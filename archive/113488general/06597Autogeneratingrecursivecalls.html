---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/06597Autogeneratingrecursivecalls.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/06597Autogeneratingrecursivecalls.html">Autogenerating recursive calls</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="185274492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Autogenerating%20recursive%20calls/near/185274492" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/06597Autogeneratingrecursivecalls.html#185274492">Wojciech Nawrocki (Jan 10 2020 at 01:24)</a>:</h4>
<p>Hello! Something I would really like for working with types that have many constructors is some kind of code generator for structural recursion in which I only want to touch some subsets of the constructors. For example, consider a simple type of formulas:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">var</span><span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">plus</span><span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">mult</span><span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
</pre></div>


<p>for which I need to write a rename-variables function that changes all 'x's to 'y's:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">rename</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span><span class="o">:</span> <span class="n">string</span><span class="o">):</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">nm</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">nm</span> <span class="bp">=</span> <span class="n">x</span> <span class="k">then</span> <span class="o">(</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">var</span> <span class="n">nm</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">plus</span> <span class="n">f₁</span> <span class="n">f₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">plus</span> <span class="o">(</span><span class="n">rename</span> <span class="n">f₁</span><span class="o">)</span> <span class="o">(</span><span class="n">rename</span> <span class="n">f₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">mult</span> <span class="n">f₁</span> <span class="n">f₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mult</span> <span class="o">(</span><span class="n">rename</span> <span class="n">f₁</span><span class="o">)</span> <span class="o">(</span><span class="n">rename</span> <span class="n">f₂</span><span class="o">)</span>
</pre></div>


<p>Most of this function is trivial and simply calls itself recursively on occurrences of the same type within constructors. Writing such functions is boring and most of the code is boilerplate. Instead, I would like a way to simply say:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">recurse</span><span class="o">]</span>
<span class="n">def</span> <span class="n">rename</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span><span class="o">:</span> <span class="n">string</span><span class="o">):</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">nm</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">nm</span> <span class="bp">=</span> <span class="n">x</span> <span class="k">then</span> <span class="o">(</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span>
</pre></div>


<p>or something similarly short and have Lean autogenerate the rest. Does anyone know if something like or close to it is possible? Has it been done in another language?<br>
(This seems like the kind of thing some variation on lenses could work for but I'm not quite sure.)</p>

<a name="185275016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Autogenerating%20recursive%20calls/near/185275016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/06597Autogeneratingrecursivecalls.html#185275016">Simon Hudon (Jan 10 2020 at 01:34)</a>:</h4>
<p>I think I would break down the problem into generating a <code>replace</code> function which looks like:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">replace</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">formula</span><span class="o">):</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">x</span> <span class="o">:=</span>
  <span class="k">match</span> <span class="n">f</span> <span class="n">x</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">y</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span>
    <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">var</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">var</span> <span class="n">v</span>
    <span class="bp">|</span> <span class="n">plus</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">plus</span> <span class="o">(</span><span class="n">replace</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">replace</span> <span class="n">y</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">mult</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">mult</span> <span class="o">(</span><span class="n">replace</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">replace</span> <span class="n">y</span><span class="o">)</span>
    <span class="kn">end</span>
  <span class="kn">end</span>
</pre></div>


<p>(not sure if that compiles) and then define your recursive function (by hand or automatically) as:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">rename</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span><span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">nm</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="err">$</span> <span class="k">if</span> <span class="n">nm</span> <span class="bp">=</span> <span class="n">x</span> <span class="k">then</span> <span class="o">(</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">none</span>

<span class="n">def</span> <span class="n">rename&#39;</span>  <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span><span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span> <span class="o">:=</span>
<span class="n">replace</span> <span class="o">(</span><span class="n">rename</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
</pre></div>

<a name="185275033"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Autogenerating%20recursive%20calls/near/185275033" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/06597Autogeneratingrecursivecalls.html#185275033">Simon Hudon (Jan 10 2020 at 01:35)</a>:</h4>
<p>The code for <code>replace</code> can be generated using the <code>induction</code> tactic.</p>

<a name="185282186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Autogenerating%20recursive%20calls/near/185282186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/06597Autogeneratingrecursivecalls.html#185282186">Tim Daly (Jan 10 2020 at 04:50)</a>:</h4>
<p>Actually, no. All the hash function is doing is checking that the proof object is unchanged. Lean could concatenate a version number to the proof it gives to Axiom (for the GCD, for example). When Axiom returns the GCD computation, Lean has to decide to trust the result. So Axiom provides the proof that Lean initially provided for GCD (which Axiom stored a long time ago) and the hash code. Lean can then concatenate the version number of the proof checker to the proof source code, compute the hash and compare it to the prior hash. If either the version number is wrong or the proof text has changed then the hash won't match.</p>
<p>A hash mismatch due to a version number change on Lean's proof checker means that Lean needs to fully check the provided proof. If the version number hasn't changed then the proof text must have changed and Lean needs to fully check the provided proof. But if the hash matches then nothing has changed and there is evidence that the GCD proof previously passed Lean's proof checker so it doesn't need to be re-checked, saving a lot of work.</p>
<p>The hash has nothing to do with the actual method of proof.</p>
<p>The problem to solve is to scale proof checking and trusted computation to larger computations. A Groebner basis can have many steps using other algorithms and each proof of each sub-algorithm needs to be provided to Lean to be checked. A hash checker would make this a very low cost but very trustable operation.</p>

<a name="185282641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Autogenerating%20recursive%20calls/near/185282641" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/06597Autogeneratingrecursivecalls.html#185282641">Tim Daly (Jan 10 2020 at 05:00)</a>:</h4>
<p>The cryptographic idea that directly applies is called HMAC.key-hashed message authentication codes.</p>

<a name="185302002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Autogenerating%20recursive%20calls/near/185302002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/06597Autogeneratingrecursivecalls.html#185302002">Wojciech Nawrocki (Jan 10 2020 at 11:30)</a>:</h4>
<p>Thanks Simon! <code>replace</code> doesn't compile but a version where the structural recursion is top-level does:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">replace₂</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">formula</span><span class="o">):</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">z</span><span class="bp">@</span><span class="o">(</span><span class="n">var</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">f</span> <span class="n">z</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">y</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">z</span>
  <span class="kn">end</span>
<span class="bp">|</span> <span class="n">z</span><span class="bp">@</span><span class="o">(</span><span class="n">plus</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">f</span> <span class="n">z</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">y</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">plus</span> <span class="o">(</span><span class="n">replace₂</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">replace₂</span> <span class="n">y</span><span class="o">)</span>
  <span class="kn">end</span>
<span class="bp">|</span> <span class="n">z</span><span class="bp">@</span><span class="o">(</span><span class="n">mult</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">f</span> <span class="n">z</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">some</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">y</span>
  <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">mult</span> <span class="o">(</span><span class="n">replace₂</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">replace₂</span> <span class="n">y</span><span class="o">)</span>
  <span class="kn">end</span>
</pre></div>


<p>It works for the simple case, however I should have been more specific in that I also want to consider functions which may include arbitrary processing of recursive results, e.g.</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">recurse</span><span class="o">]</span>
<span class="n">def</span> <span class="n">rename</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span><span class="o">:</span> <span class="n">string</span><span class="o">):</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">nm</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">nm</span> <span class="bp">=</span> <span class="n">x</span> <span class="k">then</span> <span class="o">(</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">var</span> <span class="n">nm</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">plus</span> <span class="n">f₁</span> <span class="n">f₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">mult</span> <span class="o">(</span><span class="n">rename</span> <span class="n">f₁</span><span class="o">)</span> <span class="o">(</span><span class="n">rename</span> <span class="n">f₂</span><span class="o">)</span>
</pre></div>


<p>which I'm not sure generalize into a single higher-order function since then one cannot call <code>replace</code> from <code>rename</code>. This is the reason why I asked about code generation. I guess that's what tactics do and <code>induction</code> is a good shout for going some way towards shorter definitions.</p>

<a name="185307320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Autogenerating%20recursive%20calls/near/185307320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/06597Autogeneratingrecursivecalls.html#185307320">Simon Hudon (Jan 10 2020 at 12:55)</a>:</h4>
<p>Let's try this again, then.</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">rewrite</span> <span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span><span class="o">):</span> <span class="n">formula</span> <span class="bp">→</span> <span class="n">formula</span>
<span class="bp">|</span> <span class="n">e</span><span class="bp">@</span><span class="o">(</span><span class="n">var</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">e</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">plus</span> <span class="n">e</span> <span class="n">e&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">(</span><span class="n">plus</span> <span class="o">(</span><span class="n">rewrite</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">rewrite</span> <span class="n">e&#39;</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">mult</span> <span class="n">e</span> <span class="n">e&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">(</span><span class="n">mult</span> <span class="o">(</span><span class="n">rewrite</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">rewrite</span> <span class="n">e&#39;</span><span class="o">))</span>
</pre></div>


<p>Then you should be able to write <code>rename</code> so that, together with <code>rewrite</code> it will form <code>rename_all</code>. What do you think?</p>


{% endraw %}

{% include archive_update.html %}