---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/84431toadditiveandtags.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html">to_additive and tags</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="172845919"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172845919" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172845919">Kevin Buzzard (Aug 09 2019 at 12:16)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">group_theory</span><span class="bp">.</span><span class="n">submonoid</span>

<span class="bp">@</span><span class="o">[</span><span class="n">to_additive</span> <span class="n">bar1</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">foo1</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">bar1</span> <span class="c1">-- ∀ (α : Type u_1) [_inst_1 : add_monoid α], 0 = 0</span>


<span class="bp">@</span><span class="o">[</span><span class="n">to_additive</span> <span class="n">bar2</span><span class="o">,</span> <span class="n">simp</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">foo2</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">bar2</span> <span class="c1">-- no simp tag</span>


<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">,</span> <span class="n">to_additive</span> <span class="n">bar3</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">foo3</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">bar3</span> <span class="c1">-- has a simp tag</span>

<span class="bp">@</span><span class="o">[</span><span class="n">extensionality</span><span class="o">,</span> <span class="n">to_additive</span> <span class="n">bar4</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">foo4</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">foo4</span> <span class="c1">-- has extensionality tag</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">bar4</span> <span class="c1">-- no extensionality tag</span>
</pre></div>


<p><code>to_additive</code> can move <code>simp</code> tags if they're put in the right place. Can it move extensionality tags? I just had to tag a couple of things manually, so there's an easy workaround, but it made me wonder.</p>

<a name="172845997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172845997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172845997">Kevin Buzzard (Aug 09 2019 at 12:18)</a>:</h4>
<p>Unrelated: the output of <code>#print</code> is quite something if the lemma is tagged with the extensionality tag.</p>

<a name="172846113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172846113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172846113">Mario Carneiro (Aug 09 2019 at 12:20)</a>:</h4>
<p>The attribute list is processed in left to right order, and when the <code>to_additive</code> attribute is called it will copy any attributes on the theorem to the additive version. So <code>to_additive</code> should always go at the end</p>

<a name="172846257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172846257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172846257">Kevin Buzzard (Aug 09 2019 at 12:22)</a>:</h4>
<p>But <code>bar4</code> is not getting the extensionality tag.</p>

<a name="172846300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172846300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172846300">Mario Carneiro (Aug 09 2019 at 12:23)</a>:</h4>
<p>ugh, lean core failed me again</p>
<div class="codehilite"><pre><span></span><span class="n">meta</span> <span class="n">def</span> <span class="n">transport_with_dict</span> <span class="o">(</span><span class="n">dict</span> <span class="o">:</span> <span class="n">name_map</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">src</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">(</span><span class="n">tgt</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">command</span> <span class="o">:=</span>
<span class="n">copy_decl_using</span> <span class="n">dict</span> <span class="n">src</span> <span class="n">tgt</span>
<span class="bp">&gt;&gt;</span> <span class="n">copy_attribute</span> <span class="bp">`</span><span class="kn">reducible</span> <span class="n">src</span> <span class="n">tt</span> <span class="n">tgt</span>
<span class="bp">&gt;&gt;</span> <span class="n">copy_attribute</span> <span class="bp">`</span><span class="n">simp</span> <span class="n">src</span> <span class="n">tt</span> <span class="n">tgt</span>
<span class="bp">&gt;&gt;</span> <span class="n">copy_attribute</span> <span class="bp">`</span><span class="kn">instance</span> <span class="n">src</span> <span class="n">tt</span> <span class="n">tgt</span>
</pre></div>

<a name="172846452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172846452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172846452">Mario Carneiro (Aug 09 2019 at 12:25)</a>:</h4>
<p>then again, there is probably a reason why it isn't copying <em>all</em> attributes on the original. For instance it would be a bad idea to copy <code>to_additive</code></p>

<a name="172846906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172846906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172846906">Kevin Buzzard (Aug 09 2019 at 12:32)</a>:</h4>
<p><code>to_additive</code> is better than nothing, but it is still rather inadequate. I have got 30 definitions and theorems about submonoids with a PR which is ready to go other than the fact that I have to to-additive everything. I have namespaces and variables and it would be wonderful just to get everything working with <code>@[to_additive ...]</code> because that way one doesn't have to write the proofs twice.  But there are many obstructions to doing this. Here's an example of a definition with problems:</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm">- A submonoid is closed under multiplication. -/</span>
<span class="bp">@</span><span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">add_mem</span><span class="o">]</span>
<span class="n">def</span> <span class="n">mul_mem</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">M</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">S</span> <span class="o">:=</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">mul_mem&#39;</span> <span class="n">S</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">add_mem</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_1</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">mul_mem</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_1</span>
</pre></div>


<p><code>to_additive</code> defines <code>add_mem</code>, but I have to manually tag <code>eqn_1</code>. The other problem with this approach is that add_mem does not get a docstring.</p>
<p>Here's a worse issue; a complicated definition.</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm">- A directed union of submonoids is a submonoid. -/</span>
<span class="bp">@</span><span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">Union_of_directed</span><span class="o">]</span>
<span class="n">def</span> <span class="n">Union_of_directed</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">hι</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">ι</span><span class="o">]</span>
  <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">submonoid</span> <span class="n">M</span><span class="o">)</span>
  <span class="o">(</span><span class="n">directed</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">s</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">s</span> <span class="n">k</span> <span class="bp">∧</span> <span class="n">s</span> <span class="n">j</span> <span class="bp">≤</span> <span class="n">s</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">submonoid</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="o">(</span><span class="err">⋃</span><span class="n">i</span><span class="o">,</span> <span class="n">s</span> <span class="n">i</span><span class="o">),</span>
  <span class="n">one_mem&#39;</span> <span class="o">:=</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">i</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">hι</span> <span class="k">in</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_Union</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">one_mem</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">mul_mem&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span>
    <span class="k">let</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_Union</span><span class="bp">.</span><span class="mi">1</span> <span class="n">ha</span> <span class="k">in</span>
    <span class="k">let</span> <span class="bp">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">hj</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_Union</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hb</span> <span class="k">in</span>
    <span class="k">let</span> <span class="bp">⟨</span><span class="n">k</span><span class="o">,</span> <span class="n">hk</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">directed</span> <span class="n">i</span> <span class="n">j</span> <span class="k">in</span>
    <span class="n">set</span><span class="bp">.</span><span class="n">mem_Union</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="n">s</span> <span class="n">k</span><span class="o">)</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="o">(</span><span class="n">hk</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hi</span><span class="o">)</span> <span class="o">(</span><span class="n">hk</span><span class="bp">.</span><span class="mi">2</span> <span class="n">hj</span><span class="o">)</span><span class="bp">⟩</span> <span class="o">}</span>
</pre></div>


<p>Here <code>to_additive</code> fails to port the theorem, and my understanding of the error is that <code>submonoid.Union_of_directed._match_1</code> has not been tagged with <code>to_additive</code> -- but I don't see anywhere where I have a chance to tag this. If I close the namespace now and add the additive version manually (copying and pasting the code, which in my mind already indicates something is wrong) then I have to set up all my variables again. If instead I decide to close the namespace after I've formalised all 20 lemmas/definitions then it gets to the point where even the lemmas stop working because not enough earlier stuff has been tagged. Together with the docstring issue it seems to me that currently the best way to deal with this is simply to prove a bunch of stuff in a submonoid namespace and then simply prove everything again in an add_submonoid namespace and port the proofs manually. That way I can get docstrings as well. But then I have to go through all this rigmarole of tagging all the _match and _eqn1 stuff , and, more importantly, <em>I never use <code>to_additive</code> myself at all</em>.</p>

<a name="172847028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847028" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847028">Kevin Buzzard (Aug 09 2019 at 12:34)</a>:</h4>
<p>In short: it seems to me that Lean best practice is to avoid to_additive when the going gets tough.</p>

<a name="172847067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847067" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847067">Kevin Buzzard (Aug 09 2019 at 12:34)</a>:</h4>
<p><span class="user-mention" data-user-id="110193">@Cyril Cohen</span> do you have these problems in Coq? Do you have additive groups and multiplicative groups, and a system for porting definitions / theorems in one domain to the other?</p>

<a name="172847145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847145">Kevin Buzzard (Aug 09 2019 at 12:36)</a>:</h4>
<p>I am bundling submonoids and add_submonoids and coming to the conclusion that our infrastructure for helping is giving me literally nothing more than the fact that the work I have to do is <em>more</em> than doubled, instead of just doubled.</p>

<a name="172847213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847213">Mario Carneiro (Aug 09 2019 at 12:37)</a>:</h4>
<p>why is <code>mul_mem</code> a def?</p>

<a name="172847258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847258" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847258">Kevin Buzzard (Aug 09 2019 at 12:38)</a>:</h4>
<p>Because I'm a twit.</p>

<a name="172847275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847275">Mario Carneiro (Aug 09 2019 at 12:38)</a>:</h4>
<p>if it's a theorem there is no eqn_1 to worry about</p>

<a name="172847288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847288">Kevin Buzzard (Aug 09 2019 at 12:38)</a>:</h4>
<p>I can dig out another example if you like.</p>

<a name="172847303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847303">Mario Carneiro (Aug 09 2019 at 12:38)</a>:</h4>
<p>The docstring thing would be nice, but what should it say?</p>

<a name="172847317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847317">Mario Carneiro (Aug 09 2019 at 12:39)</a>:</h4>
<p>It's possible to create a docstring for the copy</p>

<a name="172847412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847412">Kevin Buzzard (Aug 09 2019 at 12:40)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">univ</span><span class="o">]</span>
<span class="n">def</span> <span class="n">univ</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span><span class="o">,</span>
  <span class="n">one_mem&#39;</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_univ</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">mul_mem&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_univ</span> <span class="bp">_</span> <span class="o">}</span>
</pre></div>

<a name="172847421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847421">Kevin Buzzard (Aug 09 2019 at 12:40)</a>:</h4>
<p>This one fails  -- </p>
<div class="codehilite"><pre><span></span>type mismatch at application
  univ._proof_1 M _inst_3
term
  _inst_3
has type
  add_monoid M
but is expected to have type
  monoid M
</pre></div>

<a name="172847427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847427">Mario Carneiro (Aug 09 2019 at 12:40)</a>:</h4>
<p>yeah, that happens</p>

<a name="172847436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847436">Kevin Buzzard (Aug 09 2019 at 12:40)</a>:</h4>
<p>There's nothing I can do about this, right?</p>

<a name="172847445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847445">Mario Carneiro (Aug 09 2019 at 12:41)</a>:</h4>
<p>You have to transfer more things</p>

<a name="172847469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847469">Kevin Buzzard (Aug 09 2019 at 12:41)</a>:</h4>
<p>What do you mean? I have transferred everything up unto this point I think.</p>

<a name="172847490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847490">Kevin Buzzard (Aug 09 2019 at 12:41)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm">- A submonoid of a monoid α is a subset containing 1 and closed under multiplication. -/</span>
<span class="kn">structure</span> <span class="n">submonoid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">one_mem&#39;</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">∈</span> <span class="n">carrier</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_mem&#39;</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">carrier</span><span class="o">)</span>

<span class="c">/-</span><span class="cm">- An  additive submonoid of an additive monoid α is a subset containing 0 and</span>
<span class="cm">  closed under addition. -/</span>
<span class="kn">structure</span> <span class="n">add_submonoid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">add_monoid</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">zero_mem&#39;</span> <span class="o">:</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">∈</span> <span class="n">carrier</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_mem&#39;</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">carrier</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">carrier</span><span class="o">)</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="o">]</span> <span class="n">submonoid</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">carrier</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">carrier</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">cases_on</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">cases_on</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">has_sizeof_inst</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">has_sizeof_inst</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">mk</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">mk</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">inj</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">inj</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">inj_arrow</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">inj_arrow</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">inj_eq</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">inj_eq</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">sizeof_spec</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">mk</span><span class="bp">.</span><span class="n">sizeof_spec</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">add_mem&#39;</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">mul_mem&#39;</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">no_confusion</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">no_confusion</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">no_confusion_type</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">no_confusion_type</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">zero_mem&#39;</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">one_mem&#39;</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">rec</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">rec</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">rec_on</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">rec_on</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">sizeof</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">sizeof</span>
</pre></div>

<a name="172847495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847495">Kevin Buzzard (Aug 09 2019 at 12:42)</a>:</h4>
<p>I have been doing this extremely anally, trying to get the system to work.</p>

<a name="172847547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847547">Kevin Buzzard (Aug 09 2019 at 12:42)</a>:</h4>
<p>I have tagged things which will never ever be used.</p>

<a name="172847606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847606" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847606">Mario Carneiro (Aug 09 2019 at 12:42)</a>:</h4>
<p>Oh, I see, you have to do an after the fact annotation</p>

<a name="172847621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847621" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847621">Mario Carneiro (Aug 09 2019 at 12:43)</a>:</h4>
<p>like this one</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">left_rel</span> <span class="o">[</span><span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subgroup</span> <span class="n">s</span><span class="o">]</span> <span class="o">:</span> <span class="n">setoid</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">is_submonoid</span><span class="bp">.</span><span class="n">one_mem</span><span class="o">],</span>
  <span class="k">assume</span> <span class="n">x</span> <span class="n">y</span> <span class="n">hxy</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">(</span><span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span><span class="bp">⁻¹</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="k">from</span> <span class="n">is_subgroup</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hxy</span><span class="o">,</span>
  <span class="k">by</span> <span class="n">simpa</span> <span class="kn">using</span> <span class="n">this</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">hxy</span> <span class="n">hyz</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">x</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">z</span><span class="o">)</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="k">from</span> <span class="n">is_submonoid</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">hxy</span> <span class="n">hyz</span><span class="o">,</span>
  <span class="k">by</span> <span class="n">simpa</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">]</span> <span class="kn">using</span> <span class="n">this</span><span class="bp">⟩</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">left_rel</span><span class="bp">._</span><span class="n">proof_1</span><span class="o">]</span> <span class="n">left_rel</span><span class="bp">._</span><span class="n">proof_1</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">left_rel</span><span class="o">]</span> <span class="n">left_rel</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">quotient_add_group</span><span class="bp">.</span><span class="n">left_rel</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_1</span><span class="o">]</span> <span class="n">left_rel</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_1</span>
</pre></div>

<a name="172847628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847628" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847628">Kevin Buzzard (Aug 09 2019 at 12:43)</a>:</h4>
<p>But then will the additive version be auto-generated?</p>

<a name="172847641"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847641" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847641">Mario Carneiro (Aug 09 2019 at 12:43)</a>:</h4>
<p>yes</p>

<a name="172847653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847653">Mario Carneiro (Aug 09 2019 at 12:43)</a>:</h4>
<p>you just have to make sure to tag <code>foo._proof_1</code> before you tag <code>foo</code></p>

<a name="172847732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847732" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847732">Kevin Buzzard (Aug 09 2019 at 12:44)</a>:</h4>
<p>Why am I being left to discover these things myself? [because nobody wrote the docs I guess]</p>

<a name="172847760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847760">Mario Carneiro (Aug 09 2019 at 12:44)</a>:</h4>
<p>I agree that tagging new structures is horrible, because lean generates a ton of definitions and doesn't let user code know what it did</p>

<a name="172847866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847866">Kevin Buzzard (Aug 09 2019 at 12:45)</a>:</h4>
<p>I just run <code>#print prefix</code> after everything. I have been writing the code in emacs because I can automate much of the procedure which does all the post hoc tagging.</p>

<a name="172847870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847870" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847870">Kevin Buzzard (Aug 09 2019 at 12:45)</a>:</h4>
<p>But it's still a pain.</p>

<a name="172847937"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847937" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847937">Mario Carneiro (Aug 09 2019 at 12:46)</a>:</h4>
<p>I tried setting up <code>to_additive</code> so that it would copy everything in the namespace, but this turns out to be really slow because there is no index for that so you have to basically go through every definition in the environment to find which ones were added just a few lines ago</p>

<a name="172847963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847963">Mario Carneiro (Aug 09 2019 at 12:46)</a>:</h4>
<p>basically we're painted into a corner by lean 3</p>

<a name="172847977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847977" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847977">Chris Hughes (Aug 09 2019 at 12:46)</a>:</h4>
<p>Is it slower than a human copying everything in the namespace?</p>

<a name="172847984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847984">Kevin Buzzard (Aug 09 2019 at 12:47)</a>:</h4>
<p>Ha ha!</p>

<a name="172847988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172847988" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172847988">Mario Carneiro (Aug 09 2019 at 12:47)</a>:</h4>
<p>we might be able to do it with a hole command?</p>

<a name="172848002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172848002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172848002">Kevin Buzzard (Aug 09 2019 at 12:47)</a>:</h4>
<p>[gets back to tagging]</p>

<a name="172848280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172848280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172848280">Kevin Buzzard (Aug 09 2019 at 12:51)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm">- `univ` is the submonoid M of the monoid M -/</span>
<span class="n">def</span> <span class="n">univ</span> <span class="o">:</span> <span class="n">submonoid</span> <span class="n">M</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">carrier</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span><span class="o">,</span>
  <span class="n">one_mem&#39;</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_univ</span> <span class="mi">1</span><span class="o">,</span>
  <span class="n">mul_mem&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_univ</span> <span class="bp">_</span> <span class="o">}</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">univ</span><span class="bp">._</span><span class="n">proof_1</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">univ</span><span class="bp">._</span><span class="n">proof_1</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">univ</span><span class="bp">._</span><span class="n">proof_2</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">univ</span><span class="bp">._</span><span class="n">proof_2</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">univ</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">univ</span>
<span class="n">attribute</span> <span class="o">[</span><span class="n">to_additive</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_1</span><span class="o">]</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_1</span>
</pre></div>


<p>So this does work and the additive version is indeed auto-generated; I hadn't understood that I could do that after the fact. Now how do I do the docstring?</p>

<a name="172848431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172848431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172848431">Kevin Buzzard (Aug 09 2019 at 12:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="n">submonoid</span><span class="bp">.</span><span class="n">univ</span> <span class="c1">-- hover to see docstring</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">add_submonoid</span><span class="bp">.</span><span class="n">univ</span> <span class="c1">-- works but no docstring</span>
</pre></div>

<a name="172848534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive%20and%20tags/near/172848534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/84431toadditiveandtags.html#172848534">Kevin Buzzard (Aug 09 2019 at 12:55)</a>:</h4>
<p>[The point here is that the attributes have to be set in the right order]</p>


{% endraw %}

{% include archive_update.html %}