---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/96965hugetermtrees.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html">huge term trees</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="185818122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185818122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185818122">Daniel Selsam (Jan 16 2020 at 14:17)</a>:</h4>
<p>I have been doing more performance analysis on mathlib, and I found something rather intriguing. At some point during compilation, there is a typeclass <strong>goal</strong> with a ~1GB string representation. The consequences of such huge term trees are subtle. Although I did not compute the size of the term DAG (as opposed to the term tree), my suspicion is that it is relatively small. Most modules in Lean3 (and Lean4) are careful to traverse expressions as DAGs instead of as trees, and for these modules, explosion in term tree sizes may not have much ill-effect. Indeed, typeclass synthesis only takes 5ms for this example despite the enormous term tree size. However, not all modules are designed to avoid this blowup, and so huge term trees do carry the risk of massive slowdowns in some parts of the system. In some cases, Lean has even been consciously removing support for efficiently handling huge term trees, since many of the things it seems to require actually hurt performance in the majority of cases. In particular, there is no current plan for Lean4 to address performance problems arising from huge term trees.</p>
<p>What is causing these huge term trees? Can you design the libraries in a way that avoids this blowup?</p>

<a name="185818133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185818133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185818133">Daniel Selsam (Jan 16 2020 at 14:17)</a>:</h4>
<p>In case it helps, here are the first 1,000 characters of the typeclass goal mentioned above:</p>
<p>"""<br>
decidable (Pi {X : category_theory.functor.{v‚ÇÅ (max u‚ÇÇ v‚ÇÉ) u‚ÇÅ (max v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ)} C ùíû (category_theory.functor.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞) (category_theory.functor.category.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞)} {Y : category_theory.functor.{v‚ÇÅ (max u‚ÇÇ v‚ÇÉ) u‚ÇÅ (max v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ)} C ùíû (category_theory.functor.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞) (category_theory.functor.category.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞)} {Z : category_theory.functor.{v‚ÇÅ (max u‚ÇÇ v‚ÇÉ) u‚ÇÅ (max v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ)} C ùíû (category_theory.functor.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞) (category_theory.functor.category.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞)} (f : category_theory.has_hom.hom.{(max u‚ÇÅ u‚ÇÇ v‚ÇÉ) (max v‚ÇÅ (max u‚ÇÇ v‚ÇÉ) u‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ)} (category_theory.functor.{v‚ÇÅ (max u‚ÇÇ v‚ÇÉ) u‚ÇÅ (max v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ)} C ùíû (category_theory.functor.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞) (category_theory.functor.category.{v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ} D ùíü E ‚Ñ∞)) (category_theory.category_struct.to_has_hom.{(max u‚ÇÅ u‚ÇÇ v‚ÇÉ) (max v‚ÇÅ (max u‚ÇÇ v‚ÇÉ) u‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ)} (category_theory.functor.{v‚ÇÅ (max u‚ÇÇ v‚ÇÉ) u‚ÇÅ (max v‚ÇÇ v‚ÇÉ u‚ÇÇ u‚ÇÉ)} C ùíû (category_theory.functor.{v‚ÇÇ v‚ÇÉ '<br>
"""</p>

<a name="185818383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185818383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185818383">Daniel Selsam (Jan 16 2020 at 14:20)</a>:</h4>
<p>And here is a toy pattern that could explain:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">C1</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>  <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span><span class="o">:</span><span class="n">Unit</span><span class="o">:=())</span>
<span class="kn">instance</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>  <span class="o">:</span> <span class="n">C1</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="n">class</span> <span class="n">C2</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span><span class="o">:</span><span class="n">Unit</span><span class="o">:=())</span>
<span class="kn">instance</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="n">C2</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="n">class</span> <span class="n">C3</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C2</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span><span class="o">:</span><span class="n">Unit</span><span class="o">:=())</span>
<span class="kn">instance</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C2</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="n">C3</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="n">class</span> <span class="n">C4</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C2</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C3</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span><span class="o">:</span><span class="n">Unit</span><span class="o">:=())</span>
<span class="kn">instance</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C2</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C3</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="n">C4</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="n">class</span> <span class="n">C5</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C2</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C3</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C4</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span><span class="o">:</span><span class="n">Unit</span><span class="o">:=())</span>
<span class="kn">instance</span> <span class="o">(</span><span class="n">Œ±</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">C1</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C2</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C3</span> <span class="n">Œ±</span><span class="o">]</span> <span class="o">[</span><span class="n">C4</span> <span class="n">Œ±</span><span class="o">]</span>  <span class="o">:</span> <span class="n">C5</span> <span class="n">Œ±</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="c1">-- and so on</span>
</pre></div>

<a name="185818568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185818568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185818568">Johan Commelin (Jan 16 2020 at 14:23)</a>:</h4>
<p>First of all: Thanks for all your efforts. The Lean 4 team is doing a really great job!<br>
That said:</p>
<blockquote>
<p>Can you design the libraries in a way that avoids this blowup?</p>
</blockquote>
<p>I understand this question. But my first reaction is: mathematicians shouldn't have to care...</p>

<a name="185818655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185818655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185818655">Johan Commelin (Jan 16 2020 at 14:24)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Do you have the name and line numbers for this instance in mathlib?</p>

<a name="185863167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185863167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185863167">Mario Carneiro (Jan 16 2020 at 21:31)</a>:</h4>
<blockquote>
<p>In particular, there is no current plan for Lean4 to address performance problems arising from huge term trees.</p>
</blockquote>
<p>This is a bad idea. Large trees before deduplication is an inevitable consequence of dependent type theory due to redundancy inside types and dependent arguments. This will be <em>the</em> thing that we will all notice and hope to be improved in the next version if you don't fix it now.</p>

<a name="185863279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185863279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185863279">Mario Carneiro (Jan 16 2020 at 21:32)</a>:</h4>
<p>There is a coq paper about typeclass slowness using exactly your C1-C5 example</p>

<a name="185864985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185864985" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185864985">Daniel Selsam (Jan 16 2020 at 21:49)</a>:</h4>
<blockquote>
<p>There is a coq paper about typeclass slowness using exactly your C1-C5 example</p>
</blockquote>
<p>Using unbundled typeclasses.</p>

<a name="185865318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185865318">Mario Carneiro (Jan 16 2020 at 21:49)</a>:</h4>
<p>I think that's what you are doing in the example as well</p>

<a name="185865442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185865442">Mario Carneiro (Jan 16 2020 at 21:50)</a>:</h4>
<p>the parameters are stacking up, and each one refers to all the previous, so instances on C5 are already O(n^5)</p>

<a name="185865456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185865456">Daniel Selsam (Jan 16 2020 at 21:50)</a>:</h4>
<blockquote>
<p>I think that's what you are doing in the example as well</p>
</blockquote>
<p>Yes, but that is not the way typeclasses are generally used in mathlib.</p>

<a name="185865489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185865489">Mario Carneiro (Jan 16 2020 at 21:50)</a>:</h4>
<p>It is, when more types get involved</p>

<a name="185865534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185865534">Mario Carneiro (Jan 16 2020 at 21:51)</a>:</h4>
<p>For example <code>module A B</code> needs <code>ring A</code> and <code>add_group B</code> as parameters</p>

<a name="185865562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185865562">Johan Commelin (Jan 16 2020 at 21:51)</a>:</h4>
<p>And <code>topological_vector_space</code> needs ...</p>

<a name="185865568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185865568">Mario Carneiro (Jan 16 2020 at 21:51)</a>:</h4>
<p>I'm not exactly sure where your example is coming from but category theory has a similar problem with mandatory dependencies</p>

<a name="185865710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185865710">Daniel Selsam (Jan 16 2020 at 21:53)</a>:</h4>
<p>Yes but <code>ring A</code> and <code>add_group B</code> internally bundle many layers. Do you know which class in mathlib takes the most instance parameters? It seems harder to accidentally take a ton of instance parameters in Lean since it doesn't support the implicit generalization that Coq does.</p>

<a name="185865766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185865766">Mario Carneiro (Jan 16 2020 at 21:53)</a>:</h4>
<p>topological vector space is probably a contender</p>

<a name="185865820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185865820">Johan Commelin (Jan 16 2020 at 21:54)</a>:</h4>
<p>complete topological vector space?</p>

<a name="185865827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865827" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185865827">Daniel Selsam (Jan 16 2020 at 21:54)</a>:</h4>
<p>In Coq, the same example looks harmless :</p>
<div class="codehilite"><pre><span></span><span class="kn">Class</span> <span class="n">C1</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">:</span> <span class="kn">Set</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Instance</span> <span class="n">I1</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">:</span> <span class="n">C1</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Class</span> <span class="n">C2</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C1</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="kn">Set</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Instance</span> <span class="n">I2</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C1</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">C2</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Class</span> <span class="n">C3</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C2</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="kn">Set</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Instance</span> <span class="n">I3</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C2</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">C3</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Class</span> <span class="n">C4</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C3</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="kn">Set</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Instance</span> <span class="n">I4</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C3</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">C4</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Class</span> <span class="n">C5</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C4</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="kn">Set</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Instance</span> <span class="n">I5</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kn">Set</span><span class="o">)</span> <span class="o">`{</span><span class="n">C4</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">C5</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">{}.</span>
<span class="kn">Example</span> <span class="n">failing_tower</span> <span class="o">:</span> <span class="n">C5</span> <span class="n">unit</span> <span class="o">:=</span> <span class="o">_.</span>
</pre></div>

<a name="185865855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185865855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185865855">Mario Carneiro (Jan 16 2020 at 21:54)</a>:</h4>
<p>I recall that being a feature request on lean 3</p>

<a name="185866009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185866009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185866009">Patrick Massot (Jan 16 2020 at 21:56)</a>:</h4>
<p>Looking harmless was a feature request?</p>

<a name="185866070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185866070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185866070">Mario Carneiro (Jan 16 2020 at 21:56)</a>:</h4>
<p>Being able to write <code>[module A B]</code> and getting <code>{A} {B} [ring A] [add_group B] [module A B]</code> automatically</p>

<a name="185866134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185866134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185866134">Mario Carneiro (Jan 16 2020 at 21:57)</a>:</h4>
<p>This is very nice when you are doing e.g. linear algebra between two or three vector spaces</p>

<a name="185866161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185866161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185866161">Patrick Massot (Jan 16 2020 at 21:57)</a>:</h4>
<p>Oooh...</p>

<a name="185866243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185866243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185866243">Patrick Massot (Jan 16 2020 at 21:58)</a>:</h4>
<p>I didn't even know you could ask Santa Claus to get that.</p>

<a name="185866296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185866296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185866296">Kevin Buzzard (Jan 16 2020 at 21:59)</a>:</h4>
<p>It would be delicate to get right -- if B was already an add_group for some other reason then you don't want to add it again.</p>

<a name="185866403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185866403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185866403">Mario Carneiro (Jan 16 2020 at 22:00)</a>:</h4>
<p>I would have pointed to the issue page but they are all gone :(</p>

<a name="185876715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185876715" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185876715">Daniel Selsam (Jan 17 2020 at 00:26)</a>:</h4>
<blockquote>
<blockquote>
<p>In particular, there is no current plan for Lean4 to address performance problems arising from huge term trees.</p>
</blockquote>
<p>This is a bad idea. Large trees before deduplication is an inevitable consequence of dependent type theory due to redundancy inside types and dependent arguments. It's not a thing you can easily work around as a user. This will be <em>the</em> thing that we will all notice and hope to be improved in the next version if you don't fix it at this early stage.</p>
</blockquote>
<p>I agree that it <em>might</em> be this critical, but I have don't have enough information yet to have an informed opinion. In particular, there might be acceptable ways of keeping the heights of these towers acceptably bounded, and the possible backend solutions might all have substantial downsides. For now, let us all work together to investigate the problem and to assess our options.</p>

<a name="185876962"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185876962" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185876962">Daniel Selsam (Jan 17 2020 at 00:30)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> Do you have the name and line numbers for this instance in mathlib?</p>
</blockquote>
<p>Unfortunately, no. This would take quite a bit more bookkeeping, and I won't have time or CPU cycles for this for several days. Is somebody else able to investigate in the meantime with the new (and much improved) leancrawler? It is very well-documented. Here is what I suggest to start: create a lean file that imports all of mathlib, export it to a <code>.yaml</code> as described in the README, and run a simple script like the following:</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">crawler</span> <span class="kn">import</span> <span class="n">LeanLib</span>
<span class="kn">import</span> <span class="nn">networkx</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading export.yaml&quot;</span><span class="p">)</span>
<span class="n">lib</span> <span class="o">=</span> <span class="n">LeanLib</span><span class="o">.</span><span class="n">from_yaml</span><span class="p">(</span><span class="s1">&#39;FindBig&#39;</span><span class="p">,</span> <span class="s1">&#39;export.yaml&#39;</span><span class="p">)</span>

<span class="n">decls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lib</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Top-10 biggest decls by type:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">decls</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">decl</span><span class="p">:</span> <span class="o">-</span> <span class="n">decl</span><span class="o">.</span><span class="n">type_size</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">decl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">decls</span><span class="p">[:</span><span class="mi">10</span><span class="p">]):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">decl</span><span class="o">.</span><span class="n">type_size</span><span class="p">,</span> <span class="n">decl</span><span class="o">.</span><span class="n">type_dedup_size</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Top-10 biggest decls by value:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">decls</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">decl</span><span class="p">:</span> <span class="o">-</span> <span class="n">decl</span><span class="o">.</span><span class="n">value_size</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">decl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">decls</span><span class="p">[:</span><span class="mi">10</span><span class="p">]):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">decl</span><span class="o">.</span><span class="n">value_size</span><span class="p">,</span> <span class="n">decl</span><span class="o">.</span><span class="n">value_dedup_size</span><span class="p">)</span>
</pre></div>

<a name="185877007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185877007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185877007">Daniel Selsam (Jan 17 2020 at 00:31)</a>:</h4>
<p>I just ran this, but only importing a few mathlib theories. This was the output:</p>
<div class="codehilite"><pre><span></span>Top-10 biggest decls by type:

category_theory.limits.is_colimit.hom_desc 35592 1159
category_theory.limits.is_limit.hom_lift 7508 1350
gcd_domain.mk.inj 6650 3306
gcd_domain.mk.inj_arrow 6643 3319
algebraic_geometry.PresheafedSpace.ext 6407 549
decidable_linear_ordered_semiring.mk.inj 6387 3709
decidable_linear_ordered_semiring.mk.inj_arrow 6378 3758
lattice.complete_boolean_algebra.mk.inj 6252 4008
lattice.complete_boolean_algebra.mk.inj_arrow 6241 4025
linear_ordered_semiring.mk.inj 5958 3444

Top-10 biggest decls by value:

filter.is_lawful_monad 100044499 36343
algebraic_geometry.PresheafedSpace.stalk_map.comp 63928223 16816
emetric.countable_closure_of_compact 6553913 35855
real.exists_sup 6422084 11798
Top.presheaf.stalk_pushforward.comp 4524414 13016
category_theory.equivalence.unit_inverse_comp 3779575 9474
is_measurable.diff_null 1158921 7082
set.is_lawful_monad 987060 26209
free_group.is_lawful_monad 961500 23022
Top.presheaf.stalk_pushforward.id 899051 5074
</pre></div>

<a name="185879772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/huge%20term%20trees/near/185879772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/96965hugetermtrees.html#185879772">Daniel Selsam (Jan 17 2020 at 01:29)</a>:</h4>
<p>Also, to stress: most parts of the system are very careful to only traverse terms as DAGs. So, even with the status quo I don't think a term with a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> tree-to-DAG ratio would in general suffer anywhere near <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> overhead overall. But if 10 becomes 20 or 30, then any weak link anywhere in the system could cause epic slowdowns.</p>


{% endraw %}

{% include archive_update.html %}