---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/74934Trustdowntothemetal.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html">Trust "down to the metal"</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="184716541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184716541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184716541">Tim Daly (Jan 03 2020 at 07:54)</a>:</h4>
<p>While building a trusted computer algebra system, the SANE version of Axiom, I've been looking at questions of trust at all levels.</p>
<p>Andrej Bauer has been working on a smaller kernel (a nucleus) that separates the trust from the logic. The rules of the logic can be specified as  needed but checked by the nucleus code.</p>
<p>I've been studying Field Programmable Gate Arrays (FPGA) that allow you to create your own hardware in a C-like language (Verilog). It allows you to check the chip you build all the way down to the transistor states. You can create things as complex as a whole CPU or as simple as a trusted nucleus (youtube: Building a CPU on an FPGA). ACL2 has a history of verifying hardware logic.</p>
<p>It appears that, assuming I can understand Bauer's Andromeda system, it would be possible and not all that hard to implemented a trusted kernel on an FPGA the size and form factor of a USB stick.</p>
<p>Trust "down to the metal"</p>

<a name="184717893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184717893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184717893">Johan Commelin (Jan 03 2020 at 08:26)</a>:</h4>
<p><span class="user-mention" data-user-id="223495">@Tim Daly</span> You should also read Mario's metamath zero paper. One of his goals/applications is trust at all levels.</p>

<a name="184717917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184717917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184717917">Johan Commelin (Jan 03 2020 at 08:27)</a>:</h4>
<p>You can see here <a href="https://github.com/digama0/mm0/tree/master/examples" target="_blank" title="https://github.com/digama0/mm0/tree/master/examples">https://github.com/digama0/mm0/tree/master/examples</a> that he has been formalising x86 and such</p>

<a name="184721500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184721500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184721500">Tim Daly (Jan 03 2020 at 09:41)</a>:</h4>
<p>Yes, I've seen that repo.</p>
<p>The problem with the x86 is the instruction semantics. I wrote a program that generates the x86 instruction semantics (as conditional-concurrent assignments) which we used for reverse-engineering malware (<a href="http://daly.axiom-developer.org/TimothyDaly_files/publications/sei/intel/intel.pdf" target="_blank" title="http://daly.axiom-developer.org/TimothyDaly_files/publications/sei/intel/intel.pdf">http://daly.axiom-developer.org/TimothyDaly_files/publications/sei/intel/intel.pdf</a>). The x86 is a complex beast. Writing the semantics took 3 years. </p>
<p>On the other hand, an FPGA is small, has gate-level timing, and is an ideal platform for nucleus and kernel level semantics.<br>
You can do all the dancing you want at any level and then "run it through the hardware". Assuming your implementation provides independent proof checking it would not matter whether you used Coq, Lean, or something else.</p>

<a name="184721565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Trust%20%22down%20to%20the%20metal%22/near/184721565" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74934Trustdowntothemetal.html#184721565">Tim Daly (Jan 03 2020 at 09:42)</a>:</h4>
<p>In addition, Bauer's approach lets you choose your logic.</p>


{% endraw %}

{% include archive_update.html %}