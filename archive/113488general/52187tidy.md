---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/52187tidy.html
---

## Stream: [general](index.html)
### Topic: [tidy](52187tidy.html)

---


{% raw %}
#### [ Patrick Massot (Aug 28 2018 at 20:56)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/132940411):
<p><code>tidy</code> has been merged! <span class="emoji emoji-1f389" title="tada">:tada:</span> <span class="emoji emoji-1f389" title="tada">:tada:</span> <span class="emoji emoji-1f389" title="tada">:tada:</span></p>

#### [ Kevin Buzzard (Aug 28 2018 at 21:00)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/132940649):
<p>Mathlib is looking in really good shape at the minute. Many unmerged things are either WIPs or very new.</p>

#### [ Reid Barton (Sep 18 2018 at 17:40)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134173949):
<p><span class="user-mention" data-user-id="110524">@Scott Morrison</span> does mathlib's <code>tidy</code> not contain "backwards reasoning"? Or am I just not seeing it?</p>

#### [ Patrick Massot (Sep 18 2018 at 17:44)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134174192):
<p>At least the version merged in Orsay didn't</p>

#### [ Reid Barton (Sep 18 2018 at 17:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134175055):
<p>I see. That throws a minor <span class="emoji emoji-1f527" title="wrench">:wrench:</span> in my <code>continuity</code> plans, but nothing too serious</p>

#### [ Patrick Massot (Sep 18 2018 at 17:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134175083):
<p>Actually I'm curious to know why we got that nerfed <code>tidy</code></p>

#### [ Keeley Hoek (Sep 18 2018 at 18:05)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134175465):
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> not Scott but that's currently still chilling out in <a href="https://github.com/semorrison/lean-tidy/tree/master/src/tidy" target="_blank" title="https://github.com/semorrison/lean-tidy/tree/master/src/tidy">https://github.com/semorrison/lean-tidy/tree/master/src/tidy</a></p>

#### [ Reid Barton (Sep 18 2018 at 18:12)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134175925):
<p>Thanks Keeley!<br>
Patrick, I wonder too. It looks like <code>backwards_reasoning</code> is fairly simple.</p>

#### [ Reid Barton (Sep 18 2018 at 18:29)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134176805):
<p>In particular I'm not sure whether I should try to PR backwards_reasoning into mathlib, or roll my own version to use in continuity</p>

#### [ Scott Morrison (Sep 18 2018 at 22:25)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134190776):
<p>No, it's not there yet. It wasn't necessary for the early parts of the<br>
category theory library, so I took it out just to reduce the initial PR<br>
footprint.</p>

#### [ Scott Morrison (Sep 19 2018 at 03:09)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134203898):
<p>I agree it would be good to get in soon. It was written before <code>ext</code> was available, and the appearance of <code>ext</code> took away a lot of the need for the "more aggressive" <code>backwards_reasoning</code>.</p>

#### [ Scott Morrison (Sep 19 2018 at 03:09)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134203908):
<p>I think it would be worth rewriting <code>backwards_reasoning</code> one more time, looking to see what we can share with <code>ext</code>.</p>

#### [ Scott Morrison (Sep 19 2018 at 03:10)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134203956):
<p>I'm trying to catch up on non-Lean life this week, so if someone wants to go ahead with a PR, please do, otherwise I'll do it "soon".</p>

#### [ Scott Morrison (Sep 20 2018 at 12:48)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134300961):
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>, <span class="user-mention" data-user-id="110031">@Patrick Massot</span> (et al.)<br>
I've found there a two types of lemmas one frequently wants to apply backwards reasoning with. The "strong" variety are just lemmas that you always want to <code>apply</code> whenever they match. There's also a "weak" variety where you want to make sure that any hypotheses of the lemma can be immediately discharged from hypotheses.</p>

#### [ Scott Morrison (Sep 20 2018 at 12:48)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134300973):
<p>In my first implementation of <code>backwards_reasoning</code>, I introduced two attributes <code>@[back]</code> and <code>@[back']</code> for labelling the strong and weak cases.</p>

#### [ Scott Morrison (Sep 20 2018 at 12:48)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134300978):
<p>This is terrible naming!</p>

#### [ Scott Morrison (Sep 20 2018 at 12:49)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134300995):
<p>But I'm unsure what the right way to handle this is. Any suggestions welcome, and I'll get on with a <code>backwards_reasoning</code> PR.</p>

#### [ Scott Morrison (Sep 20 2018 at 12:50)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134301093):
<p>(I've decided my limits PR may be painful without having <code>backwards_reasoning</code> available.)</p>

#### [ Simon Hudon (Sep 20 2018 at 14:20)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134305714):
<p>How about <code>@[backward]</code> and <code>@[strong_back]</code>? Also, do you have an example of the kind of proof it does?</p>

#### [ Simon Hudon (Sep 20 2018 at 14:21)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134305766):
<p>You could also go with <code>@[backward strong]</code> and <code>@[backward weak]</code> with <code>weak</code> being the default?</p>

#### [ Scott Morrison (Sep 20 2018 at 14:26)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134306006):
<p>I'll (eventually) prepare some examples; at the moment everything I have is invisible, because <code>tidy</code> is just doing it in secret. :-) I think actually <code>strong</code> should be the default --- for lemmas that are "safe" to always apply, whereas <code>weak</code> is the more dangerous "you can apply this, but you have to be careful you can actually immediately solve all new goals" setting.</p>

#### [ Mario Carneiro (Sep 20 2018 at 15:00)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134307560):
<p>How about <code>@[back!]</code> and <code>@[back]</code>?</p>

#### [ Mario Carneiro (Sep 20 2018 at 15:01)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134307631):
<p>or <code>@[back]</code> and <code>@[back?]</code></p>

#### [ Reid Barton (Sep 20 2018 at 15:17)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134308545):
<p>I would just comment that the "safe"/"unsafe" terminology can be confusing--if you mark something as "safe" when it's safe to apply and "unsafe" otherwise then it's "more safe" (i.e., more likely to be correct/sound) to mark something as "unsafe" than as "safe".</p>

#### [ Reid Barton (Sep 20 2018 at 15:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134308897):
<p>For example the Haskell FFI uses <code>safe</code>/<code>unsafe</code> in the opposite sense from your terminology: <code>unsafe</code> is used to mark a function which is called "unsafely" (without any special setup/teardown), which means it had better be a function which is "safe" to call from any context (e.g., <code>sin</code>). <code>safe</code> means that the RTS will prepare a safe context from which to call the function, so it's safe to import most functions as <code>safe</code>. I'm used to this naming convention but I know some people find it confusing.</p>

#### [ Reid Barton (Sep 20 2018 at 15:28)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/134309283):
<p>Back on topic, I'm not sure I have a good intuition for which lemmas should fall into either of these two categories.</p>

#### [ Sebastien Gouezel (Oct 30 2018 at 14:11)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136775268):
<p>Is there a way to tell <code>tidy</code> that is should never unfold something, possibly with some attribute? Whenever there are real numbers involved, it unfolds them to Cauchy sequences. For instance,</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">foo</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">tidy</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>gives a goal of the form</p>
<div class="codehilite"><pre><span></span><span class="n">x_val</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">ℚ</span><span class="o">,</span>
<span class="n">x_property</span> <span class="o">:</span> <span class="n">is_cau_seq</span> <span class="n">abs</span> <span class="n">x_val</span>
<span class="err">⊢</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">quot</span><span class="bp">.</span><span class="n">mk</span> <span class="n">setoid</span><span class="bp">.</span><span class="n">r</span> <span class="bp">⟨</span><span class="n">x_val</span><span class="o">,</span> <span class="n">x_property</span><span class="bp">⟩</span>
</pre></div>

#### [ Kevin Buzzard (Oct 30 2018 at 14:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136775987):
<p>unfolding real numbers should be tagged <code>untidy</code></p>

#### [ Scott Morrison (Oct 30 2018 at 21:39)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136805385):
<p>Ugh, that is bad. :-) I'll admit I've never touched a real number in Lean!</p>

#### [ Scott Morrison (Oct 30 2018 at 21:40)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136805448):
<p>The problem is just that <code>auto_cases</code> applies first, and it, somewhat ridiculously, runs <code>induction x</code> immediately.</p>

#### [ Scott Morrison (Oct 30 2018 at 21:41)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136805492):
<p>There are certainly cases where this _is_ helpful behaviour, on the other hand.</p>

#### [ Scott Morrison (Oct 30 2018 at 21:41)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136805504):
<p>I wonder if there is a useful line to draw.</p>

#### [ Scott Morrison (Oct 30 2018 at 21:43)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136805597):
<p>One dumb solution is to just remove induction on quotients from <code>auto_cases</code> entirely, and have users of <code>tidy</code> explicitly add back in a tactic that does this (e.g. the very blunt <code>case_bash</code> tactic I have somewhere, which just tries cases on everything!)</p>

#### [ Scott Morrison (Oct 30 2018 at 21:44)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136805706):
<p>I suspect that the occasions where it makes sense to use induction on a quotient, the quotient relation is "very near at hand". But I'm having trouble thinking how to quantify/measure that.</p>

#### [ Sebastien Gouezel (Oct 31 2018 at 08:14)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136831493):
<p>Is the induction on quotients often helpful? I mean, if you remove it from <code>auto_cases</code>, does it break something in your category library? If not, I guess it is safe to remove it. Otherwise, one would need a mechanism to fine tune it, maybe with some attributes..</p>

#### [ Scott Morrison (Oct 31 2018 at 11:08)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136838627):
<p>It breaks exactly one thing, and clearly that doesn't justify the hassle caused elsewhere. I'll PR a one line change to auto_cases soon*.</p>

#### [ Scott Morrison (Oct 31 2018 at 14:12)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136850749):
<p>Ok, I've PR'd this one-line change: <a href="https://github.com/leanprover/mathlib/pull/451" target="_blank" title="https://github.com/leanprover/mathlib/pull/451">https://github.com/leanprover/mathlib/pull/451</a></p>

#### [ Sebastien Gouezel (Oct 31 2018 at 14:53)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136853102):
<p>Thanks!</p>

#### [ Scott Morrison (Oct 31 2018 at 23:29)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136885843):
<p>Huh, it turns out someone else was using <code>tidy</code> in a way that relied on induction on quotients: <a href="https://travis-ci.org/leanprover/mathlib/jobs/448843966" target="_blank" title="https://travis-ci.org/leanprover/mathlib/jobs/448843966">https://travis-ci.org/leanprover/mathlib/jobs/448843966</a></p>

#### [ Scott Morrison (Oct 31 2018 at 23:29)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136885847):
<p>I can just rewrite that proof.</p>

#### [ Scott Morrison (Oct 31 2018 at 23:30)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136885905):
<p>An alternative would be to have <code>auto_cases</code> perform induction on "things that are explicitly quotients"</p>

#### [ Scott Morrison (Oct 31 2018 at 23:30)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136885914):
<p>For one, this would include things that actually match <code>quot _</code> or <code>quotient _</code>.</p>

#### [ Scott Morrison (Oct 31 2018 at 23:30)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136885931):
<p>But for this use case I'd also want to to fire on <code>quotient_module.quotient</code>.</p>

#### [ Scott Morrison (Oct 31 2018 at 23:31)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136885944):
<p>And it seems the only way to handle that would be to make decisions based on the _name_ itself.</p>

#### [ Kevin Buzzard (Oct 31 2018 at 23:42)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136886552):
<p>Yes there's a huge difference between real numbers as quotient and quotient modules as quotients! I guess another fix would be to rewrite the real numbers as Dedekind cuts ;-)</p>

#### [ Floris van Doorn (Oct 31 2018 at 23:48)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136886818):
<p>Or make <code>real</code> irreducible (after the file <code>data.real.basic</code>) and not unfold irreducible definitions?</p>

#### [ Scott Morrison (Nov 01 2018 at 11:45)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136913655):
<p>Hmm, it seems making <code>real</code> irreducible doesn't work; lots of things fail.</p>

#### [ Scott Morrison (Nov 01 2018 at 11:46)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136913717):
<p>e.g.  <code>rw div_mul_div at this</code> producing:</p>
<div class="codehilite"><pre><span></span>/home/travis/build/leanprover/mathlib/data/real/irrational.lean:19:2: error: rewrite tactic failed, did not find instance of the pattern in the target expression
  ?m_3 / ?m_4 * (?m_5 / ?m_6)
state:
sqrt_two_irrational : irrational (sqrt 2)
n : ℤ
d : ℕ
h : d &gt; 0
c : nat.coprime (int.nat_abs n) d
e : sqrt 2 = ↑n / ↑d
d0 : 0 &lt; ↑d
this : ↑n / ↑d * (↑n / ↑d) = 2
</pre></div>

#### [ Scott Morrison (Nov 01 2018 at 11:48)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136913822):
<p>I don't really understand how reducibility caused a problem there.</p>

#### [ Chris Hughes (Nov 01 2018 at 12:13)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136914854):
<p>The issue is that this expression no longer type checks after real is made irreducible</p>
<div class="codehilite"><pre><span></span>example : @cau_seq.completion.has_mul ℚ _ ℚ _ abs _ =  (show has_mul ℝ, by apply_instance) :=
</pre></div>


<p><code>real.mul_self_sqrt</code> uses <code>cau_seq.completion.has_mul</code>, so you end up with two <code>has_mul</code>'s that are no longer reduced to the same thing.</p>

#### [ Chris Hughes (Nov 01 2018 at 12:16)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136915002):
<p>Making <code>cau_seq.completion</code> irreducible instead might be a better idea.</p>

#### [ Scott Morrison (Nov 01 2018 at 12:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136915843):
<p>Thanks! I will investigate that.</p>

#### [ Scott Morrison (Nov 01 2018 at 13:25)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136918194):
<p>Hmm, making <code>attribute [irreducible] cau_seq.completion.Cauchy</code> (is that what you had in mind, <span class="user-mention" data-user-id="110044">@Chris Hughes</span>?) seems to cause troubles later:</p>
<div class="codehilite"><pre><span></span>/Users/scott/projects/lean/mathlib/analysis/real.lean:185:29: error: type mismatch at application
</pre></div>


<p>Perhaps this is a dead-end.</p>

#### [ Chris Hughes (Nov 01 2018 at 13:27)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136918270):
<p>I tried making real irreducible immediately after <code>exists_sup</code> and that seemed to work. Two proofs in analysis broke, but they were easy to fix.</p>

#### [ Scott Morrison (Nov 01 2018 at 13:28)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136918348):
<p>Would you be interested in pursuing that to a PR? (Both because I think you'll do a better job at it that I would, and also I need to go to sleep? :-)</p>

#### [ Scott Morrison (Nov 01 2018 at 22:29)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136951464):
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> , it looks like something cropped up later:</p>
<div class="codehilite"><pre><span></span>/home/travis/build/leanprover/mathlib/analysis/bounded_linear_maps.lean:100:9: error: synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized
  normed_ring.to_ring ℝ
inferred
  domain.to_ring ℝ
</pre></div>

#### [ Chris Hughes (Nov 01 2018 at 22:46)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/136952443):
<p>I haven't managed to work out what's going on there.</p>

#### [ Chris Hughes (Nov 03 2018 at 00:14)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137088872):
<p>Done some investigation. There's some weird behaviour going on.</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">normed_ring</span><span class="bp">.</span><span class="n">to_ring</span> <span class="n">ℝ</span><span class="o">)</span><span class="bp">.</span><span class="n">zero</span> <span class="bp">=</span> <span class="n">real</span><span class="bp">.</span><span class="n">ring</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">--works</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">normed_ring</span><span class="bp">.</span><span class="n">to_ring</span> <span class="n">ℝ</span><span class="o">)</span><span class="bp">.</span><span class="n">one</span> <span class="bp">=</span> <span class="n">real</span><span class="bp">.</span><span class="n">ring</span><span class="bp">.</span><span class="n">one</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">--works</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">normed_ring</span><span class="bp">.</span><span class="n">to_ring</span> <span class="n">ℝ</span><span class="o">)</span><span class="bp">.</span><span class="n">mul</span> <span class="bp">=</span> <span class="n">real</span><span class="bp">.</span><span class="n">ring</span><span class="bp">.</span><span class="n">mul</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">--works</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">normed_ring</span><span class="bp">.</span><span class="n">to_ring</span> <span class="n">ℝ</span><span class="o">)</span><span class="bp">.</span><span class="n">add</span> <span class="bp">=</span> <span class="n">real</span><span class="bp">.</span><span class="n">ring</span><span class="bp">.</span><span class="n">add</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">--works</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">normed_ring</span><span class="bp">.</span><span class="n">to_ring</span> <span class="n">ℝ</span><span class="o">)</span><span class="bp">.</span><span class="n">add_comm</span> <span class="bp">=</span> <span class="n">real</span><span class="bp">.</span><span class="n">ring</span><span class="bp">.</span><span class="n">add_comm</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">--doesn&#39;t work</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">normed_ring</span><span class="bp">.</span><span class="n">to_ring</span> <span class="n">ℝ</span><span class="o">)</span><span class="bp">.</span><span class="n">mul_assoc</span> <span class="bp">=</span> <span class="n">real</span><span class="bp">.</span><span class="n">ring</span><span class="bp">.</span><span class="n">mul_assoc</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">--doesn&#39;t work</span>
</pre></div>


<p>Not quite sure why all the data is equal by <code>rfl</code> but none of the proofs. <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, what's happening?</p>

#### [ Mario Carneiro (Nov 03 2018 at 00:16)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137088949):
<p>I don't have the setup to test that myself right now, but if they are proofs then it should be an easy rfl, as long as the statement itself typechecks</p>

#### [ Chris Hughes (Nov 03 2018 at 00:18)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137088971):
<p>They are proofs and the statement type checks and it isn't an easy <code>rfl</code>.</p>

#### [ Chris Hughes (Nov 03 2018 at 00:18)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137089018):
<p><code>proof_irrel _ _</code> works though</p>

#### [ Chris Hughes (Nov 03 2018 at 00:19)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137089029):
<p>The context is that I made <code>real</code> irreducible in case you hadn't caught up with the discussion</p>

#### [ Mario Carneiro (Nov 03 2018 at 00:20)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137089104):
<p>is <code>normed_ring.to_ring ℝ = real.ring</code> doesn't work, I assume?</p>

#### [ Chris Hughes (Nov 03 2018 at 00:20)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137089106):
<p>That doesn't work.</p>

#### [ Mario Carneiro (Nov 03 2018 at 00:21)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137089137):
<p>How is the instance <code>normed_ring ℝ</code> defined? Is <code>normed_ring</code> an old style structure?</p>

#### [ Chris Hughes (Nov 03 2018 at 00:25)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137089285):
<p>For reals it's derived from <code>norm_field \R</code>, which is a new style structure, as is <code>normed_ring</code></p>

#### [ Mario Carneiro (Nov 03 2018 at 00:28)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137089381):
<p>In that case, the <code>normed_ring</code> instance should literally include <code>real.ring</code> as the appropriate component in its definition</p>

#### [ Chris Hughes (Nov 03 2018 at 00:31)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137089557):
<p>But that's doesn't really work, since it's defined from a general instance <code>normed_field.to_normed_ring</code></p>

#### [ Mario Carneiro (Nov 03 2018 at 00:33)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137089642):
<p>aha:</p>
<div class="codehilite"><pre><span></span>@[instance]
protected def normed_field.to_normed_ring : Π {α : Type u_1} [i : normed_field α], normed_ring α :=
λ {α : Type u_1} [i : normed_field α],
  {to_has_norm := normed_field.to_has_norm α i,
   to_ring := {add := discrete_field.add (normed_field.to_discrete_field α),
               add_assoc := _,
               zero := discrete_field.zero α (normed_field.to_discrete_field α),
               zero_add := _,
               add_zero := _,
               neg := discrete_field.neg (normed_field.to_discrete_field α),
               add_left_neg := _,
               add_comm := _,
               mul := discrete_field.mul (normed_field.to_discrete_field α),
               mul_assoc := _,
               one := discrete_field.one α (normed_field.to_discrete_field α),
               one_mul := _,
               mul_one := _,
               left_distrib := _,
               right_distrib := _},
   to_metric_space := normed_field.to_metric_space α i,
   dist_eq := _,
   norm_mul := _}
</pre></div>


<p>Apparently <code>..i</code> unfolds the ring component unnecessarily</p>

#### [ Mario Carneiro (Nov 03 2018 at 00:35)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137089729):
<p>adding <code>to_ring := by apply_instance</code> there simplifies the generated term</p>

#### [ Mario Carneiro (Nov 03 2018 at 00:35)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137089736):
<p>does that fix the issue?</p>

#### [ Chris Hughes (Nov 03 2018 at 00:44)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137090074):
<p>Yes. Thanks. I'm not sure if it's worth making reals irreducible if it generates this sort of problem however.</p>

#### [ Chris Hughes (Nov 03 2018 at 00:44)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137090089):
<p>As in, I was hoping for a solution which only changed <code>data.real.basic</code></p>

#### [ Mario Carneiro (Nov 03 2018 at 00:53)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137090402):
<p>well, I think this is a bug in structure literals, but indeed even eta expanding <code>real.ring</code> should be defeq because it's a structure. Did you mark <code>real.ring</code> irreducible?</p>

#### [ Chris Hughes (Nov 03 2018 at 00:53)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137090407):
<p>No, just <code>real</code></p>

#### [ Mario Carneiro (Nov 03 2018 at 00:56)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137090511):
<p>Oh, but then I think I can see how the problem arises... <code>real.comm_ring</code> expands to <code>cau_seq.completion.comm_ring</code>, which contains <code>real</code> internals in its type</p>

#### [ Mario Carneiro (Nov 03 2018 at 00:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137090513):
<p>you should try changing the definition to <code>real.comm_ring := {.. cau_seq.completion.comm_ring}</code></p>

#### [ Mario Carneiro (Nov 03 2018 at 00:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137090584):
<div class="codehilite"><pre><span></span>local attribute [reducible] real
</pre></div>


<p>in real.lean is a real doozy. By marking it irreducible but locally reducible, you get terms that typecheck locally, which stop typechecking later</p>

#### [ Kevin Buzzard (Nov 03 2018 at 01:00)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137090650):
<p>so you just put <code>local attribute [irredible] real</code> just afterwards, right?</p>

#### [ Mario Carneiro (Nov 03 2018 at 01:00)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137090652):
<p>well, that's the same thing</p>

#### [ Kevin Buzzard (Nov 03 2018 at 01:00)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137090655):
<p>I mean you can switch it on when you need it</p>

#### [ Mario Carneiro (Nov 03 2018 at 01:01)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137090669):
<p>I think one principle we need is that any definition which would not typecheck in the current environment (because of irreducible markings) should itself be irreducible</p>

#### [ Reid Barton (Nov 03 2018 at 01:01)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137090679):
<p>I was about to say: I haven't been following closely but I feel like we need a more principled approach to all this.</p>

#### [ Mario Carneiro (Nov 03 2018 at 01:01)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137090688):
<p>In this case, <code>real.comm_ring := cau_seq.completion.comm_ring</code> does not typecheck once the definition of real is hidden</p>

#### [ Reid Barton (Nov 03 2018 at 01:11)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137091120):
<p>I'm hopeful that the right irreducibility annotations will make the real numbers generally more pleasant to work with, but I would guess that tweaking annotations one by one is not the best way to get there. This feels related to enforcing abstraction boundaries, something Lean seems to have no capabilities for.</p>

#### [ Chris Hughes (Nov 03 2018 at 12:17)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137109695):
<p>I tried this change <code>instance : comm_ring ℝ := { ..cau_seq.completion.comm_ring }</code>, but it has the same problem. I guess the proofs still don't type check.</p>

#### [ Mario Carneiro (Nov 03 2018 at 12:21)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137109802):
<p>what about</p>
<div class="codehilite"><pre><span></span>@[irreducible] def real.comm_ring&#39; : comm_ring ℝ := cau_seq.completion.comm_ring
instance : comm_ring ℝ := {.. real.comm_ring&#39; }
</pre></div>

#### [ Chris Hughes (Nov 03 2018 at 12:23)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137109847):
<p>Breaks a lot of proofs in <code>real.basic</code></p>

#### [ Chris Hughes (Nov 03 2018 at 12:26)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137109935):
<p>It seems like making things <code>irreducible</code> after proving things about them isn't really practical.</p>

#### [ Mario Carneiro (Nov 03 2018 at 12:35)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137110157):
<p>you may have to do the same trickery with local reducible, global irreducible</p>

#### [ Chris Hughes (Nov 03 2018 at 12:40)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137110322):
<p>That seems like a really bad idea, because then things that typechecked when I wrote them no longer typecheck</p>

#### [ Mario Carneiro (Nov 03 2018 at 12:43)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137110376):
<p>that's why we're making the things that depend on irreducible things irreducible</p>

#### [ Chris Hughes (Nov 03 2018 at 12:52)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137110649):
<p>Making <code>real.comm_ring</code> irreducible at the same time that <code>real</code> is made irreducible actually works. I can't do the same thing with <code>discrete_field</code> however, otherwise <code>discrete_field.to_comm_ring</code> or whatever, won't be equal to <code>real.comm_ring</code></p>

#### [ Chris Hughes (Nov 03 2018 at 12:55)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137110716):
<p>This fails now <code>example : field.to_comm_ring ℝ = real.comm_ring := rfl</code></p>

#### [ Mario Carneiro (Nov 03 2018 at 12:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137110770):
<p>you just have to make sure the right things end up opaque</p>

#### [ Mario Carneiro (Nov 03 2018 at 12:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137110812):
<p>I think if you build another <code>discrete_linear_ordered_field ℝ</code> over top of <code>real.comm_ring'</code> and  <code>discrete_linear_ordered_field ℝ</code> , and make the latter two opaque, you should be able to prove the unfolding</p>

#### [ Mario Carneiro (Nov 03 2018 at 12:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137110820):
<p>Without abbreviating things, the longhand way to do this is to define terms <code>zero : R</code>, <code>one : R</code>, <code>zero_add : zero + x = x</code> etc, make them all opaque, and then build typeclasses on top of them</p>

#### [ Mario Carneiro (Nov 03 2018 at 13:00)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137110894):
<p>Typeclass unfolding should never be opaque, this causes problems</p>

#### [ Chris Hughes (Nov 03 2018 at 13:13)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111247):
<p>That seems to fix everything.</p>

#### [ Chris Hughes (Nov 03 2018 at 13:15)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111303):
<p>It does seem like a slightly fragile solution, and that it might cause problems later on.</p>

#### [ Mario Carneiro (Nov 03 2018 at 13:23)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111555):
<p>In metamath we actually took a really hard line on making real opaque, which is weird since we don't do that anywhere else</p>

#### [ Mario Carneiro (Nov 03 2018 at 13:24)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111595):
<p>we construct the reals, forget the construction and axiomatize</p>

#### [ Mario Carneiro (Nov 03 2018 at 13:25)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111610):
<p>It's actually a nice and principled way to do it, because you can pick an appropriate axiomatization of the reals that you know to be complete (no pun intended)</p>

#### [ Mario Carneiro (Nov 03 2018 at 13:25)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111616):
<p>You don't need all the discrete field axioms, of course some of them are redundant</p>

#### [ Chris Hughes (Nov 03 2018 at 13:27)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111675):
<p>Now a whole load of <code>rfl</code> proofs have broken in <code>complex.basic</code>.</p>

#### [ Mario Carneiro (Nov 03 2018 at 13:27)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111681):
<p>that's not good</p>

#### [ Mario Carneiro (Nov 03 2018 at 13:27)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111682):
<p>they should be "above" the construction</p>

#### [ Chris Hughes (Nov 03 2018 at 13:28)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111725):
<p>They shouldn't be proved with <code>rfl</code>? It is nice that some things about reals are definitional.</p>

#### [ Mario Carneiro (Nov 03 2018 at 13:28)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111728):
<p>oh, shoot - I just remembered that some things are definitional like 0 + 0 = 0</p>

#### [ Kenny Lau (Nov 03 2018 at 13:28)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111744):
<p>oh man</p>

#### [ Mario Carneiro (Nov 03 2018 at 13:28)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111746):
<p>that's out the window if you axiomatize</p>

#### [ Mario Carneiro (Nov 03 2018 at 13:29)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111760):
<p>lol this is probably that bunch of simp proofs that kenny made <code>rfl</code></p>

#### [ Chris Hughes (Nov 03 2018 at 13:30)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111812):
<p>I'm pretty sure it is that. I think the reason they weren't <code>rfl</code> in the first place, is because <code>complex.basic</code> was written with old reals.</p>

#### [ Mario Carneiro (Nov 03 2018 at 13:30)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111817):
<p>but I think that it is actually a bad idea to use <code>rfl</code></p>

#### [ Mario Carneiro (Nov 03 2018 at 13:30)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111824):
<p>this is why I say defeq breaks abstractions</p>

#### [ Mario Carneiro (Nov 03 2018 at 13:31)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111834):
<p>it's bad practice to rely on definitional details</p>

#### [ Johan Commelin (Nov 03 2018 at 13:32)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137111879):
<p>I like those claims. They are reassuring. I was getting used to thinking that I should care a lot about defeq. But now you make me think that I should stick to my mathematical habits (-;</p>

#### [ Chris Hughes (Nov 03 2018 at 14:44)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/137113939):
<p>I managed to fix everything. The problems were things like <code>((1 : nat) : real) = (1 : real)</code> no longer being definitional.</p>

#### [ Scott Morrison (Nov 06 2018 at 05:32)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/tidy/near/146844437):
<p>Just reporting that <span class="user-mention" data-user-id="110044">@Chris Hughes</span>'s recent fixes to reducibility have solved <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span>'s original complaint:</p>
<blockquote>
<p>Is there a way to tell tidy that is should never unfold something, possibly with some attribute? Whenever there are real numbers involved, it unfolds them to Cauchy sequences. For instance,</p>
</blockquote>
<div class="codehilite"><pre><span></span>lemma foo {x : ℝ} : 0 ≤ x :=
begin
  tidy,
  sorry
end
</pre></div>


<blockquote>
<p>gives a goal of the form</p>
</blockquote>
<div class="codehilite"><pre><span></span>x_val : ℕ → ℚ,
x_property : is_cau_seq abs x_val
⊢ 0 ≤ quot.mk setoid.r ⟨x_val, x_property⟩
</pre></div>


{% endraw %}
