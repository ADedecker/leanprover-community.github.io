---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/01963universeunification.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/01963universeunification.html">universe unification</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="173535931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20unification/near/173535931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/01963universeunification.html#173535931">Cyril Cohen (Aug 19 2019 at 11:24)</a>:</h4>
<p>Dear all (and in particular meta-programming experts <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> , <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> , <span class="user-mention" data-user-id="110596">@Rob Lewis</span> , <span class="user-mention" data-user-id="110026">@Simon Hudon</span> , <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span>, and whoever I might have forgotten ), I am still writing the so called parametricity tactic, and I am facing the following problem.</p>
<p>Since parametricity translations  generate new relations, I end up generating new universes. The best way I found to do so is to create lots of meta universes. When I am facing a definition, I simply unify the inferred type of the translation of the body with the translation of the type, and then I turn all remaining meta-universes into parameter universe, and I am done.</p>
<p>When doing the same for inductive types, what I would like to do is<br>
1. I compute the translated type for the inductive, and replace every remaining meta universes by parameter universes<br>
2. in each constructor type replace the translated <code>const</code> of my new inductive name (which does not belong to the current environment yet) by a <code>local_const</code> representing the translated inductive type.<br>
3. I launch typechecking in order to unify redundant meta-universes<br>
4. I fix the return sort of the inductive type by computing max + 1 of the sort of the type of every constructor.<br>
Unfortunately I am stuck at step 3... I tried many things: <code>type_check</code>, <code>infer_type</code> followed by <code>unify</code>, <code>to_expr (pexpr.of_expr e)</code>, first making a lambda out of my ad-hock inductive <code>local_const</code>, every time followed by <code>instatiate_mvars</code>... And so far I am still stuck...</p>
<p>Would you know of a primitive, already-written meta function, technique or methodology that would ease my pain?<br>
Best wishes!</p>

<a name="173536715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20unification/near/173536715" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/01963universeunification.html#173536715">Cyril Cohen (Aug 19 2019 at 11:37)</a>:</h4>
<p>I think I just managed, but at the price of exploring the return type of every constructor by hand, picking the list of arguments to the inductive type and performing individual type-checking with the list of abstract parameters, doing all the substitutions by hand... which seems to me redundant with what lean elaborate is capable of...</p>

<a name="173537461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20unification/near/173537461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/01963universeunification.html#173537461">Cyril Cohen (Aug 19 2019 at 11:51)</a>:</h4>
<p>and my manual check is so slow that I timeout on the translation of <code>list</code>...</p>

<a name="173537638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20unification/near/173537638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/01963universeunification.html#173537638">Simon Hudon (Aug 19 2019 at 11:55)</a>:</h4>
<p>Is it possible to have a look at your code? That would make things a bit easier to follow</p>

<a name="173538694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20unification/near/173538694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/01963universeunification.html#173538694">Cyril Cohen (Aug 19 2019 at 12:12)</a>:</h4>
<blockquote>
<p>Is it possible to have a look at your code? That would make things a bit easier to follow</p>
</blockquote>
<p>It's a moving target right now... I will show you as soon as it is a bit stable (I think tomorrow morning CEST)</p>

<a name="173538957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20unification/near/173538957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/01963universeunification.html#173538957">Simon Hudon (Aug 19 2019 at 12:17)</a>:</h4>
<p>Until then, for me, the way I handle the universes is by creating the universe parameters by hand. I calculate ahead of time how many universes a construction is going to take and I make the parameters. I try to avoid type checking in the middle of program because it's slow but also, <code>type_check</code> seems like a more superficial type check and doesn't catch every problem.</p>

<a name="173539046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20unification/near/173539046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/01963universeunification.html#173539046">Simon Hudon (Aug 19 2019 at 12:18)</a>:</h4>
<p><code>mk_mapp</code> and <code>mk_app</code> might be good tools to put in your toolbox though. When you have a definition that you're trying to apply to arguments, it will do the type checking and unification for you</p>

<a name="173539465"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20unification/near/173539465" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/01963universeunification.html#173539465">Rob Lewis (Aug 19 2019 at 12:25)</a>:</h4>
<p>Yeah, it's tough to make a suggestion without seeing the code. My intuition is that <code>unify</code> followed by <code>instantiate_mvars</code> should work. It's normally willing to match universe mvars. If I'm understanding your description right, this is kind of similar to what you're trying to do, right?</p>
<div class="codehilite"><pre><span></span><span class="n">run_cmd</span>
<span class="n">do</span> <span class="n">l</span> <span class="err">←</span> <span class="n">mk_meta_univ</span><span class="o">,</span>
   <span class="n">m</span> <span class="err">←</span> <span class="n">mk_meta_univ</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">c</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">expr</span><span class="bp">.</span><span class="n">const</span> <span class="n">tt</span> <span class="bp">`</span><span class="n">list</span> <span class="o">[</span><span class="n">l</span><span class="o">],</span>
   <span class="k">let</span> <span class="n">d</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">expr</span><span class="bp">.</span><span class="n">const</span> <span class="n">tt</span> <span class="bp">`</span><span class="n">list</span> <span class="o">[</span><span class="n">m</span><span class="o">],</span>
   <span class="n">trace</span> <span class="n">c</span><span class="bp">.</span><span class="n">to_raw_fmt</span><span class="o">,</span> <span class="n">trace</span> <span class="n">d</span><span class="bp">.</span><span class="n">to_raw_fmt</span><span class="o">,</span>
   <span class="n">unify</span> <span class="n">c</span> <span class="n">d</span><span class="o">,</span>
   <span class="n">expr</span><span class="bp">.</span><span class="n">to_raw_fmt</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">instantiate_mvars</span> <span class="n">c</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span><span class="o">,</span>
   <span class="n">expr</span><span class="bp">.</span><span class="n">to_raw_fmt</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">instantiate_mvars</span> <span class="n">d</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span>
</pre></div>

<a name="173539565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20unification/near/173539565" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/01963universeunification.html#173539565">Rob Lewis (Aug 19 2019 at 12:26)</a>:</h4>
<blockquote>
<p><code>type_check</code> seems like a more superficial type check and doesn't catch every problem.</p>
</blockquote>
<p><code>infer_type</code> is superficial, but I thought <code>type_check</code> checks the entire term, no? Which is why it can be expensive sometimes.</p>

<a name="173539699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/universe%20unification/near/173539699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/01963universeunification.html#173539699">Simon Hudon (Aug 19 2019 at 12:29)</a>:</h4>
<p>I've had trouble with type check in the past where I would <code>type_check</code> just before adding a declaration, <code>type_check</code> would succeed but the declaration would fail for typing reason (if I remember correctly, some meta vars had not been unified yet)</p>


{% endraw %}

{% include archive_update.html %}