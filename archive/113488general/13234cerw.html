---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/13234cerw.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html">cerw</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="147925618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147925618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147925618">Johan Commelin (Nov 18 2018 at 18:23)</a>:</h4>
<p>I am a complete newbie when it comes to tactic writing. Here is a request for a tactic, and I have no idea how realistic it is. Suppose I have an isomorphism <code>h : X ≅ Y</code> in some category <code>C</code>. And suppose I have some other term <code>foo : bar X</code>, then I would like to have a tactic <code>cerw</code> (category-<code>erw</code>) that tries to figure out if <code>bar</code> is some sort of <code>category_theory.functor.obj</code> and if so, replaces <code>X</code> with <code>Y</code>.<br>
I realise this request is a bit vague. I would be happy to flesh out the details.</p>

<a name="147929231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929231">Scott Morrison (Nov 18 2018 at 20:13)</a>:</h4>
<p>HI Johan,</p>

<a name="147929239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929239">Scott Morrison (Nov 18 2018 at 20:13)</a>:</h4>
<p>I started writing this, as <code>iso_induction</code>.</p>

<a name="147929248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929248">Scott Morrison (Nov 18 2018 at 20:14)</a>:</h4>
<p>This is intended as my start of an answer to all our questions about transport of structure.</p>

<a name="147929296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929296">Scott Morrison (Nov 18 2018 at 20:14)</a>:</h4>
<p>It is not at all done, but it is certainly doable, and I would love to do it!</p>

<a name="147929420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929420">Scott Morrison (Nov 18 2018 at 20:17)</a>:</h4>
<p>Have a look at <a href="https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/iso_induction.lean" target="_blank" title="https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/iso_induction.lean">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/iso_induction.lean</a></p>

<a name="147929421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929421">Scott Morrison (Nov 18 2018 at 20:18)</a>:</h4>
<p>for the idea</p>

<a name="147929468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929468">Scott Morrison (Nov 18 2018 at 20:18)</a>:</h4>
<p>It is not quite that same as <code>iso_rw</code>, but the same tooling would be required to make that work.</p>

<a name="147929531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929531">Scott Morrison (Nov 18 2018 at 20:20)</a>:</h4>
<p><code>iso_induction</code> takes a hypotheses <code>X \iso Y</code>, and tries to replace all appearances of <code>X</code> with <code>Y</code>, by writing everything in a form where <code>X</code> appears as the argument of a functor.</p>

<a name="147946598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147946598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147946598">Johan Commelin (Nov 19 2018 at 05:40)</a>:</h4>
<p>Cool. That's going to be very useful!</p>

<a name="147946650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147946650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147946650">Johan Commelin (Nov 19 2018 at 05:43)</a>:</h4>
<p>I am afraid that <code>monoid.ext</code> will be considered intollerable abuse of the type class system.</p>

<a name="147951652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951652">Scott Morrison (Nov 19 2018 at 08:17)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>, what's wrong with <code>monoid.ext</code>?</p>
<div class="codehilite"><pre><span></span>@[extensionality] lemma monoid.ext {α : Type u} (m n : monoid α)
  (mul : ∀ x y : α, (by haveI := m; exact x * y) = (by haveI := n; exact x * y)) : m = n :=
</pre></div>

<a name="147951699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951699">Mario Carneiro (Nov 19 2018 at 08:18)</a>:</h4>
<p>looks good to me</p>

<a name="147951701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951701">Scott Morrison (Nov 19 2018 at 08:18)</a>:</h4>
<p>Is it the two different uses of <code>haveI</code> that you're worried about?</p>

<a name="147951704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951704">Johan Commelin (Nov 19 2018 at 08:18)</a>:</h4>
<p>Aah, wait. You aren't actually asking that there are two instances of <code>monoid α</code></p>

<a name="147951707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951707">Johan Commelin (Nov 19 2018 at 08:18)</a>:</h4>
<p>I read to fast.</p>

<a name="147951709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951709">Scott Morrison (Nov 19 2018 at 08:18)</a>:</h4>
<p>No, no square brackets for this lemma!</p>

<a name="147951792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951792">Mario Carneiro (Nov 19 2018 at 08:21)</a>:</h4>
<p>do you have groupoids? that's an obvious thing to prove about <code>isos</code></p>

<a name="147951911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951911">Mario Carneiro (Nov 19 2018 at 08:24)</a>:</h4>
<p>also it's not clear to me why <code>monoid_transport</code> isn't proven directly and it becomes the map part of <code>monoid_type_constructor</code></p>

<a name="161111092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111092">Scott Morrison (Mar 19 2019 at 01:03)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>, <span class="user-mention" data-user-id="112680">@Johan Commelin</span>, resuming an old thread about transport of structure along isomorphisms, I wonder if you could have a look at <a href="https://github.com/leanprover-community/mathlib/blob/a3d685fd6b12f86ac4e31b344d6405e30268e4f4/test/iso_induction.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/a3d685fd6b12f86ac4e31b344d6405e30268e4f4/test/iso_induction.lean">tests/iso_induction.lean</a> on the <code>iso_induction</code> branch. In particular, my idea is that it may be possible to synthesise things like <code>submodule_functor</code>, <code>ideal_functor</code>, and <code>is_local_functor</code>, stubbed out in the file, completely automatically.</p>
<p>If that's the case, then being able to prove <code>is_local_ring S</code> given hypotheses <code>h : is_local_ring R</code> and <code>f : R \iso S</code> should be pretty doable via tactics that look like <code>iso_subst f; exact h</code>.</p>
<p>Really the question becomes --- if you look in the partial proofs of <code>submodule_functor</code> I've been writing, can you write down _exactly_ why every mathematician knows exactly what to do at every step? :-) This is the sort of thing <code>tidy</code> is aimed at, but it's not up to the task quite yet.</p>

<a name="161111356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111356">Kevin Buzzard (Mar 19 2019 at 01:08)</a>:</h4>
<p>Did you see Mario's effort on this question? My lean time has been 100% taken up with perfectoids recently so I didn't look at it</p>

<a name="161111388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111388">Scott Morrison (Mar 19 2019 at 01:09)</a>:</h4>
<p>No, maybe I didn't... <span class="user-mention" data-user-id="110049">@Mario Carneiro</span>, could you give me a pointer?</p>

<a name="161111397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111397">Scott Morrison (Mar 19 2019 at 01:09)</a>:</h4>
<p>(Have to disappear for a few hours, but I'll read up afterwards.)</p>

<a name="161111484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111484">Mario Carneiro (Mar 19 2019 at 01:10)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751" title="#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751</a></p>

<a name="161111781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111781">Scott Morrison (Mar 19 2019 at 01:16)</a>:</h4>
<p>Okay, that is cool. :-)</p>

<a name="161111805"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111805" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111805">Scott Morrison (Mar 19 2019 at 01:17)</a>:</h4>
<p>A lot of automation is going to be needed still, before the mathematicians can cope with this. :-)</p>

<a name="161111915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111915">Mario Carneiro (Mar 19 2019 at 01:19)</a>:</h4>
<p>right, this was really an exercise in finding out what major infrastructure components were missing in the automation we all expect</p>

<a name="161111924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111924">Mario Carneiro (Mar 19 2019 at 01:19)</a>:</h4>
<p><code>equiv.rel</code> in particular turned out to be important</p>

<a name="161111996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161111996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161111996">Mario Carneiro (Mar 19 2019 at 01:20)</a>:</h4>
<p>eventually, <code>transfer</code> should be able to do the job of proving the last few theorems, although stuff about transferring ideals and other things will all need to be explicitly stated, at least, and marked for use with <code>transfer</code></p>

<a name="161126312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161126312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161126312">Johan Commelin (Mar 19 2019 at 07:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> I'll try to write up the kind of proofs that I expect <code>tidy</code> to generate</p>

<a name="161130454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161130454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161130454">Scott Morrison (Mar 19 2019 at 08:31)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>, maybe it's not worth doing any now. The functoriality argument for <code>submodule</code> needs to rely on deeper layers of functoriality, anyway. May I should try writing the actual <code>iso_subst</code> and <code>iso_rw</code>tactic, because they'll in turn be used by the <code>[derive]</code> handler for functoriality and iso_functoriality instances...</p>

<a name="161130529"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/161130529" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#161130529">Scott Morrison (Mar 19 2019 at 08:32)</a>:</h4>
<p>Also, I need to understand Mario's approach properly. I haven't understood yet how general it will be. (I'm initially a little worried taking about ring equivalences, and monoid equivalences, and .... all separately, rather than building the machinery abstractly at the level of isomorphisms in some category, but maybe I don't know what I'm talking about here. :-)</p>


{% endraw %}
