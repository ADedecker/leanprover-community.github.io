---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/13234cerw.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html">cerw</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="147925618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147925618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147925618">Johan Commelin (Nov 18 2018 at 18:23)</a>:</h4>
<p>I am a complete newbie when it comes to tactic writing. Here is a request for a tactic, and I have no idea how realistic it is. Suppose I have an isomorphism <code>h : X ≅ Y</code> in some category <code>C</code>. And suppose I have some other term <code>foo : bar X</code>, then I would like to have a tactic <code>cerw</code> (category-<code>erw</code>) that tries to figure out if <code>bar</code> is some sort of <code>category_theory.functor.obj</code> and if so, replaces <code>X</code> with <code>Y</code>.<br>
I realise this request is a bit vague. I would be happy to flesh out the details.</p>

<a name="147929231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929231">Scott Morrison (Nov 18 2018 at 20:13)</a>:</h4>
<p>HI Johan,</p>

<a name="147929239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929239">Scott Morrison (Nov 18 2018 at 20:13)</a>:</h4>
<p>I started writing this, as <code>iso_induction</code>.</p>

<a name="147929248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929248">Scott Morrison (Nov 18 2018 at 20:14)</a>:</h4>
<p>This is intended as my start of an answer to all our questions about transport of structure.</p>

<a name="147929296"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929296" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929296">Scott Morrison (Nov 18 2018 at 20:14)</a>:</h4>
<p>It is not at all done, but it is certainly doable, and I would love to do it!</p>

<a name="147929420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929420">Scott Morrison (Nov 18 2018 at 20:17)</a>:</h4>
<p>Have a look at <a href="https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/iso_induction.lean" target="_blank" title="https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/iso_induction.lean">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/iso_induction.lean</a></p>

<a name="147929421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929421">Scott Morrison (Nov 18 2018 at 20:18)</a>:</h4>
<p>for the idea</p>

<a name="147929468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929468">Scott Morrison (Nov 18 2018 at 20:18)</a>:</h4>
<p>It is not quite that same as <code>iso_rw</code>, but the same tooling would be required to make that work.</p>

<a name="147929531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147929531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147929531">Scott Morrison (Nov 18 2018 at 20:20)</a>:</h4>
<p><code>iso_induction</code> takes a hypotheses <code>X \iso Y</code>, and tries to replace all appearances of <code>X</code> with <code>Y</code>, by writing everything in a form where <code>X</code> appears as the argument of a functor.</p>

<a name="147946598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147946598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147946598">Johan Commelin (Nov 19 2018 at 05:40)</a>:</h4>
<p>Cool. That's going to be very useful!</p>

<a name="147946650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147946650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147946650">Johan Commelin (Nov 19 2018 at 05:43)</a>:</h4>
<p>I am afraid that <code>monoid.ext</code> will be considered intollerable abuse of the type class system.</p>

<a name="147951652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951652">Scott Morrison (Nov 19 2018 at 08:17)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>, what's wrong with <code>monoid.ext</code>?</p>
<div class="codehilite"><pre><span></span>@[extensionality] lemma monoid.ext {α : Type u} (m n : monoid α)
  (mul : ∀ x y : α, (by haveI := m; exact x * y) = (by haveI := n; exact x * y)) : m = n :=
</pre></div>

<a name="147951699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951699">Mario Carneiro (Nov 19 2018 at 08:18)</a>:</h4>
<p>looks good to me</p>

<a name="147951701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951701">Scott Morrison (Nov 19 2018 at 08:18)</a>:</h4>
<p>Is it the two different uses of <code>haveI</code> that you're worried about?</p>

<a name="147951704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951704">Johan Commelin (Nov 19 2018 at 08:18)</a>:</h4>
<p>Aah, wait. You aren't actually asking that there are two instances of <code>monoid α</code></p>

<a name="147951707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951707">Johan Commelin (Nov 19 2018 at 08:18)</a>:</h4>
<p>I read to fast.</p>

<a name="147951709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951709">Scott Morrison (Nov 19 2018 at 08:18)</a>:</h4>
<p>No, no square brackets for this lemma!</p>

<a name="147951792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951792">Mario Carneiro (Nov 19 2018 at 08:21)</a>:</h4>
<p>do you have groupoids? that's an obvious thing to prove about <code>isos</code></p>

<a name="147951911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cerw/near/147951911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/13234cerw.html#147951911">Mario Carneiro (Nov 19 2018 at 08:24)</a>:</h4>
<p>also it's not clear to me why <code>monoid_transport</code> isn't proven directly and it becomes the map part of <code>monoid_type_constructor</code></p>


{% endraw %}
