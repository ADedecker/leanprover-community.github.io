---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/83571TypetheoryofLean.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/83571TypetheoryofLean.html">Type theory of Lean</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="163918718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/163918718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83571TypetheoryofLean.html#163918718">Mario Carneiro (Apr 22 2019 at 17:05)</a>:</h4>
<p>I just delivered my master's thesis on lean's type theory, and the talk was recorded: <a href="https://www.youtube.com/watch?v=3sKrSNhSxik" target="_blank" title="https://www.youtube.com/watch?v=3sKrSNhSxik">https://www.youtube.com/watch?v=3sKrSNhSxik</a> . It builds up the motivation for all the complexity in DTT, so if you have a basic understanding of how proof judgments are presented you should be able to follow it. The repo with the full thesis is <a href="https://github.com/digama0/lean-type-theory/releases" target="_blank" title="https://github.com/digama0/lean-type-theory/releases">https://github.com/digama0/lean-type-theory/releases</a> .</p>
<div class="youtube-video message_inline_image"><a data-id="3sKrSNhSxik" href="https://www.youtube.com/watch?v=3sKrSNhSxik" target="_blank" title="https://www.youtube.com/watch?v=3sKrSNhSxik"><img src="https://i.ytimg.com/vi/3sKrSNhSxik/default.jpg"></a></div>

<a name="163919331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/163919331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83571TypetheoryofLean.html#163919331">Rob Lewis (Apr 22 2019 at 17:13)</a>:</h4>
<p>Congrats!</p>

<a name="163921544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/163921544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83571TypetheoryofLean.html#163921544">Patrick Massot (Apr 22 2019 at 17:41)</a>:</h4>
<p><a href="http://phdcomics.com/comics/archive.php?comicid=590" target="_blank" title="http://phdcomics.com/comics/archive.php?comicid=590">http://phdcomics.com/comics/archive.php?comicid=590</a></p>

<a name="163921817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/163921817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83571TypetheoryofLean.html#163921817">Patrick Massot (Apr 22 2019 at 17:44)</a>:</h4>
<p>Who would have believed to see this before Lean 4?</p>

<a name="163990778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/163990778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83571TypetheoryofLean.html#163990778">Wojciech Nawrocki (Apr 23 2019 at 13:41)</a>:</h4>
<p>Congrats!</p>

<a name="163998787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/163998787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83571TypetheoryofLean.html#163998787">Wojciech Nawrocki (Apr 23 2019 at 15:13)</a>:</h4>
<blockquote>
<p>f == g -&gt; x == y -&gt; f x == g y is unprovable</p>
</blockquote>
<p>Oops, so that's why I couldn't do it when I tried recently. Do you know if this is consistent as an added axiom?</p>

<a name="164012424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164012424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83571TypetheoryofLean.html#164012424">Kevin Buzzard (Apr 23 2019 at 17:48)</a>:</h4>
<p>Don't add axioms! It's not really how Lean works, and support for them is poor. If you need it, add a variable. But people in general try to avoid <code>heq</code> completely. Why do you think you need it at all?</p>

<a name="164075006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164075006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83571TypetheoryofLean.html#164075006">Wojciech Nawrocki (Apr 24 2019 at 12:15)</a>:</h4>
<p>I agree that adding axioms is probably undesirable, but it would be interesting to see whether this one is consistent with Lean from a purely type-theoretical point of view</p>

<a name="164135260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164135260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83571TypetheoryofLean.html#164135260">Mario Carneiro (Apr 25 2019 at 01:29)</a>:</h4>
<p>It's consistent, because it follows from injectivity of pi</p>

<a name="164135468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164135468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83571TypetheoryofLean.html#164135468">Simon Hudon (Apr 25 2019 at 01:34)</a>:</h4>
<p>Are you saying that adding injectivity of pi is sufficient to prove it? Is there a down side to having that axiom?</p>

<a name="164141399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164141399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83571TypetheoryofLean.html#164141399">Mario Carneiro (Apr 25 2019 at 04:02)</a>:</h4>
<p>One downside, as Carlo mentioned to me, is that it breaks the types-as-sets model, and the types-as-cardinalities model</p>

<a name="164141401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164141401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83571TypetheoryofLean.html#164141401">Mario Carneiro (Apr 25 2019 at 04:03)</a>:</h4>
<p>plus axioms always have computation / canonicity troubles</p>

<a name="164141757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20theory%20of%20Lean/near/164141757" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83571TypetheoryofLean.html#164141757">Mario Carneiro (Apr 25 2019 at 04:11)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">axiom</span> <span class="n">pi_injective₁</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α&#39;</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β&#39;</span> <span class="n">a</span><span class="o">))</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">α&#39;</span>

<span class="kn">axiom</span> <span class="n">pi_injective₂</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="n">β&#39;</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β&#39;</span> <span class="n">a</span><span class="o">))</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">β&#39;</span> <span class="n">a</span>

<span class="kn">theorem</span> <span class="n">heq_congr</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α&#39;</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">a</span><span class="o">,</span> <span class="n">β&#39;</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">α&#39;</span><span class="o">}</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">==</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">==</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">==</span> <span class="n">g</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">pi_injective₁</span> <span class="o">(</span><span class="n">type_eq_of_heq</span> <span class="n">h₁</span><span class="o">),</span>
  <span class="n">cases</span> <span class="o">(</span><span class="n">funext</span> <span class="err">$</span> <span class="n">pi_injective₂</span> <span class="o">(</span><span class="n">type_eq_of_heq</span> <span class="n">h₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">=</span> <span class="n">β&#39;</span><span class="o">),</span>
  <span class="n">cases</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">refl</span>
<span class="kn">end</span>
</pre></div>


{% endraw %}
