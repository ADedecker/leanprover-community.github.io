---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/72553outparam.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html">out_param</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="160994372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160994372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160994372">Sebastien Gouezel (Mar 17 2019 at 11:05)</a>:</h4>
<p>I thought that <code>out_param</code> should have disappeared from modules, but in <code>analysis.normed_space.basic</code> there are the following lines:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">normed_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="n">out_param</span> <span class="err">$</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">out_param</span> <span class="err">$</span> <span class="n">normed_field</span> <span class="n">α</span><span class="o">]</span>
  <span class="kn">extends</span> <span class="n">normed_group</span> <span class="n">β</span><span class="o">,</span> <span class="n">vector_space</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
</pre></div>


<p>I don't understand them, which is not a big deal, but I wanted to check that they should not be changed.</p>

<a name="160994379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160994379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160994379">Patrick Massot (Mar 17 2019 at 11:05)</a>:</h4>
<p>I asked the same question last week...</p>

<a name="160994380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160994380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160994380">Sebastien Gouezel (Mar 17 2019 at 11:05)</a>:</h4>
<p>And what answer did you get?</p>

<a name="160994432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160994432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160994432">Patrick Massot (Mar 17 2019 at 11:07)</a>:</h4>
<p>none</p>

<a name="160995259"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160995259" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160995259">Kevin Buzzard (Mar 17 2019 at 11:34)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/out_param.20again/near/160275177" title="#narrow/stream/116395-maths/topic/out_param.20again/near/160275177">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/out_param.20again/near/160275177</a></p>

<a name="160995442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/160995442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#160995442">Sebastien Gouezel (Mar 17 2019 at 11:40)</a>:</h4>
<p>Thansk for the pointer. Indeed, this is the very same question!</p>

<a name="164911736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164911736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164911736">Sebastien Gouezel (May 05 2019 at 09:48)</a>:</h4>
<p>I am having problems with out_param in the following situation. Suppose <code>M</code> is a <code>C^1</code> manifold, with respect to a base field <code>k</code> and a model vector space <code>E</code>. I want to define the tangent space at a point <code>x</code>, by taking equivalence classes of vectors in charts. The maths are not important. The point is that <code>k</code> is relevant (you may want to consider a complex manifold as a real manifold), so just as for linear maps it should be explicit in the definition of the tangent space. However, there will always be one single model space <code>E</code>, so I don't want to have it as an explicit parameter in the definition: it should rather be inferred from the manifold instance in the context. I tried to write this as (with everything in <code>Type</code> to avoid potential universe issues):</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">tangent_space_unfolded</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="n">out_param</span> <span class="err">$</span> <span class="kt">Type</span><span class="o">}</span>
  <span class="o">[</span><span class="n">out_param</span> <span class="err">$</span> <span class="n">normed_space</span> <span class="n">k</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">manifold</span> <span class="n">E</span> <span class="o">(</span><span class="n">times_cont_diff_groupoid</span> <span class="mi">1</span> <span class="n">k</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="o">{</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">M</span> <span class="n">E</span> <span class="bp">//</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">chart</span> <span class="o">(</span><span class="n">times_cont_diff_groupoid</span> <span class="mi">1</span> <span class="n">k</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">}</span> <span class="bp">×</span> <span class="n">E</span>
</pre></div>


<p>(notice the <code>out_param</code> on <code>E</code> and <code>normed_space k E</code>). However, when I try to use this definition, <code>E</code> is not inferred. For instance, with</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">tangent_vector_equiv_rel</span> <span class="o">{</span><span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">nondiscrete_normed_field</span> <span class="n">k</span><span class="o">]</span> <span class="o">{</span><span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">normed_space</span> <span class="n">k</span> <span class="n">E</span><span class="o">]</span>
  <span class="o">{</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">manifold</span> <span class="n">E</span> <span class="o">(</span><span class="n">times_cont_diff_groupoid</span> <span class="mi">1</span> <span class="n">k</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">]</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">tangent_space_unfolded</span> <span class="n">k</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">true</span>
</pre></div>


<p>I get the red squiggle under <code>p : tangent_space_unfolded k x</code> with the complaint</p>
<div class="codehilite"><pre><span></span><span class="n">don&#39;t</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="kn">context</span><span class="o">:</span>
<span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">nondiscrete_normed_field</span> <span class="n">k</span><span class="o">,</span>
<span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">normed_space</span> <span class="n">k</span> <span class="n">E</span><span class="o">,</span>
<span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_3</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">M</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_4</span> <span class="o">:</span> <span class="n">manifold</span> <span class="n">E</span> <span class="o">(</span><span class="n">times_cont_diff_groupoid</span> <span class="mi">1</span> <span class="n">k</span> <span class="n">E</span><span class="o">)</span> <span class="n">M</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">M</span>
<span class="err">⊢</span> <span class="n">out_param</span> <span class="kt">Type</span>
</pre></div>


<p>If I make the parameter <code>E</code> explicit, on the other hand, everything is fine.</p>
<p>There are very few places in the library where <code>out_param</code> is used, so I don't have enough examples (or documentation) to understand what the right syntax should be. Is it impossible to do what I would like?</p>

<a name="164912212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912212">Mario Carneiro (May 05 2019 at 10:01)</a>:</h4>
<p>out_param goes on instances and class definitions</p>

<a name="164912263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912263">Mario Carneiro (May 05 2019 at 10:02)</a>:</h4>
<p>you can't just put it on a single definition, it's tied in to the whole instance search problem for that typeclass</p>

<a name="164912316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912316">Mario Carneiro (May 05 2019 at 10:04)</a>:</h4>
<p>In this case, if you want <code>k</code> to determine <code>E</code> in <code>normed_space</code>, you would need to mark <code>E</code> as <code>out_param</code> in the definition of <code>normed_space</code>. I guess that's not what you want</p>

<a name="164912334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912334" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912334">Sebastien Gouezel (May 05 2019 at 10:04)</a>:</h4>
<p>I don't want <code>k</code> to determine <code>E</code>, I want the manifold instance together with <code>k</code> to determine <code>E</code>.</p>

<a name="164912354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912354">Mario Carneiro (May 05 2019 at 10:05)</a>:</h4>
<p>but the manifold instance already mentions E</p>

<a name="164912407"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912407" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912407">Mario Carneiro (May 05 2019 at 10:06)</a>:</h4>
<p>So you want to trigger the search <code>manifold ?E (times_cont_diff_groupoid 1 k ?E) M</code>?</p>

<a name="164912409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912409">Sebastien Gouezel (May 05 2019 at 10:06)</a>:</h4>
<p>Yes. I guess I don't understand at all what out_param does. What I would like to happen when Lean encounters <code>tangent_space k x</code>: it looks in the context for a instance of <code>manifold ?m1 (times_cont_diff_groupoid 1 k ?m1) M</code>, and if it finds one it picks it at <code>E</code>.</p>

<a name="164912420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912420">Mario Carneiro (May 05 2019 at 10:07)</a>:</h4>
<p>or is it <code>manifold ?E ?X M</code></p>

<a name="164912424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912424">Mario Carneiro (May 05 2019 at 10:08)</a>:</h4>
<p>what is that second argument?</p>

<a name="164912467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912467">Sebastien Gouezel (May 05 2019 at 10:08)</a>:</h4>
<p>It is really <code>manifold ?m1 (times_cont_diff_groupoid 1 k ?m1) M</code> that it should look for.</p>

<a name="164912470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912470">Sebastien Gouezel (May 05 2019 at 10:08)</a>:</h4>
<p>It is a groupoid, i.e., a set of local homeomorphisms between <code>M</code> and <code>E</code>.</p>

<a name="164912539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912539">Mario Carneiro (May 05 2019 at 10:10)</a>:</h4>
<p>can you make another class?</p>

<a name="164912541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912541">Mario Carneiro (May 05 2019 at 10:10)</a>:</h4>
<p>like <code>model_space M ?E</code> or something</p>

<a name="164912543"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912543" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912543">Mario Carneiro (May 05 2019 at 10:10)</a>:</h4>
<p>that implies <code>manifold ?E (times_cont_diff_groupoid 1 k ?E) M</code></p>

<a name="164912624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912624">Mario Carneiro (May 05 2019 at 10:13)</a>:</h4>
<p>I am wary of that typeclass arg. You can probably make lean search for it because lean typeclass search has no hygiene, but that's also why typeclass search is starting to fall over in mathlib</p>

<a name="164912628"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912628" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912628">Sebastien Gouezel (May 05 2019 at 10:13)</a>:</h4>
<p>What I could do is mark <code>E</code> as out_param in the definition of manifold. Except that this is not OK as there can be different model spaces depending on whether one considers a space as a real or complex manifold. So, it would really have to depend on both <code>k</code> and <code>M</code>. I can build a new class <code>smooth_manifold k ?E M</code> with <code>E</code> as an out_param, and see how this goes.</p>

<a name="164912685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164912685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164912685">Sebastien Gouezel (May 05 2019 at 10:15)</a>:</h4>
<p>Being a manifold is definitely a type class, just as good as being a ring or a topological space. The only difference is that it has more structure built in, so it depends on more stuff but that's the way math is.</p>

<a name="164913172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164913172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164913172">Mario Carneiro (May 05 2019 at 10:28)</a>:</h4>
<p>The problem isn't the math, it's the use of <code>(times_cont_diff_groupoid 1 k ?E)</code> as one of the arguments to the class. It's too dependent for my liking (it's not even a type IIUC)</p>

<a name="164913454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164913454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164913454">Sebastien Gouezel (May 05 2019 at 10:36)</a>:</h4>
<p>For each groupoid <code>G</code>, you have a notion of manifold based on this groupoid. For instance, <code>C^infty</code> manifolds, or manifolds with boundary, or manifold with corners, or contact manifolds, or orientable manifolds, or whatever. Each of these structures gives you access to some objects on the manifold. My idea is to set up a set of instances between these structures, so that when you have a contact manifold then you also get automatically a smooth structure, an oriented structure, and so on, just by typeclass inference. I have the impression that this is precisely the kind of things at which typeclass inference is good, but maybe I am missing something.</p>

<a name="164913667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164913667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164913667">Mario Carneiro (May 05 2019 at 10:43)</a>:</h4>
<p>could you put the definition of <code>manifold</code>? I'm confused about the type of everything here</p>

<a name="164915110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/out_param/near/164915110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/72553outparam.html#164915110">Sebastien Gouezel (May 05 2019 at 11:24)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">structure_groupoid</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">members</span>      <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">comp</span>         <span class="o">:</span> <span class="bp">∀</span><span class="n">e</span> <span class="n">e&#39;</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">members</span> <span class="bp">→</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">members</span> <span class="bp">→</span> <span class="n">e</span> <span class="bp">→</span><span class="err">ₕ</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv</span>          <span class="o">:</span> <span class="bp">∀</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">members</span> <span class="bp">→</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>
<span class="o">(</span><span class="n">id_mem</span>       <span class="o">:</span> <span class="n">local_homeomorph</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>
<span class="o">(</span><span class="n">locality</span>     <span class="o">:</span> <span class="bp">∀</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span><span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">,</span> <span class="bp">∃</span><span class="n">s</span><span class="o">,</span> <span class="n">is_open</span> <span class="n">s</span> <span class="bp">∧</span>
                  <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">e</span><span class="bp">.</span><span class="n">restr</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span> <span class="bp">→</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>
<span class="o">(</span><span class="n">eq_on_source</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="n">e&#39;</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">α</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">members</span> <span class="bp">→</span> <span class="n">e&#39;</span> <span class="bp">≈</span> <span class="n">e</span> <span class="bp">→</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">members</span><span class="o">)</span>

<span class="n">class</span> <span class="n">manifold</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">structure_groupoid</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">chart</span>  <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">local_homeomorph</span> <span class="n">β</span> <span class="n">α</span><span class="o">))</span>
<span class="o">(</span><span class="n">compat</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">e</span> <span class="n">e&#39;</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">β</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">chart</span> <span class="bp">→</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">chart</span> <span class="bp">→</span> <span class="n">e</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">→</span><span class="err">ₕ</span> <span class="n">e&#39;</span> <span class="err">∈</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">cover</span>  <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span><span class="o">,</span> <span class="bp">∃</span><span class="n">e</span> <span class="o">:</span> <span class="n">local_homeomorph</span> <span class="n">β</span> <span class="n">α</span><span class="o">,</span> <span class="n">e</span> <span class="err">∈</span> <span class="n">chart</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">e</span><span class="bp">.</span><span class="n">source</span><span class="o">)</span>
</pre></div>


<p>One could also go for a manifold structure just by picking the charts and the cover condition (this would be a <code>has_chart</code> class, say, similar to <code>has_add</code> and friends), and say that the manifold structure is compatible with a given groupoid if the compat condition holds (in the same way as one can add properties extending <code>has_add</code> making it into a group, a ring, a module, and so on).</p>


{% endraw %}
