---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/71850POPLmarkchallenge.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html">POPLmark challenge</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="186924030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186924030">Tim Daly (Jan 29 2020 at 20:11)</a>:</h4>
<p>(<a href="https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future" target="_blank" title="https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future">https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future</a>) POPLmark challenge is about Mechanized Proofs for Programming Languages. Lean is not just about mechanizing formal mathematics. It is also about mechanizing computational mathematics (at least from my opinionated viewpoint).   So besides pushing into the Math dept. we need to push into CS departments.</p>

<a name="186924244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186924244">Tim Daly (Jan 29 2020 at 20:13)</a>:</h4>
<p>CMU has Frank Pfenning, Bob Harper, and Karl Crary, all in CS and all doing related work, just not in Lean. What would it take to "Buzzard" the CS community?</p>

<a name="186924317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186924317">Johan Commelin (Jan 29 2020 at 20:14)</a>:</h4>
<p>It would take a buzzard...</p>

<a name="186924969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186924969">Tim Daly (Jan 29 2020 at 20:22)</a>:</h4>
<p>We have mathlib for the formal crowd. Perhaps we can import the Standard ML kinds of support into a proglib, which would contain definitions, axioms, and theorems related to code.</p>

<a name="186925427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186925427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186925427">Tim Daly (Jan 29 2020 at 20:28)</a>:</h4>
<p>From the talk... The paper abstract reads:<br>
How close are we to a world where every paper on progamming languages is accompanied by an electronic appendix with machine-checked proofs?<br>
We propose an initial set of benchmarks for measuring progress in this area. Based on the metatheory of System $F_&lt;$, a typed lambda-calculus with second-order polymorphism, subtyping, and records, these benchmarks embody many aspects of programming languages that are challenging to formalize: variable binding at both the term and type levels, syntactic forms with variable numbers of components (including binders), and proofs demanding complex induction principles. We hopt that these benchmarks will help clarify the current state of the art, provide a basis for comparing competing technologies, and motivate further research.</p>

<a name="186928605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186928605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186928605">Tim Daly (Jan 29 2020 at 21:05)</a>:</h4>
<p>One of the likely side-effects of a proglib (vs mathlib) would be developing program generation from Lean proofs. This isn't of much interest to the formal math approach but would be to the computational math crowd (aka me :-) )</p>


{% endraw %}

{% include archive_update.html %}