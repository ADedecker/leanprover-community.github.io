---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/71850POPLmarkchallenge.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html">POPLmark challenge</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="186924030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186924030">Tim Daly (Jan 29 2020 at 20:11)</a>:</h4>
<p>(<a href="https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future" target="_blank" title="https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future">https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future</a>) POPLmark challenge is about Mechanized Proofs for Programming Languages. Lean is not just about mechanizing formal mathematics. It is also about mechanizing computational mathematics (at least from my opinionated viewpoint).   So besides pushing into the Math dept. we need to push into CS departments.</p>

<a name="186924244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186924244">Tim Daly (Jan 29 2020 at 20:13)</a>:</h4>
<p>CMU has Frank Pfenning, Bob Harper, and Karl Crary, all in CS and all doing related work, just not in Lean. What would it take to "Buzzard" the CS community?</p>

<a name="186924317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186924317">Johan Commelin (Jan 29 2020 at 20:14)</a>:</h4>
<p>It would take a buzzard...</p>

<a name="186924969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186924969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186924969">Tim Daly (Jan 29 2020 at 20:22)</a>:</h4>
<p>We have mathlib for the formal crowd. Perhaps we can import the Standard ML kinds of support into a proglib, which would contain definitions, axioms, and theorems related to code.</p>

<a name="186925427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186925427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186925427">Tim Daly (Jan 29 2020 at 20:28)</a>:</h4>
<p>From the talk... The paper abstract reads:<br>
How close are we to a world where every paper on progamming languages is accompanied by an electronic appendix with machine-checked proofs?<br>
We propose an initial set of benchmarks for measuring progress in this area. Based on the metatheory of System $F_&lt;$, a typed lambda-calculus with second-order polymorphism, subtyping, and records, these benchmarks embody many aspects of programming languages that are challenging to formalize: variable binding at both the term and type levels, syntactic forms with variable numbers of components (including binders), and proofs demanding complex induction principles. We hopt that these benchmarks will help clarify the current state of the art, provide a basis for comparing competing technologies, and motivate further research.</p>

<a name="186928605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186928605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186928605">Tim Daly (Jan 29 2020 at 21:05)</a>:</h4>
<p>One of the likely side-effects of a proglib (vs mathlib) would be developing program generation from Lean proofs. This isn't of much interest to the formal math approach but would be to the computational math crowd (aka me :-) )</p>

<a name="186934837"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186934837" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186934837">Patrick Massot (Jan 29 2020 at 22:18)</a>:</h4>
<blockquote>
<p>CMU has Frank Pfenning, Bob Harper, and Karl Crary, all in CS and all doing related work, just not in Lean. What would it take to "Buzzard" the CS community?</p>
</blockquote>
<p>I don't want to minimize Kevin's work, but it looks like this forum gives you a very distorted view of the reality of maths departments. To finite order, nothing changed. Any effect is beyond what Taylor expansions can see. The number of mathematicians using a proof assistant may have been multiplied by 20 in the last two years, but it is still very very very close to zero in proportion.</p>

<a name="186935818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186935818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186935818">Tim Daly (Jan 29 2020 at 22:31)</a>:</h4>
<p>I did a survey of the connection between ITP and Computer Algebra. I can only name one person (James Davenport) who appears in both bibliographies. So I know that this is at the "not even noise" level. But I have a "30 Year Horizon" view and I believe the connection must arrive in the long term. In particular, the subset of programming that involves computer algebra seems most likely to be automated since the specifications of the algorithms are already (reasonably well) known.</p>
<p>I'm spending the evening digging up information on TWELF and Standard ML, looking for something that could serve as a kernel of "proglib" in Lean. If Lean could produce ML programs from proofs that would be a major advance for Lean.</p>
<p>The fact that nobody knows how to do this is what makes it research.</p>

<a name="186935971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186935971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186935971">Simon Cruanes (Jan 29 2020 at 22:33)</a>:</h4>
<p>By producing ML programs from proofs, are you referring to something similar to Coq's extraction to OCaml?</p>

<a name="186936005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936005">Simon Cruanes (Jan 29 2020 at 22:33)</a>:</h4>
<p>(extracting programs from proof assistants seem relatively common to me, Isabelle/HOL even has components to extract imperative programs)</p>

<a name="186936123"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936123" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936123">Tim Daly (Jan 29 2020 at 22:34)</a>:</h4>
<p>Yes. Lean should be able to extract a program from a proof. I'd rather it could extract SPAD (Axiom's language) programs as SPAD is dependently typed but ML might be easier as some of the other systems could provide validation.</p>

<a name="186936287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936287">Tim Daly (Jan 29 2020 at 22:37)</a>:</h4>
<p>One interesting thought would be to try to build 'proglib' so that everything has a programming language representation. Sort of "designed to be executed". I'm not sure yet how this can be done, of course.</p>

<a name="186936382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936382">Reid Barton (Jan 29 2020 at 22:38)</a>:</h4>
<p>Lean is already a programming language, so you can take the program extraction to be the identity.</p>

<a name="186936431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936431">Tim Daly (Jan 29 2020 at 22:39)</a>:</h4>
<p>I'm not sure what the execution semantics are for the proofs I've read.</p>

<a name="186936439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936439">Reid Barton (Jan 29 2020 at 22:40)</a>:</h4>
<p>In Lean 4, this will sometimes even be a sensible thing to do. But a lot depends on the original proof. For example, if it is nonconstructive, then it has no computational meaning.</p>

<a name="186936486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936486">Reid Barton (Jan 29 2020 at 22:40)</a>:</h4>
<p>Because those proofs were not intended to be executed, most likely</p>

<a name="186936551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936551">Simon Cruanes (Jan 29 2020 at 22:41)</a>:</h4>
<p>If you want to write verified programs, why consider them as proofs and not as normal values? This way you can write programs in a readable way, and prove properties about them separately (which is done in CFML, CompCert, etc. afaik)</p>

<a name="186936598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186936598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186936598">Tim Daly (Jan 29 2020 at 22:42)</a>:</h4>
<p>My thought (and what I'm using as a basis for reading) is that I'm looking for a translation from program -&gt; Lean -&gt; program that is 1-1 (or some near approach). I've found some ML and TWELF papers so I'm reading.</p>

<a name="186937441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186937441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186937441">Tim Daly (Jan 29 2020 at 22:55)</a>:</h4>
<p><span class="user-mention" data-user-id="132878">@Simon Cruanes</span>  I have programs written in a reasonable way (e.g. GCD, Groebner, etc) and specifications for them. But there needs to be some deeper, automated connection from these programs to Lean and back so they can be trusted. Otherwise it feels like "hand waving" (at least to me).</p>

<a name="186941949"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/POPLmark%20challenge/near/186941949" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/71850POPLmarkchallenge.html#186941949">Tim Daly (Jan 29 2020 at 23:59)</a>:</h4>
<p>There is an interesting split I've come to recognize between the ITP approach and the Type-Theory approach to things, despite the fact that they both seem to use the same judgments. ITP systems tend toward "tactics" whereas the Type-Theory approach tends to use unification.</p>


{% endraw %}

{% include archive_update.html %}