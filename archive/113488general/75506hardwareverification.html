---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/75506hardwareverification.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/75506hardwareverification.html">hardware verification</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="188284010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/hardware%20verification/near/188284010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/75506hardwareverification.html#188284010">Tim Daly (Feb 15 2020 at 13:38)</a>:</h4>
<p>I've been looking at "verification down to the metal". Robert Baruch has been designing a CPU in an FPGA and documenting each step with video. One of his videos is "Very Basic Introduction to Formal Verification" which involves formal verification of Verilog (hardware design language) modules. See (<a href="https://www.youtube.com/watch?v=9e7F1XhjhKw" target="_blank" title="https://www.youtube.com/watch?v=9e7F1XhjhKw">https://www.youtube.com/watch?v=9e7F1XhjhKw</a>) and also the paper "Veriflog Synthesis and Formal Verification with Yosys" (<a href="http://www.clifford.at/papers/2016/yosys-synth-formal/slides.pdf" target="_blank" title="http://www.clifford.at/papers/2016/yosys-synth-formal/slides.pdf">http://www.clifford.at/papers/2016/yosys-synth-formal/slides.pdf</a>)</p>
<div class="youtube-video message_inline_image"><a data-id="9e7F1XhjhKw" href="https://www.youtube.com/watch?v=9e7F1XhjhKw" target="_blank" title="https://www.youtube.com/watch?v=9e7F1XhjhKw"><img src="https://i.ytimg.com/vi/9e7F1XhjhKw/default.jpg"></a></div>

<a name="188284316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/hardware%20verification/near/188284316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/75506hardwareverification.html#188284316">Tim Daly (Feb 15 2020 at 13:49)</a>:</h4>
<p>Yosys is using things like BDDs or model checking. But a lot of "metal" level "modules" in Verilog are basically either Mealy or Moore state machines. It seems to me that these could be modelled in logic and Lean-like proof machinery could be applied. I'm reading a book on hardware state machines at the moment with an eye towards a potential implementation. That would mean that, for instance, microcode implementations would be fully verifiable at the hardware level.</p>

<a name="188284807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/hardware%20verification/near/188284807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/75506hardwareverification.html#188284807">Tim Daly (Feb 15 2020 at 14:04)</a>:</h4>
<p>For those who want to play along see Volnei Pedroni "Finite State Machines in Hardware" (<a href="https://www.amazon.com/Finite-State-Machines-Hardware-SystemVerilog/dp/0262019663" target="_blank" title="https://www.amazon.com/Finite-State-Machines-Hardware-SystemVerilog/dp/0262019663">https://www.amazon.com/Finite-State-Machines-Hardware-SystemVerilog/dp/0262019663</a>)</p>

<a name="188285072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/hardware%20verification/near/188285072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/75506hardwareverification.html#188285072">Tim Daly (Feb 15 2020 at 14:12)</a>:</h4>
<p>Lean seems to have an advantage over, say ACL2, in that we have dependent types. It should be possible to declare a 'register type' that knows the size of the register, for example.</p>

<a name="188302053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/hardware%20verification/near/188302053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/75506hardwareverification.html#188302053">Tim Daly (Feb 15 2020 at 22:50)</a>:</h4>
<p>Lets play 'assume'. Assume you can prove that a hardware finite state machine (FSM) implements a specification. (Since the implementation is finite state then it seems you can use a SAT solver?). Assume that the specification is Lean's proof checker (so the FSM can check a Lean proof). Assume the state machine(s) is small enough to fit in an Field Programmable Gate Array (FPGA) (which are huge these days). Then there is a piece of hardware to proof check. Note that the large data center companies (but not ordinary mortals) have access to the new Intel CPU which has a built-in FPGA. So... one could have a hardware "instruction" to check a proof.</p>

<a name="188302174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/hardware%20verification/near/188302174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/75506hardwareverification.html#188302174">Tim Daly (Feb 15 2020 at 22:54)</a>:</h4>
<p>(sorry, wrote thread). A more (mealy?) interesting question: Can CIC be implemented in finite state machines?</p>


{% endraw %}

{% include archive_update.html %}