---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/86753TFAE.html
---

## Stream: [general](index.html)
### Topic: [TFAE](86753TFAE.html)

---


{% raw %}
#### [ Reid Barton (Sep 07 2018 at 21:52)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133533223):
<p>What's the best way to structure the statement and proof when I want to prove (1), (2), and (3) are equivalent by showing (1) =&gt; (2) =&gt; (3) =&gt; (1)?</p>

#### [ Reid Barton (Sep 07 2018 at 22:01)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133533668):
<p>Let's say (1) is the definition of something, and (2) and (3) are alternate definitions and I'd like to end up with (1) &lt;=&gt; (2) and (1) &lt;=&gt; (3).<br>
I could just do something very straightforward (prove (1) =&gt; (2), (2) =&gt; (3), (3) =&gt; (1) as separate top-level lemmas, then conclude (1) &lt;=&gt; (2) and (1) &lt;=&gt; (3) manually) but maybe there is a better idea.</p>

#### [ Keeley Hoek (Sep 08 2018 at 05:47)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133552573):
<p>it'd be cool if there was a tactic for this</p>

#### [ Mario Carneiro (Sep 08 2018 at 05:51)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133552679):
<p>I'm not sure how a tactic could help. The problem is the proof structuring, you don't want all three major parts to be in one big proof</p>

#### [ Mario Carneiro (Sep 08 2018 at 05:52)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133552721):
<p>It is easy enough to encode the idea of a cycle in a preorder, and deduce equivalence of all parts, which you could prove once and for all and apply as a theorem for your 11-part theorem</p>

#### [ Mario Carneiro (Sep 08 2018 at 05:53)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133552726):
<p>For the case of 2 or 3 statements, it's easier just to use the lemmas as given</p>

#### [ Mario Carneiro (Sep 08 2018 at 05:54)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133552773):
<p>I'm not sure I've ever had a case of 4+ statements proven in cyclic order where I actually care about all 4 equivalences</p>

#### [ Keeley Hoek (Sep 08 2018 at 06:26)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133553769):
<p>I was just thinking of a tactic which turns a single goal "a iff b iff c iff d iff ..." into a cyclic set of goals "a=&gt;b", "b=&gt;c", etc. Probably itd be too yuck for anything big?</p>

#### [ Mario Carneiro (Sep 08 2018 at 06:30)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133553893):
<p>There are two problems with that: (1) the goals might be big - if they aren't there isn't really a need for this (2) The output is <code>a iff b iff c</code> - what is that? If it is a big conjunction then there is still work to be done to make a usable lemma</p>

#### [ Keeley Hoek (Sep 08 2018 at 06:30)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133553898):
<p>yep ok sure</p>

#### [ Reid Barton (Sep 08 2018 at 10:21)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133559919):
<blockquote>
<p>(2) The output is <code>a iff b iff c</code> - what is that? If it is a big conjunction then there is still work to be done to make a usable lemma</p>
</blockquote>
<p>Yeah, this is where I really got stuck</p>

#### [ Chris Hughes (Sep 08 2018 at 11:32)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133561811):
<p>Also <code>a iff b iff c</code> is not the same as <code>a iff b and b iff c</code></p>

#### [ Reid Barton (Sep 08 2018 at 11:45)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133562136):
<p>I guess one out-there idea is to define</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">the_following_are_equivalent</span> <span class="o">(</span><span class="n">ps</span> <span class="o">:</span> <span class="n">list</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">p</span> <span class="n">q</span> <span class="err">∈</span> <span class="n">ps</span><span class="o">,</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">q</span>
</pre></div>


<p>and then a helper function which extracts for a given pair of indices implication (or bi-implication) between the corresponding Props</p>

#### [ Reid Barton (Sep 08 2018 at 11:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133562550):
<p>Mario I do agree that when the list is really long, typically some of the equivalent statements are not included for later use, but rather to elucidate the structure of the argument. Or to say: here is a variant definition of something and you might wonder whether it is equivalent to the official one; it is (and now we never need to talk about it again).</p>

#### [ Simon Hudon (Sep 09 2018 at 01:54)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133586841):
<p>I could imagine a presentation like:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">my_interesting_equivalences</span> <span class="o">:</span>
   <span class="n">the_following_are_equivalent</span>
    <span class="o">[</span> <span class="n">formula1</span><span class="o">,</span>
      <span class="n">formula2</span><span class="o">,</span>
      <span class="n">formula3</span> <span class="o">]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">circular_implication</span><span class="o">,</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> proof1 -/</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> proof2 -/</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> proof3 -/</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>


<p>and have <code>circular_implication</code> extract the two by two equivalences as separate lemmas: <code>my_interesting_equivalences_1_2</code>, my_interesting_equivalences_1_3<code>, my_interesting_equivalences_2_3</code>.</p>

#### [ Simon Hudon (Sep 09 2018 at 01:56)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133586909):
<p>Or, even better:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">my_interesting_equivalences</span> <span class="o">:</span>
   <span class="n">the_following_are_equivalent</span>
    <span class="o">[</span> <span class="n">Reids_defn</span> <span class="bp">::=</span> <span class="n">formula1</span><span class="o">,</span>
      <span class="n">Simons_defn</span> <span class="bp">::=</span> <span class="n">formula2</span><span class="o">,</span>
      <span class="n">Marios_defn</span> <span class="bp">::=</span> <span class="n">formula3</span> <span class="o">]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">circular_implication</span><span class="o">,</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> proof1 -/</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> proof2 -/</span> <span class="o">},</span>
  <span class="o">{</span> <span class="c">/-</span><span class="cm"> proof3 -/</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>


<p>and then have <code>my_interesting_equivalences_Reids_defn_iff_Simons_defn</code> etc and make <code>Reids_defn</code>, <code>Simons_defn</code> and <code>Marios_defn</code> into stand alone definitions.</p>

#### [ Mario Carneiro (Sep 09 2018 at 02:01)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587038):
<p>This won't work inside a theorem, you can't make new definitions</p>

#### [ Mario Carneiro (Sep 09 2018 at 02:02)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587079):
<p>Also, that's a quadratic number of generated lemmas</p>

#### [ Simon Hudon (Sep 09 2018 at 02:06)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587184):
<blockquote>
<p>This won't work inside a theorem, you can't make new definitions</p>
</blockquote>
<p>I'm fairly sure that you can.</p>

#### [ Simon Hudon (Sep 09 2018 at 02:08)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587234):
<blockquote>
<p>Also, that's a quadratic number of generated lemmas</p>
</blockquote>
<p>Yes it is but that's what you're trying to prove if you use this approach, no? You could also state only consecutive equivalences but I think that would make the use of those lemmas harder.</p>

#### [ Kenny Lau (Sep 09 2018 at 02:16)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587455):
<p>I know there's a tactic that can generate iff statements for any inductive type</p>

#### [ Mario Carneiro (Sep 09 2018 at 02:18)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587500):
<p>Here's how I think you can do it with just definitions:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">namespace</span> <span class="n">list</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">last&#39;</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">[]</span>     <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span> <span class="o">:=</span> <span class="n">last&#39;</span> <span class="n">b</span> <span class="n">l</span>

<span class="n">def</span> <span class="n">TFAE</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">l</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">l</span><span class="o">,</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">y</span>

<span class="kn">theorem</span> <span class="n">TFAE_of_cycle</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">chain</span> <span class="o">(</span><span class="bp">→</span><span class="o">)</span> <span class="n">a</span> <span class="o">(</span><span class="n">b</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">last&#39;</span> <span class="n">b</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="n">TFAE</span> <span class="o">(</span><span class="n">a</span><span class="bp">::</span><span class="n">b</span><span class="bp">::</span><span class="n">l</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="n">def</span> <span class="n">TFAE</span><span class="bp">.</span><span class="n">out</span> <span class="o">{</span><span class="n">l</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">TFAE</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">n₁</span> <span class="n">n₂</span><span class="o">)</span>
 <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">n₁</span> <span class="bp">&lt;</span> <span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="n">l</span> <span class="bp">.</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">exact_dec_trivial</span><span class="o">)</span>
 <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">n₂</span> <span class="bp">&lt;</span> <span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="n">l</span> <span class="bp">.</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">exact_dec_trivial</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">l</span> <span class="n">n₁</span> <span class="n">h₁</span> <span class="bp">↔</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">l</span> <span class="n">n₂</span> <span class="n">h₂</span> <span class="o">:=</span>
<span class="n">h</span> <span class="bp">_</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">nth_le_mem</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">nth_le_mem</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">TFAE_test</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">TFAE</span> <span class="o">[</span><span class="n">true</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span><span class="o">]</span> <span class="o">:=</span>
<span class="n">TFAE_of_cycle</span> <span class="o">(</span><span class="k">by</span> <span class="n">simp</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">trivial</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span> <span class="o">(</span><span class="n">TFAE_test</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span><span class="bp">.</span><span class="n">out</span> <span class="mi">1</span> <span class="mi">2</span>

<span class="kn">end</span> <span class="n">list</span>
</pre></div>

#### [ Mario Carneiro (Sep 09 2018 at 02:19)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587508):
<p>A tactic could be used to unfold the definitions involved in <code>TFAE_of_cycle</code></p>

#### [ Mario Carneiro (Sep 09 2018 at 02:19)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587509):
<p>then again, <code>simp</code> already does that</p>

#### [ Kenny Lau (Sep 09 2018 at 02:21)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587554):
<p>wow that's so magical</p>

#### [ Mario Carneiro (Sep 09 2018 at 02:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133587995):
<p>Another option besides <code>TFAE.out</code> is to use</p>
<div class="codehilite"><pre><span></span>theorem TFAE_iff_iff {a l} : TFAE (a::l) ↔ ∀ b ∈ l, a ↔ b := sorry
</pre></div>


<p>as a simp lemma, that way you can simplify a <code>TFAE</code> into a bunch of iffs with the first thing in the list (which is usually what you will want to have as the output theorems)</p>

#### [ Cyril Cohen (Sep 11 2018 at 18:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133745529):
<p><span class="user-mention" data-user-id="110172">@Assia Mahboubi</span> pointed this thread to me. It is funny because I was considering adding such a feature to mathcomp: <a href="https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf" target="_blank" title="https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf">https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf</a></p>

#### [ Patrick Massot (Sep 11 2018 at 19:55)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133748935):
<p>What is the interface you chose then? It's hard to tell from the link  without knowing Coq</p>

#### [ Cyril Cohen (Sep 12 2018 at 13:23)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133792495):
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I chose something like: <code>[↔ P0; ...; Pn] := (all_iff P0 [P1; ...; Pn]) := ((P0 → P1) ∧ (P1 → P2) ∧ ... ∧ (Pn → P0))</code> (pseudo syntax)<br>
And the main theorem <code>all_iffLR</code> says roughly that <code>[↔ P0; ...; Pn] → ∀i j, Pi → Pj</code> (pseudo syntax again), and is a coercion to a function, so that a lemma <code>mylemma : [↔ P0; ...; Pn]</code> can be applied to natural numbers to give <code>mylemma i j</code>, a proof of <code>Pi → Pj</code>.</p>

#### [ Johan Commelin (Sep 12 2018 at 13:30)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133792868):
<p>That looks like a really nice way to attack this.</p>

#### [ Johan Commelin (Sep 12 2018 at 13:32)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133792930):
<p>As a mathematician I wonder if we could use tactics to allow for even more general ways of proving an <code>all_iff</code> instead of only cycles.</p>

#### [ Cyril Cohen (Sep 12 2018 at 13:33)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133792958):
<p>One of the improvements I have in mind is to provide a graph. And have the computational part of the system check it is strongly connected, then ask to prove only the edges. (so no deep tactic involved, just reflexion)</p>

#### [ Johan Commelin (Sep 12 2018 at 13:34)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793003):
<p>Right.</p>

#### [ Johan Commelin (Sep 12 2018 at 13:34)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793006):
<p>But it would allow for more convenience.</p>

#### [ Cyril Cohen (Sep 12 2018 at 13:34)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793017):
<p>Yes</p>

#### [ Johan Commelin (Sep 12 2018 at 13:35)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793019):
<p>The interactive version would first ask the user to supply a graph. Then the system does the connectedness check (or asks the user for a proof). And then the tactic goes on to supply you all the edges 1-by-1</p>

#### [ Johan Commelin (Sep 12 2018 at 13:35)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793042):
<p>I mean, check this out: <a href="https://stacks.math.columbia.edu/tag/04GG" target="_blank" title="https://stacks.math.columbia.edu/tag/04GG">https://stacks.math.columbia.edu/tag/04GG</a></p>

#### [ Johan Commelin (Sep 12 2018 at 13:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793116):
<p>Too bad we don't have a lot about graphs in Lean.</p>

#### [ Cyril Cohen (Sep 12 2018 at 13:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793117):
<p>I would start my proof by applying the lemma <code>all_iff_from [(2,1);(5,3)...]</code>(implicit arguments + unification would do the job of checking the connectedness of the graph, and a split would ask for all the implications, that is why I see no need for a tactic...</p>

#### [ Cyril Cohen (Sep 12 2018 at 13:38)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793166):
<p>And since we have graphs in coq with math-comp, I am really eager to try :)</p>

#### [ Johan Commelin (Sep 12 2018 at 13:38)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793173):
<p>But do you have henselian local rings?</p>

#### [ Johan Commelin (Sep 12 2018 at 13:38)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793175):
<p>Just kidding...</p>

#### [ Johan Commelin (Sep 12 2018 at 13:39)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793184):
<p>I would love to have this kind of stuff in Lean!</p>

#### [ Johan Commelin (Sep 12 2018 at 13:39)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793189):
<p>How hard is the connectedness check? I guess that shouldn't be too hard, right?</p>

#### [ Cyril Cohen (Sep 12 2018 at 13:40)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793241):
<p>it is just a dfs</p>

#### [ Johan Commelin (Sep 12 2018 at 13:40)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793242):
<p>/me walks over to his copy of TAOCP</p>

#### [ Johan Commelin (Sep 12 2018 at 13:40)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793250):
<p>Right, and you need to generate a proof along the way.</p>

#### [ Johan Commelin (Sep 12 2018 at 13:41)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793266):
<p>(I've never really written tactics before... so I'm just thinking out loud.)</p>

#### [ Johan Commelin (Sep 12 2018 at 13:42)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793352):
<p>Hmmm... but most of this isn't even <code>meta</code>.</p>

#### [ Johan Commelin (Sep 12 2018 at 13:43)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793369):
<p><span class="user-mention" data-user-id="110193">@Cyril Cohen</span> Two questions: (1) Do you have any experience in Lean? (2) Where can we find your coq implementation?</p>

#### [ Cyril Cohen (Sep 12 2018 at 13:47)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793540):
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> (1) I only saw <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> and <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> in action, I have no more experience than that. (2) my current coq implementation does not support graphs yet, only what I described in the message you replied to and it is here: <a href="https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf" target="_blank" title="https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf">https://github.com/math-comp/math-comp/commit/0d41046cff37af7b85da0e771e3d25a4c640edbf</a> (waiting patiently to be cleaned and merged since august)</p>

#### [ Johan Commelin (Sep 12 2018 at 13:50)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793720):
<p>Ok, understood <span class="emoji emoji-1f44d" title="thumbs up">:thumbs_up:</span></p>

#### [ Patrick Massot (Sep 12 2018 at 13:55)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133793964):
<p>Nice! So the current implementation in Coq is about using a chain of equivalences, not proving it. But clearly both ways are useful. I'm sure we'll soon have this in Lean</p>

#### [ Cyril Cohen (Sep 12 2018 at 13:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133794023):
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> it's also about proving it, but only from circular implications <code>P0 -&gt; ... -&gt; Pn -&gt; P0</code> (no arbitrary strongly connected graph)</p>

#### [ Patrick Massot (Sep 12 2018 at 14:10)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133794539):
<p>ok, nice</p>

#### [ Patrick Massot (Sep 12 2018 at 14:11)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133794566):
<p>I guess it already covers most use cases, you only need to list the conditions in the order you intend to prove the chain of implications, and then you can use any implication</p>

#### [ Johan Commelin (Sep 12 2018 at 14:13)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133794674):
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>

<span class="bp">@</span><span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">def</span> <span class="n">vector</span><span class="bp">.</span><span class="n">mk</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">pr</span> <span class="o">:</span> <span class="n">l</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">l</span><span class="o">,</span> <span class="n">pr</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">all_iff</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">vector</span> <span class="kt">Prop</span> <span class="n">n</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="n">Ps</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="mi">1</span>     <span class="n">Ps</span> <span class="o">:=</span> <span class="n">Ps</span><span class="bp">.</span><span class="n">head</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="n">Ps</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Ps</span><span class="bp">.</span><span class="n">head</span> <span class="bp">→</span> <span class="n">Ps</span><span class="bp">.</span><span class="n">tail</span><span class="bp">.</span><span class="n">head</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">all_iff</span> <span class="n">Ps</span><span class="bp">.</span><span class="n">tail</span><span class="o">)</span>

<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`</span><span class="o">[</span><span class="bp">↔`</span> <span class="n">l</span><span class="o">:(</span><span class="n">foldr</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">all_iff</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">mk</span> <span class="n">l</span> <span class="n">rfl</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">[</span><span class="bp">↔</span> <span class="n">true</span><span class="o">,</span> <span class="n">false</span><span class="o">]</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="n">def</span> <span class="n">all_iff_LR</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">Ps</span> <span class="o">:</span> <span class="n">vector</span> <span class="kt">Prop</span> <span class="n">n</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">all_iff</span> <span class="n">Ps</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">Ps</span><span class="bp">.</span><span class="n">nth</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">Ps</span><span class="bp">.</span><span class="n">nth</span> <span class="n">j</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

#### [ Johan Commelin (Sep 12 2018 at 14:16)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133794856):
<p>Oops, there is a bug. I'm not closing the cycle.</p>

#### [ Reid Barton (Sep 12 2018 at 14:24)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133795209):
<p>Somewhere on Twitch there is now a video of me having proved 1 =&gt; 2 and 2 =&gt; 3 and 3 =&gt; 1 and then taking several minutes to figure out how to prove 2 &lt;=&gt; 1 and 3 &lt;=&gt; 1 and then later being unable to remember whether I had proved 2 &lt;=&gt; 1 or 1 &lt;=&gt; 2. So I guess there is some real non-zero value to this.</p>

#### [ Johan Commelin (Sep 12 2018 at 14:42)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796095):
<p>This is better:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>

<span class="bp">@</span><span class="o">[</span><span class="n">pattern</span><span class="o">]</span> <span class="n">def</span> <span class="n">vector</span><span class="bp">.</span><span class="n">mk</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">pr</span> <span class="o">:</span> <span class="n">l</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">l</span><span class="o">,</span> <span class="n">pr</span><span class="bp">⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="n">def</span> <span class="n">all_iff&#39;</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="n">list</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">P₀</span> <span class="o">[]</span>               <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">P₀</span> <span class="o">(</span><span class="n">P₁</span> <span class="bp">::</span> <span class="o">[])</span>       <span class="o">:=</span> <span class="n">P₁</span> <span class="bp">→</span> <span class="n">P₀</span>
<span class="bp">|</span> <span class="n">P₀</span> <span class="o">(</span><span class="n">P₁</span> <span class="bp">::</span> <span class="n">P₂</span> <span class="bp">::</span> <span class="n">Ps</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">P₁</span> <span class="bp">→</span> <span class="n">P₂</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">all_iff&#39;</span> <span class="n">P₀</span> <span class="o">(</span><span class="n">P₂</span> <span class="bp">::</span> <span class="n">Ps</span><span class="o">)</span>

<span class="n">def</span> <span class="n">all_iff</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">vector</span> <span class="kt">Prop</span> <span class="n">n</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="o">[],</span>             <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">P</span> <span class="bp">::</span> <span class="o">[],</span>        <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">true</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">P₀</span> <span class="bp">::</span> <span class="n">P₁</span> <span class="bp">::</span> <span class="n">Ps</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="o">(</span><span class="n">P₀</span> <span class="bp">→</span> <span class="n">P₁</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">all_iff&#39;</span> <span class="n">P₀</span> <span class="o">(</span><span class="n">P₁</span> <span class="bp">::</span> <span class="n">Ps</span><span class="o">)</span>

<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`</span><span class="o">[</span><span class="bp">↔`</span> <span class="n">l</span><span class="o">:(</span><span class="n">foldr</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">all_iff</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">mk</span> <span class="n">l</span> <span class="n">rfl</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">[</span><span class="bp">↔</span> <span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">,</span> <span class="n">true</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span> <span class="n">tauto</span><span class="o">,</span>
  <span class="n">dsimp</span> <span class="o">[</span><span class="n">all_iff&#39;</span><span class="o">],</span> <span class="n">tauto</span>
<span class="kn">end</span>
</pre></div>

#### [ Johan Commelin (Sep 12 2018 at 14:42)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796112):
<p>I would like to not have the <code>dsimp [all_iff']</code> in the example. I marked the definition <code>reducible</code>, but that didn't help.</p>

#### [ Reid Barton (Sep 12 2018 at 14:45)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796235):
<p>I don't know whether this matters here, but when I was playing around with this stuff I found you can also do</p>
<div class="codehilite"><pre><span></span><span class="n">local</span> <span class="kn">notation</span> <span class="bp">`</span><span class="o">[</span><span class="bp">↔`</span> <span class="n">p0</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="n">l</span><span class="o">:(</span><span class="n">foldr</span> <span class="bp">`</span><span class="o">,</span> <span class="bp">`</span> <span class="o">(</span><span class="n">h</span> <span class="n">t</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">cons</span> <span class="n">h</span> <span class="n">t</span><span class="o">)</span> <span class="n">list</span><span class="bp">.</span><span class="n">nil</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">all_iff</span> <span class="o">(</span><span class="n">vector</span><span class="bp">.</span><span class="n">mk</span> <span class="o">(</span><span class="n">p0</span> <span class="bp">::</span> <span class="n">l</span><span class="o">)</span> <span class="n">rfl</span><span class="o">)</span>
</pre></div>

#### [ Reid Barton (Sep 12 2018 at 14:45)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796240):
<p>which lets you guarantee that the list is nonempty</p>

#### [ Johan Commelin (Sep 12 2018 at 14:48)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796412):
<p>I'm not sure if we want that guarantee... for interaction sure. But maybe this code will also be used in automation or something. And then it would be nice if <code>[]</code> is not a problem.</p>

#### [ Reid Barton (Sep 12 2018 at 14:50)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796518):
<p>If you <code>dsimp only [all_iff, all_iff', vector.mk]</code> first then you get a conjunction of the 3 iffs</p>

#### [ Reid Barton (Sep 12 2018 at 14:51)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796551):
<p>I thought it might be more likely that allowing <code>[]</code> is a problem for automation than that disallowing it is a problem. But I'm not sure either, just thought I would mention the possibility.</p>

#### [ Reid Barton (Sep 12 2018 at 14:55)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796744):
<p>I think a very simple tactic which turns an <code>all_iff</code> goal with list of length N into N subgoals (or possibly a conjunction of N implications) will probably be useful. Otherwise, I think it will be hard to avoid making the intermediate goals confusing.</p>

#### [ Johan Commelin (Sep 12 2018 at 14:56)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133796811):
<p>True, something like that is necessary.</p>

#### [ Johan Commelin (Sep 12 2018 at 15:04)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797157):
<p><span class="user-mention" data-user-id="110193">@Cyril Cohen</span> I am very bad at reading coq code, apparently...</p>

#### [ Johan Commelin (Sep 12 2018 at 15:05)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797191):
<p>I'm trying to prove <code>all_iff_LR</code> in Lean. I'm exploding into different cases. Is there a good strategy to prove this by induction?</p>

#### [ Johan Commelin (Sep 12 2018 at 15:05)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797194):
<p>Do you case on <code>i &lt; j</code> or something similar?</p>

#### [ Cyril Cohen (Sep 12 2018 at 15:09)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797383):
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span>  I am using a lemma saying (roughly) that a function <code>f : nat -&gt; T</code> respects the order (<code>&lt;</code> for nat, and an arbitrary order on <code>T</code> (<code>-&gt;</code> on <code>Prop</code> in our case)) if one can prove that <code>f i  &lt; f (i + 1)</code> (or <code>f i -&gt; f (i + 1)</code> in our case). Only then, I do an induction.</p>

#### [ Johan Commelin (Sep 12 2018 at 15:10)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797460):
<p>Hmm, I see. That seems smart.</p>

#### [ Johan Commelin (Sep 12 2018 at 15:11)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797517):
<p>So now I need to find that lemma in mathlib. <span class="user-mention" data-user-id="110064">@Kenny Lau</span> Do you know the function that Cyril is talking about?</p>

#### [ Kenny Lau (Sep 12 2018 at 15:12)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797578):
<p>is it even in mathlib?</p>

#### [ Kenny Lau (Sep 12 2018 at 15:12)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797582):
<p>I'd just use induction to prove it</p>

#### [ Johan Commelin (Sep 12 2018 at 15:12)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133797584):
<p>Dunno.</p>

#### [ Johan Commelin (Sep 12 2018 at 15:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133798133):
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">foobar</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">f</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">f</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h</span> <span class="n">i</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">le_succ</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">monotone</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">induction</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">h</span> <span class="n">ih</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">refl</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">le_trans</span> <span class="n">ih</span> <span class="o">(</span><span class="n">H</span> <span class="n">x</span><span class="o">)</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

#### [ Johan Commelin (Sep 12 2018 at 15:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133798146):
<p>It still needs a name and golfing (-;</p>

#### [ Johan Commelin (Sep 12 2018 at 16:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133802962):
<p>Ok, I'm making slow progress. I'll try to post something later tonight.</p>

#### [ Johan Commelin (Sep 12 2018 at 16:46)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133803540):
<p><span class="user-mention" data-user-id="110524">@Scott Morrison</span> <span class="user-mention" data-user-id="110111">@Keeley Hoek</span>  I think I found a missing feature in <code>tidy</code>. It doesn't split <code>\iff</code> in the assumptions into two implications. If it did, I guess it could have solved more of my goals.</p>

#### [ Keeley Hoek (Sep 12 2018 at 17:07)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133804789):
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> Could you give me an example? In the (admittedly baby) example</p>
<div class="codehilite"><pre><span></span>constants a b : Prop

def lol : iff a b := begin
  tidy,
  admit
end
</pre></div>


<p><code>tidy</code> does do what you're saying, I think.</p>

#### [ Keeley Hoek (Sep 12 2018 at 17:09)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133804897):
<p>Or are you talking about <code>tidy</code> not converting <code>iff</code> hypotheses into a pair of <code>implies</code> hypotheses? Maybe it should do that...</p>

#### [ Keeley Hoek (Sep 12 2018 at 17:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133805759):
<p>For the latter, give <a href="https://github.com/leanprover/mathlib/pull/344" target="_blank" title="https://github.com/leanprover/mathlib/pull/344">https://github.com/leanprover/mathlib/pull/344</a> (i.e. <a href="https://github.com/leanprover-community/mathlib/tree/auto-cases-iff" target="_blank" title="https://github.com/leanprover-community/mathlib/tree/auto-cases-iff">https://github.com/leanprover-community/mathlib/tree/auto-cases-iff</a>) a try.</p>

#### [ Johan Commelin (Sep 12 2018 at 18:53)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133811896):
<p><span class="user-mention" data-user-id="110111">@Keeley Hoek</span> Cool! That kills of another goal (-;</p>

#### [ Mario Carneiro (Sep 12 2018 at 19:14)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133812980):
<p>What was wrong with the sketch I gave earlier for <code>TFAE_of_cycle</code>? It should be isomorphic to cyril's definition</p>

#### [ Keeley Hoek (Sep 12 2018 at 19:21)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133813298):
<p>that <code>list.chain</code> syntax is sick Mario</p>

#### [ Mario Carneiro (Sep 12 2018 at 19:46)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133814801):
<p>Here's the whole proof:</p>
<div class="codehilite"><pre><span></span>namespace list

@[simp] def last&#39; {α} : α → list α → α
| a []     := a
| a (b::l) := last&#39; b l

theorem last&#39;_mem {α} : ∀ a l, @last&#39; α a l ∈ a :: l
| a []     := or.inl rfl
| a (b::l) := or.inr (last&#39;_mem b l)

def TFAE (l : list Prop) : Prop := ∀ x ∈ l, ∀ y ∈ l, x ↔ y

theorem TFAE_nil : TFAE [] := forall_mem_nil _
theorem TFAE_singleton (p) : TFAE [p] := by simp [TFAE]

theorem TFAE_cons_of_mem {a b} {l : list Prop} (h : b ∈ l) :
  TFAE (a::l) ↔ (a ↔ b) ∧ TFAE l :=
⟨λ H, ⟨H a (by simp) b (or.inr h), λ p hp q hq, H _ (or.inr hp) _ (or.inr hq)⟩,
 begin
   rintro ⟨ab, H⟩ p (rfl | hp) q (rfl | hq),
   { refl },
   { exact ab.trans (H _ h _ hq) },
   { exact (ab.trans (H _ h _ hp)).symm },
   { exact H _ hp _ hq }
 end⟩

theorem TFAE_cons_cons {a b} {l : list Prop} : TFAE (a::b::l) ↔ (a ↔ b) ∧ TFAE (b::l) :=
TFAE_cons_of_mem (or.inl rfl)

theorem TFAE_of_cycle {a b} {l : list Prop} :
  list.chain (→) a (b::l) → (last&#39; b l → a) → TFAE (a::b::l) :=
begin
  induction l with c l IH generalizing a b; simp [TFAE_cons_cons, TFAE_singleton] at *,
  { exact iff.intro },
  intros ab bc ch la,
  have := IH bc ch (ab ∘ la),
  exact ⟨⟨ab, la ∘ (this.2 c (or.inl rfl) _ (last&#39;_mem _ _)).1 ∘ bc⟩, this⟩
end

theorem TFAE.out {l} (h : TFAE l) (n₁ n₂)
 (h₁ : n₁ &lt; list.length l . tactic.exact_dec_trivial)
 (h₂ : n₂ &lt; list.length l . tactic.exact_dec_trivial) :
  list.nth_le l n₁ h₁ ↔ list.nth_le l n₂ h₂ :=
h _ (list.nth_le_mem _ _ _) _ (list.nth_le_mem _ _ _)

theorem TFAE_test (x y : ℕ) : TFAE [true, x = x, y = y] :=
TFAE_of_cycle (by simp) (λ _, trivial)

example (x y : ℕ) : x = x ↔ y = y := (TFAE_test x y).out 1 2

end list
</pre></div>

#### [ Mario Carneiro (Sep 12 2018 at 19:49)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133814995):
<p>There is a theorem that says that you can put a <code>list.chain</code> together over a transitive relation, but I had to prove the rest by induction anyway so it wasn't necessary</p>

#### [ Johan Commelin (Sep 12 2018 at 19:53)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815251):
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I think the only thing that was wrong with it was that I didn't understand what you were doing...</p>

#### [ Mario Carneiro (Sep 12 2018 at 19:54)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815331):
<p><code>list.chain</code> says that you have forward implications along the list, <code>last l -&gt; a</code> gives the final backward arrow</p>

#### [ Mario Carneiro (Sep 12 2018 at 19:55)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815344):
<p>and they are both defined naturally by recursion making the proofs easy</p>

#### [ Johan Commelin (Sep 12 2018 at 19:56)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815437):
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Ok, so I was almost done with a slightly clunkier implementation. <span class="emoji emoji-1f606" title="lol">:lol:</span></p>

#### [ Johan Commelin (Sep 12 2018 at 19:56)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815453):
<p>Would you mind pushing your stuff to a <code>tfae</code> branch on community?</p>

#### [ Johan Commelin (Sep 12 2018 at 19:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815472):
<p>I think we should put everything into a <code>tfae</code> namespace.</p>

#### [ Mario Carneiro (Sep 12 2018 at 19:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815506):
<p>I would just put it all in <code>list.basic</code></p>

#### [ Mario Carneiro (Sep 12 2018 at 19:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815535):
<p>and in the <code>list</code> namespace, as you can see</p>

#### [ Johan Commelin (Sep 12 2018 at 19:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815542):
<p>Ok, fine with me.</p>

#### [ Johan Commelin (Sep 12 2018 at 19:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815556):
<p>Do you want to capitalise TFAE?</p>

#### [ Mario Carneiro (Sep 12 2018 at 19:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815569):
<p>dunno, seemed nicer that way</p>

#### [ Mario Carneiro (Sep 12 2018 at 19:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815582):
<p><code>tfae</code> could be misread?</p>

#### [ Johan Commelin (Sep 12 2018 at 19:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815591):
<p>Maybe. <code>TFAE</code> feels like shouting.</p>

#### [ Johan Commelin (Sep 12 2018 at 19:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815594):
<p>I wouldn't mind having <code>tfae</code>.</p>

#### [ Mario Carneiro (Sep 12 2018 at 19:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815600):
<p>it's always the way I see it on the blackboard</p>

#### [ Johan Commelin (Sep 12 2018 at 20:00)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815668):
<p>That is true. But on the blackboard I also see <code>Lemma</code> and <code>Thm</code>...</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:01)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815706):
<p>I would also not have any notation. for me <code>tfae [p, q, r]</code> is sufficient</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:01)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815719):
<p><code>[&lt;-&gt; p, q, r]</code> doesn't seem to buy much</p>

#### [ Johan Commelin (Sep 12 2018 at 20:02)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815762):
<p>Right, I also came to that conclusion</p>

#### [ Johan Commelin (Sep 12 2018 at 20:02)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815778):
<p>It is even easier to read.</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:02)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815782):
<p>(none of this is to cast aspersions on Cyril's work; the style and design decisions are different there)</p>

#### [ Johan Commelin (Sep 12 2018 at 20:03)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815809):
<p>If you push your stuff, I would like to see if I can do anything with <code>tfae_of_graph</code>.</p>

#### [ Johan Commelin (Sep 12 2018 at 20:03)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133815842):
<p>Some how you need to show that the transitive closure of the relation that is your graph is everything. Would an <code>auto_param</code> be able to do that?</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:09)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816149):
<p>you are talking about Cyril's extension? I wouldn't want to try that without using a tactic to guide the whole process</p>

#### [ Johan Commelin (Sep 12 2018 at 20:10)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816223):
<p>Why not?</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:10)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816232):
<p>because the number of goals is very nonuniform</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:10)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816246):
<p>the types are too complicated to get much help from lean</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:11)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816275):
<p>again, this reflects a difference in design from Coq. It's easier to do strongly connected checking in the kernel in Coq</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:12)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816318):
<p>in lean we would do it with a tactic</p>

#### [ Johan Commelin (Sep 12 2018 at 20:15)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816459):
<p>Pseudo-code:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">tfae_of_graph</span> <span class="o">(</span><span class="n">Ps</span> <span class="o">:</span> <span class="n">list</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span> <span class="n">x</span> <span class="n">fin</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">proof_that_G_generates_everything</span><span class="o">)</span>
<span class="o">(</span><span class="n">proofs</span> <span class="o">:</span> <span class="err">\</span><span class="k">forall</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="err">\</span><span class="k">in</span> <span class="n">G</span><span class="o">,</span> <span class="n">Ps</span> <span class="n">i</span> <span class="err">\</span><span class="n">implies</span> <span class="n">Ps</span> <span class="n">j</span><span class="o">)</span> <span class="o">:</span> <span class="n">tfae</span> <span class="n">Ps</span>
</pre></div>

#### [ Johan Commelin (Sep 12 2018 at 20:15)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816476):
<p>Ok, I agree that maybe the Lean way is to use tactics</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:16)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816547):
<p>You would have to supply <code>proofs</code> manually which is not nice</p>

#### [ Johan Commelin (Sep 12 2018 at 20:16)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816551):
<p>I don't know anything about <code>auto_param</code>s but I would definitely want <code>H</code> to be automated by some tactic.</p>

#### [ Johan Commelin (Sep 12 2018 at 20:17)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816571):
<p>Right, so <code>proofs</code> better be a list of <code>mvar</code>s, is that what you mean?</p>

#### [ Patrick Massot (Sep 12 2018 at 20:17)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816572):
<p>this would not be interactive because of the proofs parameter</p>

#### [ Johan Commelin (Sep 12 2018 at 20:17)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816600):
<p>Well, if you <code>apply</code> it, you would then be left with a goal that asks for <code>proofs</code>.</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:17)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816605):
<p>Here's a conjecture: Given any SC graph on 1...n, there is a way to connect 1-2, 2-3, ..., n-1 by disjoint paths in the graph</p>

#### [ Johan Commelin (Sep 12 2018 at 20:17)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816612):
<p>And you would want to split that into a bunch of goals.</p>

#### [ Johan Commelin (Sep 12 2018 at 20:18)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816675):
<p>What is SC?</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:18)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816691):
<p>strongly connected</p>

#### [ Johan Commelin (Sep 12 2018 at 20:19)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816707):
<p>I see.</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:19)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816728):
<p>if true, the generalization is always redundant</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:20)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816808):
<p>if you supply 1&lt;-&gt;2 and 2&lt;-&gt;3 then you have four proofs, and you could have just composed the proofs 3-&gt;2 and 2-&gt;1 to get a result in the form for <code>tfae_of_cycle</code></p>

#### [ Johan Commelin (Sep 12 2018 at 20:20)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816824):
<p>Here is a graph: <code>1 -&gt; 3 -&gt; 2 -&gt; 1</code></p>

#### [ Mario Carneiro (Sep 12 2018 at 20:21)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816848):
<p>of course</p>

#### [ Johan Commelin (Sep 12 2018 at 20:21)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816862):
<p>Did I misunderstand your conjecture?</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:21)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816867):
<p>so I guess we need a theorem about permuting the graph</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:21)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816870):
<p>no, that's a counterexample</p>

#### [ Johan Commelin (Sep 12 2018 at 20:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133816918):
<p>I'dd just do a <code>meta</code> dfs</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834471):
<p>new conjecture: there is a way to permute the vertices so that the first conjecture holds</p>

#### [ Johan Commelin (Sep 12 2018 at 20:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834478):
<p>That is trivial</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834483):
<p>is it?</p>

#### [ Johan Commelin (Sep 12 2018 at 20:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834484):
<p>Hmm, maybe not.</p>

#### [ Johan Commelin (Sep 12 2018 at 20:24)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834580):
<p>But, why do you not want to reuse edges?</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:25)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834619):
<p>because that way you can achieve the same with a straight line proof where you inline the relevant parts in each subproof</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:25)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834636):
<p>i.e. the proof 3-&gt;2 only appears as part of the proof 3-&gt;1 in my example</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:26)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834680):
<p>so it doesn't need to be stored and reused</p>

#### [ Johan Commelin (Sep 12 2018 at 20:26)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834686):
<p>Here is another graph: <code>1 -&gt; 2 -&gt; 3 -&gt; 1;   2 -&gt; 4 -&gt; 1;   2 -&gt; 5 -&gt; 1</code></p>

#### [ Mario Carneiro (Sep 12 2018 at 20:27)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834726):
<p>foiled again</p>

#### [ Johan Commelin (Sep 12 2018 at 20:29)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834833):
<p>Hmm, you don't even need vertex <code>5</code>.</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:29)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834839):
<p>okay so we definitely need a tactic to manage this kind of structure</p>

#### [ Johan Commelin (Sep 12 2018 at 20:30)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834952):
<p>So the tactic takes a graph as input, and then proves that it is SC, and generates a list of goals, right?</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:31)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834966):
<p>yes</p>

#### [ Reid Barton (Sep 12 2018 at 20:31)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133834999):
<p>it might be worth considering the aforementioned <a href="https://stacks.math.columbia.edu/tag/04GG" target="_blank" title="https://stacks.math.columbia.edu/tag/04GG">https://stacks.math.columbia.edu/tag/04GG</a> when imagining what the UI might look like</p>

#### [ Patrick Massot (Sep 12 2018 at 20:31)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835001):
<p>Do we really want the tactic to decide on a list of implications to prove? Sometimes there will be several solutions, some easier than others</p>

#### [ Johan Commelin (Sep 12 2018 at 20:32)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835061):
<p>No, you provide a list of edges.</p>

#### [ Johan Commelin (Sep 12 2018 at 20:32)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835070):
<p>You get to prove those. And the tactic shows that this is enough.</p>

#### [ Patrick Massot (Sep 12 2018 at 20:32)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835078):
<p>ok, I prefer that</p>

#### [ Reid Barton (Sep 12 2018 at 20:32)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835080):
<p>for example, listing all the edges and then, separately, all the proofs might be less nice than being able to interleave them</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:33)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835110):
<p>My suggestion: suppose the goal is <code>tfae [p1, p2, p3, p4, p5]</code>, then you can call <code>tfae [1 -&gt; 2, 2 -&gt; 3, 3 -&gt; 1, 2 -&gt; 4, 4 -&gt; 1, 1 &lt;-&gt; 5]</code> and get six goals like <code>|- p1 -&gt; p2</code> and <code>|- p1 &lt;-&gt; p5</code></p>

#### [ Johan Commelin (Sep 12 2018 at 20:33)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835123):
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  Hmmm... but then it feels like you'll need a separate mode, like <code>conv</code> and <code>calc</code>.</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:34)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835191):
<p>ooh, should it be zero-based indexing?</p>

#### [ Johan Commelin (Sep 12 2018 at 20:34)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835197):
<p>In principal that is fine, but in practice we see that <code>conv</code> is limited by the fact that not all tactics that we'dd like to be there actually work.</p>

#### [ Johan Commelin (Sep 12 2018 at 20:35)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835221):
<p>I guess <code>0</code>-based is easier to implement. But I don't know if it is user friendly.</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:35)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835257):
<p>1 based is probably more user friendly, but I'm sure it will surprise someone either way</p>

#### [ Johan Commelin (Sep 12 2018 at 20:36)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835270):
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Do you think Reid's idea can be implemented in usual tactic mode?</p>

#### [ Reid Barton (Sep 12 2018 at 20:36)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835323):
<p>maybe rather than a plain list in tfae we should use an association list indexed by<br>
<code>inductive roman_number | i | ii | iii | iv | ...</code></p>

#### [ Mario Carneiro (Sep 12 2018 at 20:36)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835342):
<p>and how long does that <code>...</code> go? :P</p>

#### [ Johan Commelin (Sep 12 2018 at 20:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835351):
<p>at least till <code>xiii</code></p>

#### [ Mario Carneiro (Sep 12 2018 at 20:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835362):
<p>anyway it's not an actual type, it's just an input format</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835398):
<p><code>1 -&gt; 2</code> isn't well typed</p>

#### [ Reid Barton (Sep 12 2018 at 20:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835403):
<p>What I really mean though is if you actually had 13 things to prove equivalent, you wouldn't really want to have to count them whether you use 0-based or 1-based indexing</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835410):
<p>neither is <code>i -&gt; ii</code></p>

#### [ Mario Carneiro (Sep 12 2018 at 20:38)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835478):
<p>I don't see an alternative</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:38)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835493):
<p>lean can try to give you help in filling out the tactic arguments, but that's it</p>

#### [ Johan Commelin (Sep 12 2018 at 20:39)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835504):
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Do you have an idea for an "interleaving UI"?</p>

#### [ Johan Commelin (Sep 12 2018 at 20:39)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835523):
<p>syntax, I mean</p>

#### [ Johan Commelin (Sep 12 2018 at 20:39)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835532):
<p>What would you like to write?</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:39)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835541):
<p>it sounds like what <code>case</code> does, but in that case you already know what the goals are</p>

#### [ Reid Barton (Sep 12 2018 at 20:40)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835603):
<p>something like <code>case</code> in terms of syntax, yeah</p>

#### [ Johan Commelin (Sep 12 2018 at 20:40)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835610):
<p><code>have : i -&gt; ii := bla</code></p>

#### [ Mario Carneiro (Sep 12 2018 at 20:41)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835657):
<p><code>tfae</code> could take an <code>itactic</code> argument, I'm not sure if the parsing will work but then you could have one huge tactic with subblocks like:</p>
<div class="codehilite"><pre><span></span>tfae:
1 -&gt; 2 {
  ...
}
2 -&gt; 1 {
  ...
},
</pre></div>

#### [ Johan Commelin (Sep 12 2018 at 20:41)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835674):
<p>And then, somehow Lean should keep track of them. And once you think you are done, you type <code>tfae_done</code>, and it checks that your graph is SC.</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:42)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835723):
<p>in my example it's just one tactic invocation (note lack of comma)</p>

#### [ Johan Commelin (Sep 12 2018 at 20:42)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835740):
<p>I see. And inside the <code>{ ... }</code> you would be in regular tactic mode?</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:42)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835743):
<p>yes</p>

#### [ Johan Commelin (Sep 12 2018 at 20:42)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835752):
<p>Then I think that syntax is really cool!</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:43)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835762):
<p>I don't know if I can make it work though</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:43)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835777):
<p><code>itactic</code> isn't a parser</p>

#### [ Johan Commelin (Sep 12 2018 at 20:43)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835780):
<p>I know that I can't</p>

#### [ Johan Commelin (Sep 12 2018 at 20:43)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835811):
<p>I think I would call the tactic <code>tfae_cases</code></p>

#### [ Mario Carneiro (Sep 12 2018 at 20:45)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835929):
<p>I would stick to my original proposal though, these syntaxes are crazy</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:46)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835982):
<p>you can put the numbers in comments if you forgot which is which</p>

#### [ Johan Commelin (Sep 12 2018 at 20:46)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133835987):
<p>Ok, too bad.</p>

#### [ Johan Commelin (Sep 12 2018 at 20:47)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836020):
<p>But, if you think it is really hard to do, then I won't even try thinking about it (-;</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:47)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836027):
<p>also you could have <code>tfae?</code> which would just print out a numbered list of the elements of the <code>tfae</code> for referral</p>

#### [ Johan Commelin (Sep 12 2018 at 20:48)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836058):
<p>It should be a hole command (-;</p>

#### [ Johan Commelin (Sep 12 2018 at 20:48)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836111):
<p>And fill out those comments!</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:48)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836117):
<p>I want more "implicit" hole commands (without the <code>{!!}</code> markers), but alas</p>

#### [ Johan Commelin (Sep 12 2018 at 20:50)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836226):
<p>Mario, could we have <code>have : tfae_case i ii := ...</code></p>

#### [ Johan Commelin (Sep 12 2018 at 20:50)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836245):
<p>and then a finishing tactic <code>tfae_done</code></p>

#### [ Reid Barton (Sep 12 2018 at 20:50)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836275):
<p>Oh, <code>have</code> is a better analogy. I would certainly be happy with <code>have_tfae 1 -&gt; 3, blah, have_tfae ..., ..., tfae_finish</code></p>

#### [ Mario Carneiro (Sep 12 2018 at 20:51)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836289):
<p>sorry, that's not well typed. The best you can do is <code>have : p1 -&gt; p2</code> and have <code>tfae_done</code> figure it out</p>

#### [ Johan Commelin (Sep 12 2018 at 20:51)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836317):
<p>But it's just notation, like before...</p>

#### [ Johan Commelin (Sep 12 2018 at 20:52)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836325):
<p>Ok, my example won't work.</p>

#### [ Johan Commelin (Sep 12 2018 at 20:52)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836366):
<p>But Reid's could, not?</p>

#### [ Reid Barton (Sep 12 2018 at 20:52)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836369):
<p>It would need to refer to the goal</p>

#### [ Reid Barton (Sep 12 2018 at 20:52)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836372):
<p>Yours I mean</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:52)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836377):
<p>Actually <code>have_tfae 1 -&gt; 3</code> might make sense: if the goal is <code>tfae [p1, ..., p5]</code> then it is just the same as <code>have : p1 -&gt; p3</code></p>

#### [ Johan Commelin (Sep 12 2018 at 20:52)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836402):
<p>Exactly. (And can we make it <code>tfae_have</code>?)</p>

#### [ Reid Barton (Sep 12 2018 at 20:53)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836445):
<p>It should also support &lt;-&gt; btw</p>

#### [ Johan Commelin (Sep 12 2018 at 20:53)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836448):
<p>So the <code>tfae_have</code> should generate a new goal, and record an edge in some graph. And then <code>tfae_finish</code> checks that the graph is SC.</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:54)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836450):
<p>naturally</p>

#### [ Johan Commelin (Sep 12 2018 at 20:54)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836501):
<p>I really like where this is going!</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:54)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836507):
<p><code>tfae_have</code> doesn't need to do anything</p>

#### [ Reid Barton (Sep 12 2018 at 20:54)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836510):
<p><code>tfae_finish</code> could almost just be <code>solve_by_elim</code> it seems</p>

#### [ Johan Commelin (Sep 12 2018 at 20:55)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836546):
<p>A smart <code>tfae_finish</code> could suggest a list of edges that still needs to be done...</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:55)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836571):
<p><code>tfae_finish</code> has to apply <code>tfae_of_cycle</code>, reduce the subproofs to implications of the given stuff, and then use the existing implications</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:56)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836620):
<p>and produce any unproven parts as subgoals</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:56)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836630):
<p>that way you can use <code>tfae</code> either forwards or backwards</p>

#### [ Johan Commelin (Sep 12 2018 at 20:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836644):
<p>What would those unproven parts look like?</p>

#### [ Johan Commelin (Sep 12 2018 at 20:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836660):
<p>Just unproven edges in the default cycle?</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836666):
<p>yes</p>

#### [ Johan Commelin (Sep 12 2018 at 20:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836684):
<p>Ok, so by default <code>tfae_finish</code> generates <code>n</code> goals.</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836737):
<p>(I would just call this one <code>tfae</code> btw)</p>

#### [ Johan Commelin (Sep 12 2018 at 20:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836752):
<p>If you want to use it both forwards and backward, that makes sense.</p>

#### [ Johan Commelin (Sep 12 2018 at 20:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836773):
<p>Semantically I don't like <code>tfae</code>, but short names are useful.</p>

#### [ Mario Carneiro (Sep 12 2018 at 20:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133836787):
<p><code>tfae</code> can still take a list of edges, and it would just add to this the list of edges that have already been <code>have</code>'d</p>

#### [ Johan Commelin (Sep 12 2018 at 21:04)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133837161):
<p>Ok, once this tactic is there, we need to make sure <code>obviously</code> in fact tackles the first nine cases of the Hensel's lemma TFAE proof.</p>

#### [ Reid Barton (Sep 12 2018 at 21:09)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133837469):
<p>tpwe = the preceding were equivalent for the finisher</p>

#### [ Cyril Cohen (Sep 13 2018 at 09:00)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133866415):
<blockquote>
<p>you can put the numbers in comments if you forgot which is which</p>
</blockquote>
<p>That's what I do</p>

#### [ Keeley Hoek (Sep 13 2018 at 11:33)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133872603):
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> is there a version of <code>chain</code> which lets me apply a function to each pair?</p>

#### [ Scott Morrison (Sep 13 2018 at 11:36)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133872777):
<p>What do you mean, <span class="user-mention" data-user-id="110111">@Keeley Hoek</span>?</p>

#### [ Keeley Hoek (Sep 13 2018 at 11:44)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133873151):
<p>id like to apply an <code>α → α → β</code> function to pairs of adjacent elements of a <code>list α</code>, and get a <code>list β</code>. It feels a bit like <code>chain</code> but not just for <code>Prop</code>s</p>

#### [ Johan Commelin (Sep 13 2018 at 19:07)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133898963):
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Are you working on this tactic? Or do you think this could be a good exercise for me trying to learn how to write tactics?</p>

#### [ Mario Carneiro (Sep 13 2018 at 19:08)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133899025):
<p>I'm not working on it right now. If you would like to try your hand at it, go ahead</p>

#### [ Mario Carneiro (Sep 13 2018 at 19:08)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/133899046):
<p><span class="user-mention" data-user-id="110111">@Keeley Hoek</span> I would suggest defining an element of <code>α × β</code> using <code>list.foldl</code></p>

#### [ Johan Commelin (Sep 26 2018 at 17:52)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/134684999):
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> <span class="user-mention" data-user-id="110026">@Simon Hudon</span> and me have worked on this a bit. There is now a PR: <a href="https://github.com/leanprover/mathlib/pull/373" target="_blank" title="https://github.com/leanprover/mathlib/pull/373">https://github.com/leanprover/mathlib/pull/373</a></p>

#### [ Johan Commelin (Oct 04 2018 at 10:33)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/135159468):
<p><span class="user-mention" data-user-id="110294">@Johannes Hölzl</span>  <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Is there anything blocking this PR? I've been hitting a couple of "the following are equivalent" lemmas recently, and I wouldn't mind using this machinery.</p>

#### [ Johannes Hölzl (Oct 04 2018 at 10:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/135159627):
<p>Looks good for me. I'm fine with merging it.</p>

#### [ Johannes Hölzl (Oct 04 2018 at 10:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/135159652):
<p>I don't know if Mario still has some concerns?</p>

#### [ Mario Carneiro (Oct 04 2018 at 15:02)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/135176877):
<p>no, I have just been busy with school. Go ahead and merge it if you have looked it over.</p>

#### [ Johannes Hölzl (Oct 04 2018 at 15:08)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/TFAE/near/135178091):
<p>okay I merged it</p>


{% endraw %}
