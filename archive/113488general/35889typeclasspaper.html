---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/35889typeclasspaper.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html">typeclass paper</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="185313688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185313688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185313688">Daniel Selsam (Jan 10 2020 at 14:25)</a>:</h4>
<p>Hello Mathlib! As many of you know, <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> and I are writing a paper about our new typeclass resolution procedure for Lean4. We have a first draft and it would be great to get feedback, particularly from people who know more about Mathlib than they do about the internals of typeclass resolution. Here is a link: <a href="https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0" target="_blank" title="https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0">https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0</a> Thanks in advance.</p>
<div class="message_inline_ref"><a href="https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0" target="_blank" title="typeclass.pdf"><img src="https://www.dropbox.com/static/images/spectrum-icons/generated/content/content-pdf-large.png"></a><div><div class="message_inline_image_title">typeclass.pdf</div><desc class="message_inline_image_desc"></desc></div></div>

<a name="185314530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185314530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185314530">Rob Lewis (Jan 10 2020 at 14:34)</a>:</h4>
<p>Do you have a submission/feedback deadline? I'd love to take a look but might not find time until next week.</p>

<a name="185314592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185314592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185314592">Daniel Selsam (Jan 10 2020 at 14:35)</a>:</h4>
<p>We are submitting to IJCAR 2020, January 23rd deadline</p>

<a name="185318515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185318515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185318515">Johan Commelin (Jan 10 2020 at 15:15)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> See <a href="https://www.math.sciences.univ-nantes.fr/~gouezel/" target="_blank" title="https://www.math.sciences.univ-nantes.fr/~gouezel/">https://www.math.sciences.univ-nantes.fr/~gouezel/</a> for how to spell <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span>'s name outside of Zulip <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>

<a name="185320293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185320293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185320293">Johan Commelin (Jan 10 2020 at 15:34)</a>:</h4>
<blockquote>
<p>Thus even though e.g. lists and multisets may usefully coerce into each other, one direction must be chosen arbitrarily for the Coe instance and the other must be sacrificed.</p>
</blockquote>
<p>How do you coerce a multiset into a list? You've lost the ordering... Do you want "multisets" and "finsets"? (Note that the generic mathematical reader won't recognize "finset", but then, they aren't your target audience anyway.)</p>

<a name="185320352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185320352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185320352">Johan Commelin (Jan 10 2020 at 15:35)</a>:</h4>
<p>Also... you talk about coercions between "bijective" types. But for example <code>multiset</code> and <code>finset</code> are not bijective. It's just that there are natural maps in both directions, but those maps are not bijections.</p>

<a name="185320490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185320490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185320490">Johan Commelin (Jan 10 2020 at 15:36)</a>:</h4>
<p>Minor comment:</p>
<blockquote>
<p>allows reducing the scalars in a module</p>
</blockquote>
<p>It's <em>restricting</em> scalars, not "reducing"</p>

<a name="185321363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185321363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185321363">Johan Commelin (Jan 10 2020 at 15:45)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Is this new typeclass resolution procedure implemented in Lean4 or in C++?</p>

<a name="185321667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185321667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185321667">Daniel Selsam (Jan 10 2020 at 15:49)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> Is this new typeclass resolution procedure implemented in Lean4 or in C++?</p>
</blockquote>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> in Lean4: <a href="https://github.com/leanprover/lean4/blob/master/src/Init/Lean/Meta/SynthInstance.lean" target="_blank" title="https://github.com/leanprover/lean4/blob/master/src/Init/Lean/Meta/SynthInstance.lean">https://github.com/leanprover/lean4/blob/master/src/Init/Lean/Meta/SynthInstance.lean</a></p>

<a name="185321716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185321716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185321716">Johan Commelin (Jan 10 2020 at 15:49)</a>:</h4>
<p>Ok, cool!</p>

<a name="185321840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185321840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185321840">Johan Commelin (Jan 10 2020 at 15:51)</a>:</h4>
<p>Is there a way to deal with diamonds that prop-eq but not def-eq?</p>

<a name="185322040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322040">Johan Commelin (Jan 10 2020 at 15:53)</a>:</h4>
<p>For example, Chris mentioned the other day that we'll get two <code>algebra ℚ ℂ</code> instances. But we know that <code>algebra ℚ K</code> is a subsingleton, so they must be prop-eq.</p>

<a name="185322170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322170">Daniel Selsam (Jan 10 2020 at 15:54)</a>:</h4>
<p>What do you mean by "deal with"? What are you afraid will happen, and what do you want to happen?</p>

<a name="185322179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322179" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322179">Johan Commelin (Jan 10 2020 at 15:54)</a>:</h4>
<p>But maybe this is not something that the typeclass resolution should deal with, but another part of the system.</p>

<a name="185322321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322321">Johan Commelin (Jan 10 2020 at 15:55)</a>:</h4>
<p>I might claim that <code>algebra_map x = algebra_map x</code>, but both sides might find different instances (especially if the expressions are a bit more complicated and not syntactically equal).</p>

<a name="185322386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322386">Johan Commelin (Jan 10 2020 at 15:56)</a>:</h4>
<p>And so Lean will refuse, because the <code>algebra_map</code>s come from different instances.</p>

<a name="185322425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322425">Johan Commelin (Jan 10 2020 at 15:56)</a>:</h4>
<p>But since those instances are prop-eq, we are a silly rw away from moving forward.</p>

<a name="185322480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322480">Johan Commelin (Jan 10 2020 at 15:57)</a>:</h4>
<p>But I realize now that this is not a problem that you hit during tc resolution, but during type checking</p>

<a name="185322562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322562">Johan Commelin (Jan 10 2020 at 15:58)</a>:</h4>
<p>So I guess it's a bit off topic in this thread.</p>

<a name="185322677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322677">Johan Commelin (Jan 10 2020 at 15:59)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Section 5.3 ends with a parenthetical remark (that is not properly</p>

<a name="185322808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322808">Daniel Selsam (Jan 10 2020 at 16:00)</a>:</h4>
<p>I have been pushing frequent fixes, including the 5.3 issue. Please reload the page.</p>

<a name="185322908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322908" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322908">Daniel Selsam (Jan 10 2020 at 16:01)</a>:</h4>
<p>If 5.3 still trails off for you after reloading, you may need to click some kind of "jump to most recent version of paper" button.</p>

<a name="185323900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185323900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185323900">Daniel Selsam (Jan 10 2020 at 16:11)</a>:</h4>
<blockquote>
<p>But I realize now that this is not a problem that you hit during tc resolution, but during type checking</p>
</blockquote>
<p>This example is outside the scope of tc resolution, since presumably the two calls to tc are independent. There is a related issue we have discussed about TC though: whether to consider a second solution to the same (sub)goal to be a repeat (and so discard it) if it has the same type as the first solution, even if it is not definitionally equal to the first solution.</p>

<a name="185324025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324025">Daniel Selsam (Jan 10 2020 at 16:12)</a>:</h4>
<p>Our current plan is to say that typeclasses are "morally canonical", and consider a solution (to a subgoal) to be a repeat if it has the same type as a previous solution.</p>

<a name="185324260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324260">Daniel Selsam (Jan 10 2020 at 16:14)</a>:</h4>
<p>The "morally canonical" assumption would be violated by <code>Algebra</code>, and some downstream goals may succeed or fail depending on which specific instance to <code>Algebra</code> is found first.</p>

<a name="185324441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324441">Johan Commelin (Jan 10 2020 at 16:16)</a>:</h4>
<p>Aah, it might be that it still pops up here...</p>

<a name="185324471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324471">Johan Commelin (Jan 10 2020 at 16:16)</a>:</h4>
<p>Note that in general <code>Algebra R A</code> is not a subsingleton... but if <code>R</code> is <code>\Z</code> or <code>\Q</code>, then it is...</p>

<a name="185324520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324520">Daniel Selsam (Jan 10 2020 at 16:17)</a>:</h4>
<p>Edited my comment -- the assumption is violated whether or not Algebra is a subsingleton.</p>

<a name="185324863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324863">Johan Commelin (Jan 10 2020 at 16:20)</a>:</h4>
<p>By transitivity <code>algebra R A</code> and <code>f</code> will give me another instance of <code>algebra R B</code>, and by some property field of <code>alg_hom</code> we know that <code>f</code> ensures it is prop-eq to the existing instance of <code>algebra R B</code>.<br>
Mathematicians treat these instances as def-eq all the time.</p>

<a name="185324875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324875">Johan Commelin (Jan 10 2020 at 16:20)</a>:</h4>
<p>Or if <code>R</code> is any field</p>

<a name="185324877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324877">Johan Commelin (Jan 10 2020 at 16:21)</a>:</h4>
<p>Suppose we have <code>algebra R A</code>, <code>algebra R B</code> and <code>f : alg_hom[R] A B</code> in the context.</p>

<a name="185324902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324902">Johan Commelin (Jan 10 2020 at 16:21)</a>:</h4>
<p>Oops... messages are mangled up by German telecom</p>

<a name="185325802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185325802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185325802">Daniel Selsam (Jan 10 2020 at 16:29)</a>:</h4>
<p>Can you come up with an example where typeclass resolution will succeed or fail depending on which of two different instances with the same type are discovered first for some subgoal?</p>

<a name="185326046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185326046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185326046">Daniel Selsam (Jan 10 2020 at 16:31)</a>:</h4>
<p>How about I try to come up with a toy example first to make the issue clear, and then you can try to come up with a real example that would exhibit the same problem.</p>

<a name="185328210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185328210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185328210">Chris Hughes (Jan 10 2020 at 16:51)</a>:</h4>
<p>I don't think typeclass inference fails in these situations, the problem tends to be that it infers two different instances in different situations, so terms that look the same, and are in fact equal aren't definitionally equal, so <code>exact</code> doesn't work when it looks like it should.</p>

<a name="185328504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185328504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185328504">Daniel Selsam (Jan 10 2020 at 16:54)</a>:</h4>
<p>Very artificial example but just to give intuition:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">Foo</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span>
<span class="n">class</span> <span class="n">Bar</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="o">())</span>
<span class="n">class</span> <span class="n">Rig</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="o">())</span>

<span class="kn">instance</span> <span class="n">FooToBar</span> <span class="o">[</span><span class="n">f</span><span class="o">:</span><span class="n">Foo</span><span class="o">]</span> <span class="o">:</span> <span class="n">Bar</span> <span class="n">f</span><span class="bp">.</span><span class="n">b</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="kn">instance</span> <span class="n">BarToRig</span> <span class="o">[</span><span class="n">Bar</span> <span class="n">true</span><span class="o">]</span> <span class="o">:</span> <span class="n">Rig</span> <span class="o">:=</span> <span class="o">{}</span>

<span class="kn">instance</span> <span class="n">FooTrue</span>  <span class="o">:</span> <span class="n">Foo</span> <span class="o">:=</span> <span class="o">{</span><span class="n">b</span> <span class="o">:=</span> <span class="n">true</span><span class="o">}</span>
<span class="kn">instance</span> <span class="n">FooFalse</span> <span class="o">:</span> <span class="n">Foo</span> <span class="o">:=</span> <span class="o">{</span><span class="n">b</span> <span class="o">:=</span> <span class="n">false</span><span class="o">}</span>

<span class="c1">-- There are two instances to Foo with different values.</span>
<span class="c1">-- Since they have the same type, the second one found is discarded.</span>
<span class="c1">-- The overall query succeeds only if the first one found happens to be `FooTrue`.</span>

<span class="n">def</span> <span class="n">synthRig</span> <span class="o">[</span><span class="n">Rig</span><span class="o">]</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="o">()</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">synthRig</span>
</pre></div>

<a name="185328736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185328736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185328736">Daniel Selsam (Jan 10 2020 at 16:56)</a>:</h4>
<blockquote>
<p>I don't think typeclass inference fails in these situations, the problem tends to be that it infers two different instances in different situations, so terms that look the same, and are in fact equal aren't definitionally equal, so <code>exact</code> doesn't work when it looks like it should.</p>
</blockquote>
<p>I agree with <span class="user-mention" data-user-id="112680">@Johan Commelin</span> that the issue you are describing is probably better addressed after the fact, outside of typeclass resolution. Note that Lean3 had a subsingleton-canonicalizer which would address this problem.</p>

<a name="185329385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185329385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185329385">Chris Hughes (Jan 10 2020 at 17:04)</a>:</h4>
<p>Here's an example that comes up in practice</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">constant</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">fintype</span>

<span class="n">def</span> <span class="n">card</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">constant</span> <span class="n">fintype_range</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">fintype</span> <span class="err">↥</span><span class="n">p</span>

<span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">fintype_range</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">lemma</span> <span class="n">subset_lemma</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">card</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">card</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">card</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">card</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">f</span><span class="o">):=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">subset_lemma</span><span class="o">],</span> <span class="c1">--fails</span>
<span class="kn">end</span>
</pre></div>

<a name="185345362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185345362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185345362">Daniel Selsam (Jan 10 2020 at 19:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> Thanks. I don't think this is an issue with typeclass resolution though. Higher-level tactics can be made to hide this kind of complication, similar to the way <code>simp</code> does.</p>

<a name="185362526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185362526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185362526">Tim Daly (Jan 10 2020 at 23:51)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Note that the Diamond problem has been around a while. Symbolics Common Lisp solved this using the "Mixin" idea (<a href="https://en.wikipedia.org/wiki/Mixin" target="_blank" title="https://en.wikipedia.org/wiki/Mixin">https://en.wikipedia.org/wiki/Mixin</a>) in its Flavors implementation. Common Lisp Object System (CLOS) has rules (<a href="http://www.lambdafaq.org/how-are-conflicting-method-declarations-resolved" target="_blank" title="http://www.lambdafaq.org/how-are-conflicting-method-declarations-resolved">http://www.lambdafaq.org/how-are-conflicting-method-declarations-resolved</a>).</p>

<a name="185370110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185370110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185370110">Tim Daly (Jan 11 2020 at 02:42)</a>:</h4>
<p>Also note that CLOS checks class precedence to check for the cycle problem.</p>

<a name="185375312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185375312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185375312">Johan Commelin (Jan 11 2020 at 05:23)</a>:</h4>
<p><span class="user-mention" data-user-id="223495">@Tim Daly</span> Is there any reason to think that diamonds in those systems can be dealt with in the same way as diamonds in the algebraic hierarchy of an interactive theorem prover? Intuitively it feels to me like they might need different solutions.</p>

<a name="185378278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185378278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185378278">Tim Daly (Jan 11 2020 at 07:06)</a>:</h4>
<p>Axiom struggled with similar problems. Here is an abbreviated form of Axiom's typeclasses: <a href="https://github.com/daly/PDFS/blob/master/endpaper.pdf" target="_blank" title="https://github.com/daly/PDFS/blob/master/endpaper.pdf">https://github.com/daly/PDFS/blob/master/endpaper.pdf</a> and the full form (with typeclass abbreviated names): <a href="http://axiom-developer.org/axiom-website/bookvol10.2abb.html" target="_blank" title="http://axiom-developer.org/axiom-website/bookvol10.2abb.html">http://axiom-developer.org/axiom-website/bookvol10.2abb.html</a></p>

<a name="185378404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185378404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185378404">Tim Daly (Jan 11 2020 at 07:10)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> If you have a function with the same name and same signature but different semantics available on two different paths there are various schemes to resolve them. Axiom knows that a function FOO on the path from typeclass X can be different from FOO on the path from typeclass Y. The compiler will complain. But you can be explicit FOO$X or FOO$Y where the $ operator explicitly says "use this typeclass"</p>

<a name="185378732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185378732" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185378732">Johan Commelin (Jan 11 2020 at 07:22)</a>:</h4>
<p>How is that remark relevant  to my reply to your remark about how lisp flavours solved the diamond problem?</p>

<a name="185380831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185380831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185380831">Tim Daly (Jan 11 2020 at 08:37)</a>:</h4>
<p>Sorry, I thought the referenced Wikipedia article covered that question. Flavors was merged into the Common Lisp standard as the Common Lisp Object System (CLOS) </p>
<p>"CLOS allows multiple inheritance. When the default order in which methods are executed in multiple inheritance is not correct, the programmer may resolve the diamond inheritance problems by specifying the order of method combinations".</p>
<p>"CLOS attempts to provide both reasonable default behavior and the ability to override it... by giving a specific method resolution order or stating a rule for combining methods. This is called 'method combination', which may be fully controlled. The MOP (metaobject protocol) also provides means to modify the inheritance, dynamic dispatch, class instantiation, and other internal mechanisms without affecting the stability of the system."</p>
<p>Essentially the CLOS programmer can specify their own method of solving the diamond problem by writing 'method combinators'. So you can override the system-provided version in a specific case if you need to. This was derived from the Symbolics Flavors system.</p>

<a name="185380934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185380934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185380934">Tim Daly (Jan 11 2020 at 08:40)</a>:</h4>
<p>See <a href="http://www.bracha.org/oopsla90.pdf" target="_blank" title="http://www.bracha.org/oopsla90.pdf">http://www.bracha.org/oopsla90.pdf</a> ... Mixin-based Inheritance</p>

<a name="185381102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381102">Tim Daly (Jan 11 2020 at 08:47)</a>:</h4>
<p>Axiom's approach is "Well, you've got two functions from different paths with the same signature. That's fine but you have to tell me which one you mean when you decide to use it."</p>

<a name="185381157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381157">Tim Daly (Jan 11 2020 at 08:49)</a>:</h4>
<p>If Lean were implemented in Common Lisp it would be much easier to resolve certain problems. (Disclosure: I'm a lisper, in case that isn't obvious)</p>

<a name="185381219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381219">Tim Daly (Jan 11 2020 at 08:51)</a>:</h4>
<p>Lean could adopt the approach of specifying not only the name of the function but, if there are duplicates, also specifying the particular typeclass (otherwise complain).</p>

<a name="185381893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381893">Johan Commelin (Jan 11 2020 at 09:15)</a>:</h4>
<blockquote>
<p>If Lean were implemented in Common Lisp it would be much easier to resolve certain problems. (Disclosure: I'm a lisper, in case that isn't obvious)</p>
</blockquote>
<p>Too bad (for you) that most of Lean4 is implemented in Lean4...</p>

<a name="185381898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381898">Johan Commelin (Jan 11 2020 at 09:16)</a>:</h4>
<p>In Lean it is always possible to explicitly provide the type class. So I think all of the things you've described are already available. The point is (mostly) that we want things to be fast.</p>

<a name="185381942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381942">Johan Commelin (Jan 11 2020 at 09:16)</a>:</h4>
<p>My remark was that mathlib's diamonds are probably the same kind as those in Lisp, but considerably more complex.</p>

<a name="185382597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185382597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185382597">Tim Daly (Jan 11 2020 at 09:38)</a>:</h4>
<p>Actually, that's a huge win. I'm looking forward to seeing the implementation.</p>


{% endraw %}

{% include archive_update.html %}