---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/35889typeclasspaper.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html">typeclass paper</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="185313688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185313688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185313688">Daniel Selsam (Jan 10 2020 at 14:25)</a>:</h4>
<p>Hello Mathlib! As many of you know, <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> <span class="user-mention" data-user-id="112857">@Leonardo de Moura</span> and I are writing a paper about our new typeclass resolution procedure for Lean4. We have a first draft and it would be great to get feedback, particularly from people who know more about Mathlib than they do about the internals of typeclass resolution. Here is a link: <a href="https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0" target="_blank" title="https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0">https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0</a> Thanks in advance.</p>
<div class="message_inline_ref"><a href="https://www.dropbox.com/s/5nxklkxvdh7xna9/typeclass.pdf?dl=0" target="_blank" title="typeclass.pdf"><img src="https://www.dropbox.com/static/images/spectrum-icons/generated/content/content-pdf-large.png"></a><div><div class="message_inline_image_title">typeclass.pdf</div><desc class="message_inline_image_desc"></desc></div></div>

<a name="185314530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185314530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185314530">Rob Lewis (Jan 10 2020 at 14:34)</a>:</h4>
<p>Do you have a submission/feedback deadline? I'd love to take a look but might not find time until next week.</p>

<a name="185314592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185314592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185314592">Daniel Selsam (Jan 10 2020 at 14:35)</a>:</h4>
<p>We are submitting to IJCAR 2020, January 23rd deadline</p>

<a name="185318515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185318515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185318515">Johan Commelin (Jan 10 2020 at 15:15)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> See <a href="https://www.math.sciences.univ-nantes.fr/~gouezel/" target="_blank" title="https://www.math.sciences.univ-nantes.fr/~gouezel/">https://www.math.sciences.univ-nantes.fr/~gouezel/</a> for how to spell <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span>'s name outside of Zulip <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>

<a name="185320293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185320293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185320293">Johan Commelin (Jan 10 2020 at 15:34)</a>:</h4>
<blockquote>
<p>Thus even though e.g. lists and multisets may usefully coerce into each other, one direction must be chosen arbitrarily for the Coe instance and the other must be sacrificed.</p>
</blockquote>
<p>How do you coerce a multiset into a list? You've lost the ordering... Do you want "multisets" and "finsets"? (Note that the generic mathematical reader won't recognize "finset", but then, they aren't your target audience anyway.)</p>

<a name="185320352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185320352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185320352">Johan Commelin (Jan 10 2020 at 15:35)</a>:</h4>
<p>Also... you talk about coercions between "bijective" types. But for example <code>multiset</code> and <code>finset</code> are not bijective. It's just that there are natural maps in both directions, but those maps are not bijections.</p>

<a name="185320490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185320490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185320490">Johan Commelin (Jan 10 2020 at 15:36)</a>:</h4>
<p>Minor comment:</p>
<blockquote>
<p>allows reducing the scalars in a module</p>
</blockquote>
<p>It's <em>restricting</em> scalars, not "reducing"</p>

<a name="185321363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185321363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185321363">Johan Commelin (Jan 10 2020 at 15:45)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Is this new typeclass resolution procedure implemented in Lean4 or in C++?</p>

<a name="185321667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185321667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185321667">Daniel Selsam (Jan 10 2020 at 15:49)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="230999">Daniel Selsam</span> Is this new typeclass resolution procedure implemented in Lean4 or in C++?</p>
</blockquote>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> in Lean4: <a href="https://github.com/leanprover/lean4/blob/master/src/Init/Lean/Meta/SynthInstance.lean" target="_blank" title="https://github.com/leanprover/lean4/blob/master/src/Init/Lean/Meta/SynthInstance.lean">https://github.com/leanprover/lean4/blob/master/src/Init/Lean/Meta/SynthInstance.lean</a></p>

<a name="185321716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185321716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185321716">Johan Commelin (Jan 10 2020 at 15:49)</a>:</h4>
<p>Ok, cool!</p>

<a name="185321840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185321840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185321840">Johan Commelin (Jan 10 2020 at 15:51)</a>:</h4>
<p>Is there a way to deal with diamonds that prop-eq but not def-eq?</p>

<a name="185322040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322040">Johan Commelin (Jan 10 2020 at 15:53)</a>:</h4>
<p>For example, Chris mentioned the other day that we'll get two <code>algebra ℚ ℂ</code> instances. But we know that <code>algebra ℚ K</code> is a subsingleton, so they must be prop-eq.</p>

<a name="185322170"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322170" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322170">Daniel Selsam (Jan 10 2020 at 15:54)</a>:</h4>
<p>What do you mean by "deal with"? What are you afraid will happen, and what do you want to happen?</p>

<a name="185322179"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322179" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322179">Johan Commelin (Jan 10 2020 at 15:54)</a>:</h4>
<p>But maybe this is not something that the typeclass resolution should deal with, but another part of the system.</p>

<a name="185322321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322321">Johan Commelin (Jan 10 2020 at 15:55)</a>:</h4>
<p>I might claim that <code>algebra_map x = algebra_map x</code>, but both sides might find different instances (especially if the expressions are a bit more complicated and not syntactically equal).</p>

<a name="185322386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322386">Johan Commelin (Jan 10 2020 at 15:56)</a>:</h4>
<p>And so Lean will refuse, because the <code>algebra_map</code>s come from different instances.</p>

<a name="185322425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322425">Johan Commelin (Jan 10 2020 at 15:56)</a>:</h4>
<p>But since those instances are prop-eq, we are a silly rw away from moving forward.</p>

<a name="185322480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322480">Johan Commelin (Jan 10 2020 at 15:57)</a>:</h4>
<p>But I realize now that this is not a problem that you hit during tc resolution, but during type checking</p>

<a name="185322562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322562">Johan Commelin (Jan 10 2020 at 15:58)</a>:</h4>
<p>So I guess it's a bit off topic in this thread.</p>

<a name="185322677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322677">Johan Commelin (Jan 10 2020 at 15:59)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Section 5.3 ends with a parenthetical remark (that is not properly</p>

<a name="185322808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322808">Daniel Selsam (Jan 10 2020 at 16:00)</a>:</h4>
<p>I have been pushing frequent fixes, including the 5.3 issue. Please reload the page.</p>

<a name="185322908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185322908" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185322908">Daniel Selsam (Jan 10 2020 at 16:01)</a>:</h4>
<p>If 5.3 still trails off for you after reloading, you may need to click some kind of "jump to most recent version of paper" button.</p>

<a name="185323900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185323900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185323900">Daniel Selsam (Jan 10 2020 at 16:11)</a>:</h4>
<blockquote>
<p>But I realize now that this is not a problem that you hit during tc resolution, but during type checking</p>
</blockquote>
<p>This example is outside the scope of tc resolution, since presumably the two calls to tc are independent. There is a related issue we have discussed about TC though: whether to consider a second solution to the same (sub)goal to be a repeat (and so discard it) if it has the same type as the first solution, even if it is not definitionally equal to the first solution.</p>

<a name="185324025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324025">Daniel Selsam (Jan 10 2020 at 16:12)</a>:</h4>
<p>Our current plan is to say that typeclasses are "morally canonical", and consider a solution (to a subgoal) to be a repeat if it has the same type as a previous solution.</p>

<a name="185324260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324260">Daniel Selsam (Jan 10 2020 at 16:14)</a>:</h4>
<p>The "morally canonical" assumption would be violated by <code>Algebra</code>, and some downstream goals may succeed or fail depending on which specific instance to <code>Algebra</code> is found first.</p>

<a name="185324441"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324441" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324441">Johan Commelin (Jan 10 2020 at 16:16)</a>:</h4>
<p>Aah, it might be that it still pops up here...</p>

<a name="185324471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324471">Johan Commelin (Jan 10 2020 at 16:16)</a>:</h4>
<p>Note that in general <code>Algebra R A</code> is not a subsingleton... but if <code>R</code> is <code>\Z</code> or <code>\Q</code>, then it is...</p>

<a name="185324520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324520">Daniel Selsam (Jan 10 2020 at 16:17)</a>:</h4>
<p>Edited my comment -- the assumption is violated whether or not Algebra is a subsingleton.</p>

<a name="185324863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324863">Johan Commelin (Jan 10 2020 at 16:20)</a>:</h4>
<p>By transitivity <code>algebra R A</code> and <code>f</code> will give me another instance of <code>algebra R B</code>, and by some property field of <code>alg_hom</code> we know that <code>f</code> ensures it is prop-eq to the existing instance of <code>algebra R B</code>.<br>
Mathematicians treat these instances as def-eq all the time.</p>

<a name="185324875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324875">Johan Commelin (Jan 10 2020 at 16:20)</a>:</h4>
<p>Or if <code>R</code> is any field</p>

<a name="185324877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324877">Johan Commelin (Jan 10 2020 at 16:21)</a>:</h4>
<p>Suppose we have <code>algebra R A</code>, <code>algebra R B</code> and <code>f : alg_hom[R] A B</code> in the context.</p>

<a name="185324902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185324902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185324902">Johan Commelin (Jan 10 2020 at 16:21)</a>:</h4>
<p>Oops... messages are mangled up by German telecom</p>

<a name="185325802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185325802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185325802">Daniel Selsam (Jan 10 2020 at 16:29)</a>:</h4>
<p>Can you come up with an example where typeclass resolution will succeed or fail depending on which of two different instances with the same type are discovered first for some subgoal?</p>

<a name="185326046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185326046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185326046">Daniel Selsam (Jan 10 2020 at 16:31)</a>:</h4>
<p>How about I try to come up with a toy example first to make the issue clear, and then you can try to come up with a real example that would exhibit the same problem.</p>

<a name="185328210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185328210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185328210">Chris Hughes (Jan 10 2020 at 16:51)</a>:</h4>
<p>I don't think typeclass inference fails in these situations, the problem tends to be that it infers two different instances in different situations, so terms that look the same, and are in fact equal aren't definitionally equal, so <code>exact</code> doesn't work when it looks like it should.</p>

<a name="185328504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185328504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185328504">Daniel Selsam (Jan 10 2020 at 16:54)</a>:</h4>
<p>Very artificial example but just to give intuition:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">Foo</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span>
<span class="n">class</span> <span class="n">Bar</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="o">())</span>
<span class="n">class</span> <span class="n">Rig</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="o">())</span>

<span class="kn">instance</span> <span class="n">FooToBar</span> <span class="o">[</span><span class="n">f</span><span class="o">:</span><span class="n">Foo</span><span class="o">]</span> <span class="o">:</span> <span class="n">Bar</span> <span class="n">f</span><span class="bp">.</span><span class="n">b</span> <span class="o">:=</span> <span class="o">{}</span>
<span class="kn">instance</span> <span class="n">BarToRig</span> <span class="o">[</span><span class="n">Bar</span> <span class="n">true</span><span class="o">]</span> <span class="o">:</span> <span class="n">Rig</span> <span class="o">:=</span> <span class="o">{}</span>

<span class="kn">instance</span> <span class="n">FooTrue</span>  <span class="o">:</span> <span class="n">Foo</span> <span class="o">:=</span> <span class="o">{</span><span class="n">b</span> <span class="o">:=</span> <span class="n">true</span><span class="o">}</span>
<span class="kn">instance</span> <span class="n">FooFalse</span> <span class="o">:</span> <span class="n">Foo</span> <span class="o">:=</span> <span class="o">{</span><span class="n">b</span> <span class="o">:=</span> <span class="n">false</span><span class="o">}</span>

<span class="c1">-- There are two instances to Foo with different values.</span>
<span class="c1">-- Since they have the same type, the second one found is discarded.</span>
<span class="c1">-- The overall query succeeds only if the first one found happens to be `FooTrue`.</span>

<span class="n">def</span> <span class="n">synthRig</span> <span class="o">[</span><span class="n">Rig</span><span class="o">]</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="o">()</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">Unit</span> <span class="o">:=</span> <span class="n">synthRig</span>
</pre></div>

<a name="185328736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185328736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185328736">Daniel Selsam (Jan 10 2020 at 16:56)</a>:</h4>
<blockquote>
<p>I don't think typeclass inference fails in these situations, the problem tends to be that it infers two different instances in different situations, so terms that look the same, and are in fact equal aren't definitionally equal, so <code>exact</code> doesn't work when it looks like it should.</p>
</blockquote>
<p>I agree with <span class="user-mention" data-user-id="112680">@Johan Commelin</span> that the issue you are describing is probably better addressed after the fact, outside of typeclass resolution. Note that Lean3 had a subsingleton-canonicalizer which would address this problem.</p>

<a name="185329385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185329385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185329385">Chris Hughes (Jan 10 2020 at 17:04)</a>:</h4>
<p>Here's an example that comes up in practice</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">constant</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="n">attribute</span> <span class="o">[</span><span class="n">class</span><span class="o">]</span> <span class="n">fintype</span>

<span class="n">def</span> <span class="n">card</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">constant</span> <span class="n">fintype_range</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">fintype</span> <span class="err">↥</span><span class="n">p</span>

<span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">fintype_range</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">fintype</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">lemma</span> <span class="n">subset_lemma</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">card</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">card</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">fintype</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">card</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">card</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="n">f</span><span class="o">):=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">subset_lemma</span><span class="o">],</span> <span class="c1">--fails</span>
<span class="kn">end</span>
</pre></div>

<a name="185345362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185345362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185345362">Daniel Selsam (Jan 10 2020 at 19:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> Thanks. I don't think this is an issue with typeclass resolution though. Higher-level tactics can be made to hide this kind of complication, similar to the way <code>simp</code> does.</p>

<a name="185362526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185362526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185362526">Tim Daly (Jan 10 2020 at 23:51)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Note that the Diamond problem has been around a while. Symbolics Common Lisp solved this using the "Mixin" idea (<a href="https://en.wikipedia.org/wiki/Mixin" target="_blank" title="https://en.wikipedia.org/wiki/Mixin">https://en.wikipedia.org/wiki/Mixin</a>) in its Flavors implementation. Common Lisp Object System (CLOS) has rules (<a href="http://www.lambdafaq.org/how-are-conflicting-method-declarations-resolved" target="_blank" title="http://www.lambdafaq.org/how-are-conflicting-method-declarations-resolved">http://www.lambdafaq.org/how-are-conflicting-method-declarations-resolved</a>).</p>

<a name="185370110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185370110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185370110">Tim Daly (Jan 11 2020 at 02:42)</a>:</h4>
<p>Also note that CLOS checks class precedence to check for the cycle problem.</p>

<a name="185375312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185375312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185375312">Johan Commelin (Jan 11 2020 at 05:23)</a>:</h4>
<p><span class="user-mention" data-user-id="223495">@Tim Daly</span> Is there any reason to think that diamonds in those systems can be dealt with in the same way as diamonds in the algebraic hierarchy of an interactive theorem prover? Intuitively it feels to me like they might need different solutions.</p>

<a name="185378278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185378278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185378278">Tim Daly (Jan 11 2020 at 07:06)</a>:</h4>
<p>Axiom struggled with similar problems. Here is an abbreviated form of Axiom's typeclasses: <a href="https://github.com/daly/PDFS/blob/master/endpaper.pdf" target="_blank" title="https://github.com/daly/PDFS/blob/master/endpaper.pdf">https://github.com/daly/PDFS/blob/master/endpaper.pdf</a> and the full form (with typeclass abbreviated names): <a href="http://axiom-developer.org/axiom-website/bookvol10.2abb.html" target="_blank" title="http://axiom-developer.org/axiom-website/bookvol10.2abb.html">http://axiom-developer.org/axiom-website/bookvol10.2abb.html</a></p>

<a name="185378404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185378404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185378404">Tim Daly (Jan 11 2020 at 07:10)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> If you have a function with the same name and same signature but different semantics available on two different paths there are various schemes to resolve them. Axiom knows that a function FOO on the path from typeclass X can be different from FOO on the path from typeclass Y. The compiler will complain. But you can be explicit FOO$X or FOO$Y where the $ operator explicitly says "use this typeclass"</p>

<a name="185378732"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185378732" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185378732">Johan Commelin (Jan 11 2020 at 07:22)</a>:</h4>
<p>How is that remark relevant  to my reply to your remark about how lisp flavours solved the diamond problem?</p>

<a name="185380831"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185380831" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185380831">Tim Daly (Jan 11 2020 at 08:37)</a>:</h4>
<p>Sorry, I thought the referenced Wikipedia article covered that question. Flavors was merged into the Common Lisp standard as the Common Lisp Object System (CLOS) </p>
<p>"CLOS allows multiple inheritance. When the default order in which methods are executed in multiple inheritance is not correct, the programmer may resolve the diamond inheritance problems by specifying the order of method combinations".</p>
<p>"CLOS attempts to provide both reasonable default behavior and the ability to override it... by giving a specific method resolution order or stating a rule for combining methods. This is called 'method combination', which may be fully controlled. The MOP (metaobject protocol) also provides means to modify the inheritance, dynamic dispatch, class instantiation, and other internal mechanisms without affecting the stability of the system."</p>
<p>Essentially the CLOS programmer can specify their own method of solving the diamond problem by writing 'method combinators'. So you can override the system-provided version in a specific case if you need to. This was derived from the Symbolics Flavors system.</p>

<a name="185380934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185380934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185380934">Tim Daly (Jan 11 2020 at 08:40)</a>:</h4>
<p>See <a href="http://www.bracha.org/oopsla90.pdf" target="_blank" title="http://www.bracha.org/oopsla90.pdf">http://www.bracha.org/oopsla90.pdf</a> ... Mixin-based Inheritance</p>

<a name="185381102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381102">Tim Daly (Jan 11 2020 at 08:47)</a>:</h4>
<p>Axiom's approach is "Well, you've got two functions from different paths with the same signature. That's fine but you have to tell me which one you mean when you decide to use it."</p>

<a name="185381157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381157">Tim Daly (Jan 11 2020 at 08:49)</a>:</h4>
<p>If Lean were implemented in Common Lisp it would be much easier to resolve certain problems. (Disclosure: I'm a lisper, in case that isn't obvious)</p>

<a name="185381219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381219">Tim Daly (Jan 11 2020 at 08:51)</a>:</h4>
<p>Lean could adopt the approach of specifying not only the name of the function but, if there are duplicates, also specifying the particular typeclass (otherwise complain).</p>

<a name="185381893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381893">Johan Commelin (Jan 11 2020 at 09:15)</a>:</h4>
<blockquote>
<p>If Lean were implemented in Common Lisp it would be much easier to resolve certain problems. (Disclosure: I'm a lisper, in case that isn't obvious)</p>
</blockquote>
<p>Too bad (for you) that most of Lean4 is implemented in Lean4...</p>

<a name="185381898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381898">Johan Commelin (Jan 11 2020 at 09:16)</a>:</h4>
<p>In Lean it is always possible to explicitly provide the type class. So I think all of the things you've described are already available. The point is (mostly) that we want things to be fast.</p>

<a name="185381942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185381942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185381942">Johan Commelin (Jan 11 2020 at 09:16)</a>:</h4>
<p>My remark was that mathlib's diamonds are probably the same kind as those in Lisp, but considerably more complex.</p>

<a name="185382597"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185382597" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185382597">Tim Daly (Jan 11 2020 at 09:38)</a>:</h4>
<p>Actually, that's a huge win. I'm looking forward to seeing the implementation.</p>

<a name="185389661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185389661" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185389661">Daniel Selsam (Jan 11 2020 at 13:22)</a>:</h4>
<p><span class="user-mention" data-user-id="223495">@Tim Daly</span> Thanks for sharing the links. We seem to be using the phrase <em>diamond problem</em> to mean slightly different things.  In Lean, in the common case, all the different paths through the diamond towers lead to the same implementation.  So, deciding among alternative implementations is not the main challenge. The problem is that towers of diamonds in the instance graph induce an exponential number of paths, and without care, certain queries will spend exponential time traversing these paths. The diamond problem for us is purely a performance problem.</p>

<a name="185390666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185390666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185390666">Tim Daly (Jan 11 2020 at 13:52)</a>:</h4>
<p>The term 'diamond problem' has a long history. You might want to be very clear up front to distinguish your problem from the other uses of the term.</p>

<a name="185390808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185390808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185390808">Tim Daly (Jan 11 2020 at 13:57)</a>:</h4>
<p>If your problem is only that you might encounter the same object on different paths, it might help to memoize the path information so you never traverse it more than once. I will reread the paper with your new definition. I assumed more about the problem than you wrote I guess. My apology for the mistake.</p>

<a name="185391293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185391293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185391293">Jason Rute (Jan 11 2020 at 14:11)</a>:</h4>
<p>Also Rust is another language using type classes or something similar.  Is any of this a concern there?</p>

<a name="185391928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185391928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185391928">Jason Rute (Jan 11 2020 at 14:27)</a>:</h4>
<p>In Scala, <em>implicits</em> are similar to Lean's type classes. They are used  to support ad-hoc polymorphism, coercion, and true-type classes.  They also have a similar syntax to Lean.  I know they are one fo the things which makes compiling Scala so slow, particularly because of <em>implicit macros</em>, which are the Scala analogue of instances depending on other instances.  Do you know off-hand if your method can be used to speed up implicit resolution in Scala?  (Or if Scala uses a method similar to yours already?)  I know the implicit resolution in Scala has some additional concerns such as trying to resolve implicits in closer levels of scope first.  Also, I haven't checked for sure that diamonds or loops are allowed in implicit macros.  Last, I don't know for sure that the slow down in implicit search in practice is due to an exponential search tree or if it is due to the execution time of the code in the implicit macros.  Just curious if you have any thoughts on this.</p>

<a name="185391976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185391976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185391976">Jason Rute (Jan 11 2020 at 14:28)</a>:</h4>
<p>(Due to the Zulip mobile app issues, my messages got reversed.)</p>

<a name="185392639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185392639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185392639">Jason Rute (Jan 11 2020 at 14:49)</a>:</h4>
<p>Actually, I just checked with some Scala code.  Diamonds are allowed in Scala in the sense that you can write the code.  However, implicit search will fall if it finds two ways to resolve the same implicit at the same level of scope, so if the top of the diamond is inhabited, it will complain that there are two ways to match the expected type (even if they evaluate the same).  This must mean it is checking all the paths (at least until it finds two satisfied paths).  In that case, I hope it is doing something similar to your method or it could be checking an exponential number of paths.</p>

<a name="185392767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185392767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185392767">Daniel Selsam (Jan 11 2020 at 14:53)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> Thanks. I have never used Scala and know very little about it. Could you please share your diamond example?</p>

<a name="185393609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185393609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185393609">Jason Rute (Jan 11 2020 at 15:17)</a>:</h4>
<p>You can paste this into a scala REPL.</p>
<div class="codehilite"><pre><span></span><span class="c1">// The classes</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">A</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>  <span class="c1">// this like a structure type</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">B</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">C</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">D</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="c1">// the implicit macros</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">dToC</span><span class="o">(</span><span class="k">implicit</span> <span class="n">d</span><span class="k">:</span> <span class="kt">D</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="n">n</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">dToB</span><span class="o">(</span><span class="k">implicit</span> <span class="n">d</span><span class="k">:</span> <span class="kt">D</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="n">n</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">bToA</span><span class="o">(</span><span class="k">implicit</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="n">n</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">cToA</span><span class="o">(</span><span class="k">implicit</span> <span class="n">c</span><span class="k">:</span> <span class="kt">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="n">n</span><span class="o">)</span>

<span class="c1">// case 1: only one valid path.  This block will return A(42)</span>
<span class="o">{</span>  <span class="c1">// restrict scope</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
 <span class="c1">// can use implicitly to check implicit implicit resolution &quot;def implicitly[T](implicit t : T): T = T&quot;</span>
 <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// case 2: two valid paths which meet together.  This will fail.</span>
<span class="o">{</span>  <span class="c1">// restrict scope</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">d</span><span class="k">:</span> <span class="kt">D</span> <span class="o">=</span> <span class="n">D</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>   <span class="c1">// compiler will complain about &quot;ambiguous implicit values&quot;</span>
<span class="o">}</span>

<span class="c1">// case 3: two valid paths (one which extends the other). This will succeed and return A(43)</span>
<span class="o">{</span>  <span class="c1">// restrict scope</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">d</span><span class="k">:</span> <span class="kt">D</span> <span class="o">=</span> <span class="n">D</span><span class="o">(</span><span class="mi">43</span><span class="o">)</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// case 3: two valid paths not extending each other. This will fail.</span>
<span class="o">{</span>  <span class="c1">// restrict scope</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">c</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">(</span><span class="mi">43</span><span class="o">)</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>   <span class="c1">// compiler will complain about &quot;ambiguous implicit values&quot;</span>
<span class="o">}</span>
</pre></div>

<a name="185395015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185395015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185395015">Daniel Selsam (Jan 11 2020 at 15:59)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> Thank you very much. I just confirmed that it also scales exponentially on the tower of (failing) diamonds.</p>

<a name="185395083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185395083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185395083">Daniel Selsam (Jan 11 2020 at 16:00)</a>:</h4>
<p>I am not sure if it merits putting in the paper though. For all I know, their instance logic may be simple enough that relatively naive caching would address this. And I doubt it is a problem in practice for them.</p>

<a name="185395152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185395152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185395152">Daniel Selsam (Jan 11 2020 at 16:03)</a>:</h4>
<p>Haskell is the same boat. We discuss and compare against Haskell mainly due its historical significance in pioneering typeclasses. I suspect Haskell could implement a simple caching scheme, and I highly doubt it would make sense for them to implement tabled resolution.</p>

<a name="185842670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185842670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185842670">Rob Lewis (Jan 16 2020 at 18:13)</a>:</h4>
<p><span class="user-mention" data-user-id="230999">@Daniel Selsam</span> Thanks for sharing the paper, it's very nice. Very excited to use the new procedure in Lean 4. I have some minor line comments on the paper I'll send you directly, but a few more general points:</p>
<ul>
<li>
<p>One of the frustrating parts of Lean 3 type class resolution is error reporting. To some extent I think this is inherent in the algorithm, it can be hard to localize what goes wrong. I wonder if this gets better or worse with tabled resolution. Is this something you've thought about at all and is there anything worth saying in the paper? I'd be very interested to read a paragraph on this in section 5.5 if there is.</p>
</li>
<li>
<p>Both appear in the literature, but "type class" seems to be more common than "typeclass" (except maybe surrounding Coq). Any reason to prefer the latter?</p>
</li>
<li>
<p>There might not be space, but I'd be curious to see one or two more examples at the end, eg the frustrating int coe issue we had in mathlib. I don't think it fits the same pattern as the tower of diamonds. (edit - thinking harder, maybe it is essentially the same idea?)</p>
</li>
<li>
<p>Mathlib is dropped in toward the beginning without introduction. One of the reasons we wrote the mathlib paper was just for this reason, so we can cite it without describing it!</p>
</li>
</ul>

<a name="185842835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185842835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185842835">Patrick Massot (Jan 16 2020 at 18:15)</a>:</h4>
<p>Another question that Coq users keep asking whenever we mention type class resolution. Will we have <a href="https://en.wikipedia.org/wiki/Cut_(logic_programming)" target="_blank" title="https://en.wikipedia.org/wiki/Cut_(logic_programming)">cuts</a>?</p>

<a name="185846970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass%20paper/near/185846970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/35889typeclasspaper.html#185846970">Daniel Selsam (Jan 16 2020 at 18:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> To the best of my knowledge, nobody has yet brought to our attention any issue that cuts might help address, so we haven't considered it.</p>


{% endraw %}

{% include archive_update.html %}