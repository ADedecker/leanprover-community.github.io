---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/81802missingextlemmas.html
---

## Stream: [general](https://leanprover-community.github.io/archive/113488general/index.html)
### Topic: [missing ext lemmas?](https://leanprover-community.github.io/archive/113488general/81802missingextlemmas.html)

---

<base href="https://leanprover.zulipchat.com">
{% raw %}
#### [ Johan Commelin (Oct 03 2018 at 10:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135088491):
<p>How many of the following should be marked with <code>@[extensionality]</code>?</p>
<div class="codehilite"><pre><span></span><span class="n">data</span><span class="bp">/</span><span class="n">buffer</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">b₁</span> <span class="n">b₂</span> <span class="o">:</span> <span class="n">buffer</span> <span class="n">α</span><span class="o">},</span> <span class="n">to_list</span> <span class="n">b₁</span> <span class="bp">=</span> <span class="n">to_list</span> <span class="n">b₂</span> <span class="bp">→</span> <span class="n">b₁</span> <span class="bp">=</span> <span class="n">b₂</span>
<span class="n">data</span><span class="bp">/</span><span class="n">equiv</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">ext</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">finsupp</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span><span class="err">₀</span> <span class="n">β</span><span class="o">},</span> <span class="o">(</span><span class="bp">∀</span><span class="n">a</span><span class="o">,</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">a</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span>
<span class="n">data</span><span class="bp">/</span><span class="n">list</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">foldl_ext</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="n">data</span><span class="bp">/</span><span class="n">list</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">foldr_ext</span> <span class="o">(</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span>
<span class="n">data</span><span class="bp">/</span><span class="n">prod</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">ext</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">}</span> <span class="o">:</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">=</span> <span class="n">q</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">→</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">q</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">subtype</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">a1</span> <span class="n">a2</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">β</span> <span class="n">x</span><span class="o">}}</span> <span class="o">:</span> <span class="n">a1</span> <span class="bp">=</span> <span class="n">a2</span> <span class="bp">↔</span> <span class="n">a1</span><span class="bp">.</span><span class="n">val</span> <span class="bp">=</span> <span class="n">a2</span><span class="bp">.</span><span class="n">val</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">subtype</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">coe_ext</span> <span class="o">{</span><span class="n">a1</span> <span class="n">a2</span> <span class="o">:</span> <span class="o">{</span><span class="n">x</span> <span class="bp">//</span> <span class="n">β</span> <span class="n">x</span><span class="o">}}</span> <span class="o">:</span> <span class="n">a1</span> <span class="bp">=</span> <span class="n">a2</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">a1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a2</span> <span class="o">:=</span>
<span class="n">logic</span><span class="bp">/</span><span class="n">function</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">lemma</span> <span class="n">hfunext</span> <span class="o">{</span><span class="n">α</span> <span class="n">α&#39;</span><span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">β&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span> <span class="bp">→</span> <span class="n">Sort</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span><span class="n">a</span><span class="o">,</span> <span class="n">β</span> <span class="n">a</span><span class="o">}</span> <span class="o">{</span><span class="n">f&#39;</span> <span class="o">:</span> <span class="bp">Π</span><span class="n">a</span><span class="o">,</span> <span class="n">β&#39;</span> <span class="n">a</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">filter</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">protected</span> <span class="kn">lemma</span> <span class="n">ext</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">f</span><span class="bp">.</span><span class="n">sets</span> <span class="bp">↔</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">g</span><span class="bp">.</span><span class="n">sets</span><span class="o">)</span> <span class="bp">→</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="n">category</span><span class="bp">/</span><span class="n">applicative</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">applicative</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">F</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A1</span> <span class="o">:</span> <span class="n">applicative</span> <span class="n">F</span><span class="o">}</span> <span class="o">{</span><span class="n">A2</span> <span class="o">:</span> <span class="n">applicative</span> <span class="n">F</span><span class="o">}</span>
<span class="n">category</span><span class="bp">/</span><span class="n">functor</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">functor</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">F</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">F1</span> <span class="o">:</span> <span class="n">functor</span> <span class="n">F</span><span class="o">}</span> <span class="o">{</span><span class="n">F2</span> <span class="o">:</span> <span class="n">functor</span> <span class="n">F</span><span class="o">}</span>
<span class="n">data</span><span class="bp">/</span><span class="n">analysis</span><span class="bp">/</span><span class="n">topology</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">[</span><span class="n">T</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">σ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">ctop</span> <span class="n">α</span> <span class="n">σ</span><span class="o">}</span>
<span class="n">data</span><span class="bp">/</span><span class="n">complex</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">z</span> <span class="n">w</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">},</span> <span class="n">z</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">w</span><span class="bp">.</span><span class="n">re</span> <span class="bp">→</span> <span class="n">z</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">w</span><span class="bp">.</span><span class="n">im</span> <span class="bp">→</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">w</span>
<span class="n">data</span><span class="bp">/</span><span class="n">finset</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">s₁</span> <span class="n">s₂</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">s₁</span> <span class="bp">=</span> <span class="n">s₂</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s₁</span> <span class="bp">↔</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s₂</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">list</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">},</span> <span class="o">(</span><span class="bp">∀</span><span class="n">n</span><span class="o">,</span> <span class="n">nth</span> <span class="n">l₁</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">nth</span> <span class="n">l₂</span> <span class="n">n</span><span class="o">)</span> <span class="bp">→</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span>
<span class="n">data</span><span class="bp">/</span><span class="n">list</span><span class="bp">/</span><span class="n">perm</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">perm_ext</span> <span class="o">{</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">d₁</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">d₂</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">~</span> <span class="n">l₂</span> <span class="bp">↔</span> <span class="bp">∀</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">l₁</span> <span class="bp">↔</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">l₂</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">multiset</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">count</span> <span class="n">a</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">count</span> <span class="n">a</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">multiset</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">nodup_ext</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">nodup</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">nodup</span> <span class="n">t</span> <span class="bp">→</span> <span class="o">(</span><span class="n">s</span> <span class="bp">=</span> <span class="n">t</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">multiset</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">erase_dup_ext</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">multiset</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">erase_dup</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">erase_dup</span> <span class="n">t</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">↔</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">option</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">o₁</span> <span class="n">o₂</span> <span class="o">:</span> <span class="n">option</span> <span class="n">α</span><span class="o">},</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">o₁</span> <span class="bp">↔</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">o₂</span><span class="o">)</span> <span class="bp">→</span> <span class="n">o₁</span> <span class="bp">=</span> <span class="n">o₂</span>
<span class="n">data</span><span class="bp">/</span><span class="n">real</span><span class="bp">/</span><span class="n">cau_seq</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">cau_seq</span> <span class="n">β</span> <span class="n">abv</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">g</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">g</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">semiquot</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">q₁</span> <span class="n">q₂</span> <span class="o">:</span> <span class="n">semiquot</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">q₁</span> <span class="bp">=</span> <span class="n">q₂</span> <span class="bp">↔</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">q₁</span> <span class="bp">↔</span> <span class="n">a</span> <span class="err">∈</span> <span class="n">q₂</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">seq</span><span class="bp">/</span><span class="n">wseq</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">wseq</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">nth</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">~</span> <span class="n">nth</span> <span class="n">t</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">~</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">set</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">set_coe</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">s</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="err">↑</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">b</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">data</span><span class="bp">/</span><span class="n">set</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">a</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">group_theory</span><span class="bp">/</span><span class="n">free_abelian_group</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">protected</span> <span class="kn">theorem</span> <span class="n">ext</span> <span class="o">(</span><span class="n">g</span> <span class="n">h</span> <span class="o">:</span> <span class="n">free_abelian_group</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
<span class="n">linear_algebra</span><span class="bp">/</span><span class="n">linear_map_module</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">A</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">B</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="err">$</span> <span class="n">funext</span> <span class="n">h</span>
<span class="n">linear_algebra</span><span class="bp">/</span><span class="n">tensor_product</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">to_module</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">g</span> <span class="n">h</span> <span class="o">:</span> <span class="n">M</span> <span class="err">⊗</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">P</span><span class="o">}</span>
<span class="n">number_theory</span><span class="bp">/</span><span class="n">dioph</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span>  <span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">S</span> <span class="n">S&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)}</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dioph</span> <span class="n">S</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">v</span><span class="o">,</span> <span class="n">S</span> <span class="n">v</span> <span class="bp">↔</span> <span class="n">S&#39;</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">dioph</span> <span class="n">S&#39;</span> <span class="o">:=</span>
<span class="n">number_theory</span><span class="bp">/</span><span class="n">pell</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span>  <span class="kn">theorem</span> <span class="n">ext</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">z</span> <span class="n">w</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="err">√</span><span class="n">d</span><span class="o">},</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">w</span> <span class="bp">↔</span> <span class="n">z</span><span class="bp">.</span><span class="n">re</span> <span class="bp">=</span> <span class="n">w</span><span class="bp">.</span><span class="n">re</span> <span class="bp">∧</span> <span class="n">z</span><span class="bp">.</span><span class="n">im</span> <span class="bp">=</span> <span class="n">w</span><span class="bp">.</span><span class="n">im</span>
<span class="n">order</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">preorder</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">preorder</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">partial_order</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">linear_order</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">linear_order</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">bounded_lattice</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">order_top</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">order_top</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">bounded_lattice</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">order_bot</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">order_bot</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">bounded_lattice</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">bounded_lattice</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">bounded_lattice</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">lattice</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">semilattice_sup</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">semilattice_sup</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">lattice</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">semilattice_inf</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">semilattice_inf</span> <span class="n">α</span><span class="o">}</span>
<span class="n">order</span><span class="bp">/</span><span class="n">lattice</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">lattice</span><span class="bp">.</span><span class="n">ext</span> <span class="o">{</span><span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">lattice</span> <span class="n">α</span><span class="o">}</span>
<span class="n">set_theory</span><span class="bp">/</span><span class="n">zfc</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">ext</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">pSet</span><span class="o">),</span> <span class="n">equiv</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">x</span> <span class="err">⊆</span> <span class="n">y</span> <span class="bp">∧</span> <span class="n">y</span> <span class="err">⊆</span> <span class="n">x</span><span class="o">)</span>
<span class="n">set_theory</span><span class="bp">/</span><span class="n">zfc</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">mem</span><span class="bp">.</span><span class="n">ext</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">pSet</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}},</span> <span class="o">(</span><span class="bp">∀</span><span class="n">w</span><span class="o">:</span><span class="n">pSet</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">},</span> <span class="n">w</span> <span class="err">∈</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">w</span> <span class="err">∈</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">equiv</span> <span class="n">x</span> <span class="n">y</span>
<span class="n">set_theory</span><span class="bp">/</span><span class="n">zfc</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="kn">theorem</span> <span class="n">ext</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">Set</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span><span class="n">z</span><span class="o">:</span><span class="n">Set</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">},</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">x</span> <span class="bp">↔</span> <span class="n">z</span> <span class="err">∈</span> <span class="n">y</span><span class="o">)</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
</pre></div>

#### [ Johan Commelin (Oct 03 2018 at 10:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135088502):
<p>Is it worth going through this list. Or have people done that before, and decided that this should not get the <code>extensionality</code> attribute?</p>

#### [ Kenny Lau (Oct 03 2018 at 10:37)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135089015):
<p>thanks for bringing this up</p>

#### [ Patrick Massot (Oct 03 2018 at 10:38)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135089062):
<p>I think it's worth going through the list</p>

#### [ Simon Hudon (Oct 03 2018 at 10:39)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135089070):
<p>I, for one, have not done it and I was working on the basis of "let's add them when we need them" after I added the most obvious ones.</p>

#### [ Johan Commelin (Oct 03 2018 at 10:46)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135089396):
<p>Can someone give an entry on the list that should <em>not</em> be tagged with the <code>extensionality</code> attribute? If I understand the reason, then I might be able to go through the list myself.</p>

#### [ Simon Hudon (Oct 03 2018 at 10:50)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135089575):
<p><code>set_theory/zfc.lean:theorem equiv.ext</code></p>

#### [ Scott Morrison (Oct 03 2018 at 10:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135089902):
<p>You missed <code>yoneda.ext</code> :-). (Perhaps because it's a <code>def</code>?)  Anyway, it probably shouldn't have <code>@[extensionality]</code>.</p>

#### [ Simon Hudon (Oct 03 2018 at 10:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135089964):
<p>Also, I wouldn't tag <code>semilattice_sup.ext_sup</code></p>

#### [ Johan Commelin (Oct 03 2018 at 11:00)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135090054):
<p>Can you explain why?</p>

#### [ Johan Commelin (Oct 03 2018 at 11:00)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135090064):
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Indeed, I only looked for lemmas and theorems</p>

#### [ Simon Hudon (Oct 03 2018 at 11:11)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135090608):
<p>It's a comparison of class instances rather than the objects themselves. It seems like it could produce surprising results</p>

#### [ Johan Commelin (Oct 03 2018 at 11:15)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135090806):
<p>Ok, I see. <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> Does it make sense to create an <code>extensionality</code> PR that adds about 40 <code>extensionality</code> attributes?</p>

#### [ Johannes Hölzl (Oct 03 2018 at 11:16)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135090874):
<p>Do we have 40 types? Are sensible? Also be careful that they don't overlap.</p>

#### [ Johan Commelin (Oct 03 2018 at 11:17)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135090907):
<p>See the list I posted above.</p>

#### [ Johan Commelin (Oct 03 2018 at 11:17)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135090923):
<p>Simon mentioned a couple that shouldn't be tagged, but I think a lot of them could reasonably be tagged.</p>

#### [ Simon Hudon (Oct 03 2018 at 11:21)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135091116):
<p>Some of them are equivalences while <code>ext</code> uses implications. When I encounter such lemma, I rename them <code>ext_iff</code> so that I can add a <code>ext</code> lemma as an implication</p>

#### [ Johannes Hölzl (Oct 03 2018 at 13:51)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097606):
<p>also before you add the extensionality lemmas we should change the semantics of <code>ext</code>. Instead of applying all possible extensionality lemmas it should only work along the names given by the user, or accept <code>*</code> to apply all.</p>

#### [ Johan Commelin (Oct 03 2018 at 13:53)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097698):
<p>Hmm, ok. Do you mean you want people to write <code>ext set</code> or <code>ext subtype</code> etc...?</p>

#### [ Simon Hudon (Oct 03 2018 at 13:54)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097745):
<p>Right now, <code>ext</code> detects the type of the arguments (e.g. set) and only tries relevant extensionality lemmas</p>

#### [ Simon Hudon (Oct 03 2018 at 13:54)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097758):
<p>It used to be that functional extensionality might be selected for the equality of two sets. It's no longer the case.</p>

#### [ Patrick Massot (Oct 03 2018 at 13:54)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097764):
<p>Johannes, that would be very sad</p>

#### [ Patrick Massot (Oct 03 2018 at 13:54)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097769):
<p>I like to type <code>ext</code> and Lean figures out what I mean</p>

#### [ Johannes Hölzl (Oct 03 2018 at 13:55)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097780):
<p>and I hate it to add an attribute and half of mathlib breaks</p>

#### [ Mario Carneiro (Oct 03 2018 at 13:55)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097781):
<p>Johannes this was implemented recently, like simon says</p>

#### [ Johannes Hölzl (Oct 03 2018 at 13:55)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097790):
<p>okay, thats good!</p>

#### [ Mario Carneiro (Oct 03 2018 at 13:55)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097800):
<p>You don't need to say <code>ext set</code>, it looks at the type of the objects in the equality in the goal</p>

#### [ Simon Hudon (Oct 03 2018 at 13:56)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097851):
<p>It's also tolerant on the kind of relation you can prove but I think sticking close to <code>=</code> is a good idea.</p>

#### [ Mario Carneiro (Oct 03 2018 at 13:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097866):
<p>But this also means that you essentially want one extensionality lemma for each type, so no multiples, and no equalities over generic types</p>

#### [ Johan Commelin (Oct 03 2018 at 13:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097868):
<p>Right, but <code>functor.ext</code> seems like a good exception</p>

#### [ Mario Carneiro (Oct 03 2018 at 13:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097939):
<p>If there are multiple candidates for extensionality, e.g. <code>roption.ext</code> vs <code>roption.ext'</code> then you have to think about which one is better general-purpose and pick one</p>

#### [ Simon Hudon (Oct 03 2018 at 13:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097970):
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I'm tempted to agree with you but technically, there's no reason why <code>functor.ext</code> wouldn't work as an extensionality lemma</p>

#### [ Johan Commelin (Oct 03 2018 at 13:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097992):
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> I meant that it is an exception to sticking to <code>=</code></p>

#### [ Mario Carneiro (Oct 03 2018 at 13:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135097994):
<p>Also keep in mind that <code>ext</code> will apply all extensionality lemmas it can all the way down so you don't want loopable hypotheses</p>

#### [ Simon Hudon (Oct 03 2018 at 14:00)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098052):
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> You can also give the most general one a lower priority</p>

#### [ Johan Commelin (Oct 03 2018 at 14:00)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098057):
<p>Or we want <code>ext</code> to take an optional <code>small_nat</code> argument like <code>congr</code></p>

#### [ Johan Commelin (Oct 03 2018 at 14:00)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098062):
<p>Or <code>congr'</code>, whatever</p>

#### [ Simon Hudon (Oct 03 2018 at 14:00)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098066):
<p>It already does: <code>ext : 3</code></p>

#### [ Mario Carneiro (Oct 03 2018 at 14:01)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098081):
<p>AFAIK competing extensionality lemmas always apply in the same generality, they just have different hypotheses, so giving priority wouldn't help</p>

#### [ Simon Hudon (Oct 03 2018 at 14:01)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098082):
<p>But I think Mario is right. There has to be a sense that something decreases as we keep applying <code>ext</code>, for instance the complexity of the objects being compared</p>

#### [ Simon Hudon (Oct 03 2018 at 14:02)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098144):
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I don't understand what you mean by "in the same generality"</p>

#### [ Mario Carneiro (Oct 03 2018 at 14:04)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098185):
<p>Most theorems that could qualify as <code>@[extensionality]</code> have a conclusion <code>(a : T) = b</code>, so if this is the goal then all extensionalities for T will apply</p>

#### [ Mario Carneiro (Oct 03 2018 at 14:05)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098270):
<p>With other kinds of theorems there might be a difference in generality like if one theorem only has say <code>F a = G b</code> in the conclusion, but with extensionality lemmas it's always <code>a = b</code> where <code>a</code> and <code>b</code> match anything in the type</p>

#### [ Simon Hudon (Oct 03 2018 at 14:05)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098278):
<p>You could see one lemma being <code>(a : set α) = b</code> and another be <code>(a : set (list α)) = b</code>. The first one is the most general one although both would be attempted</p>

#### [ Mario Carneiro (Oct 03 2018 at 14:06)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098339):
<p>I suppose that is a possibility, but so far I don't think we have any such "composite extensionality lemmas"</p>

#### [ Mario Carneiro (Oct 03 2018 at 14:06)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098348):
<p>it's always a constant or type constructor applied to variables</p>

#### [ Mario Carneiro (Oct 03 2018 at 14:08)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098445):
<p>Looking at the list, I see <code>free_abelian_group.ext</code> and <code>to_module.ext</code> have composite types, and <code>dioph</code> has something that isn't an extensionality at all</p>

#### [ Mario Carneiro (Oct 03 2018 at 14:09)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135098492):
<p>I don't think <code>free_abelian_group.ext</code> qualifies as an extensionality, this is some kind of yoneda thing</p>

#### [ Patrick Massot (Oct 03 2018 at 22:53)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135133090):
<p>what about <code>topological_space_eq</code>?</p>

#### [ Patrick Massot (Oct 03 2018 at 22:54)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/missing%20ext%20lemmas%3F/near/135133135):
<p>yes</p>


{% endraw %}
