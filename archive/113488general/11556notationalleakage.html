---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/11556notationalleakage.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html">notational leakage</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="169636247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169636247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169636247">Kevin Buzzard (Jul 04 2019 at 10:21)</a>:</h4>
<p>My understanding of idiomatic Lean is that a lot of simple terms have some kind of "canonical form", and when writing Lean code (especially simp lemmas) one should write each such term in its canonical form rather than any of the defeq other forms which can be used, because defeq is fine for <code>rfl</code> but not for <code>rw</code>.</p>
<p>In the past, when things have not come out in the "canonical form" which I want them to be, this was user error, because this user in particular had no idea about this canonical form philosophy until recently. </p>
<p>I'm now attempting to stick to it rigidly whilst writing teaching materials. Here is an example where I decide that <code>0</code> (i.e. <code>has_zero.zero</code>) is my canonical form for <code>mynat.zero</code> and then a <code>mynat.zero</code> appears:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">mynat</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">mynat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">mynat</span> <span class="bp">→</span> <span class="n">mynat</span>

<span class="c1">-- I want to never see mynat.zero again</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">mynat</span><span class="bp">.</span><span class="n">zero</span><span class="bp">⟩</span>

<span class="kn">namespace</span> <span class="n">mynat</span>

<span class="kn">definition</span> <span class="n">add</span> <span class="o">:</span> <span class="n">mynat</span> <span class="bp">→</span> <span class="n">mynat</span> <span class="bp">→</span> <span class="n">mynat</span>
<span class="bp">|</span> <span class="n">n</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">succ</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">n</span> <span class="n">p</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">mynat</span><span class="bp">.</span><span class="n">add</span><span class="bp">⟩</span>

<span class="kn">theorem</span> <span class="n">zero_add</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">mynat</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">x</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- ⊢ 0 + zero = zero -- leakage of &quot;zero&quot; i.e. mynat.zero</span>
    <span class="n">sorry</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- inductive case is fine</span>
    <span class="n">sorry</span>
  <span class="o">}</span>
<span class="kn">end</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">⊢ @eq.{1} mynat (@has_add.add.{0} mynat mynat.has_add (@has_zero.zero.{0} mynat mynat.has_zero) mynat.zero) mynat.zero</span>
<span class="cm">-/</span>
</pre></div>


<p>I was thinking I could just fix this with my own induction <em>function</em>, which does all the rewriting of <code>mynat.zero</code> to <code>has_zero.zero</code>. But I can't do it, because the <code>induction</code> tactic eats some new variable names and this is convenient, so I would have to write my own tactic to do this. I don't know where to start with writing tactics though. I think that in practice all I want to do is some kind of <code>repeat {rw (show mynat.zero = (0 : mynat), from rfl) at *},</code> after every application of any tactic which leaks.</p>
<p>Does anyone have any advice on how to make Lean a bit more noob-friendly here? I just want it to work for beginners and them never ever see <code>zero</code>.</p>

<a name="169636552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169636552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169636552">Johan Commelin (Jul 04 2019 at 10:25)</a>:</h4>
<p>Also, this doesn't seem to happen when you reprove <code>zero_add</code> for Lean's version of <code>nat</code>, right?</p>

<a name="169636567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169636567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169636567">Johan Commelin (Jul 04 2019 at 10:25)</a>:</h4>
<p>Let me check.</p>

<a name="169636657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169636657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169636657">Johan Commelin (Jul 04 2019 at 10:26)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="mi">1</span> <span class="n">goal</span>
<span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span>
<span class="err">⊢</span> <span class="mi">0</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span>
</pre></div>

<a name="169636672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169636672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169636672">Johan Commelin (Jul 04 2019 at 10:27)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">zero_add&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">induction</span> <span class="n">x</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- ⊢ 0 + 0 = 0 -- no leakage of &quot;zero&quot;</span>
    <span class="n">sorry</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- inductive case is fine</span>
    <span class="n">sorry</span>
  <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="169636692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169636692" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169636692">Johan Commelin (Jul 04 2019 at 10:27)</a>:</h4>
<p>So somehow the induction tactic picked up that <code>nat.zero</code> is not canonical form, and it should use <code>0</code>.</p>

<a name="169636770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169636770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169636770">Mario Carneiro (Jul 04 2019 at 10:28)</a>:</h4>
<p>It's not that hard to use a custom recursor, including getting names for the variables in the cases. You just use <code>refine</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">refine</span> <span class="n">mynat</span><span class="bp">.</span><span class="n">rec_on&#39;</span> <span class="n">n</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span> <span class="n">IH</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
</pre></div>

<a name="169636827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169636827" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169636827">Mario Carneiro (Jul 04 2019 at 10:29)</a>:</h4>
<p>This doesn't happen for <code>nat</code> because the pretty printer has magic to print <code>nat.zero</code> as <code>0</code> even though it's not the same as <code>has_zero.zero nat</code></p>

<a name="169636886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169636886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169636886">Mario Carneiro (Jul 04 2019 at 10:30)</a>:</h4>
<p>so the leakage is still happening, you just can't see it because of the pp</p>

<a name="169637008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169637008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169637008">Mario Carneiro (Jul 04 2019 at 10:32)</a>:</h4>
<p>We could try writing an <code>induction'</code> which doesn't have a broken <code>using</code> clause. I never use it because the <code>refine</code> version is shorter, but if the using clause was triggered automatically with an attribute that could be a lot of value added for custom recursors</p>

<a name="169637063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169637063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169637063">Johan Commelin (Jul 04 2019 at 10:33)</a>:</h4>
<p>I think this could be quite helpful to beginners...</p>

<a name="169637071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169637071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169637071">Johan Commelin (Jul 04 2019 at 10:33)</a>:</h4>
<p>In some sense the <code>induction</code> tactic is quite useless as it is.</p>

<a name="169637164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169637164" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169637164">Johan Commelin (Jul 04 2019 at 10:34)</a>:</h4>
<p>I would wish that <code>refine blah.rec_on _ _ _</code> isn't "idiomatic". Because the informal proof says "use induction on <code>x</code>". It would be great if you could actually type <code>induction x</code> in the Lean proof.</p>

<a name="169637246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169637246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169637246">Johan Commelin (Jul 04 2019 at 10:36)</a>:</h4>
<p>And I wouldn't want a <code>using</code> clause, that's very verbose. I'd rather have some sort of attribute.</p>

<a name="169637283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169637283" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169637283">Johan Commelin (Jul 04 2019 at 10:36)</a>:</h4>
<p>If we tag <code>mynat.custom_rec_on</code> with <code>@induction</code> then the <code>induction'</code> tactic could pick that up, right?</p>

<a name="169637308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169637308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169637308">Mario Carneiro (Jul 04 2019 at 10:37)</a>:</h4>
<p>that's the idea</p>

<a name="169637315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169637315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169637315">Mario Carneiro (Jul 04 2019 at 10:37)</a>:</h4>
<p>I like refine because it's the swiss army knife of lean tactics</p>

<a name="169637370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169637370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169637370">Mario Carneiro (Jul 04 2019 at 10:38)</a>:</h4>
<p>it's very straightforward to use and less to remember</p>

<a name="169637380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169637380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169637380">Mario Carneiro (Jul 04 2019 at 10:38)</a>:</h4>
<p>and it doesn't have gotchas like <code>apply</code></p>

<a name="169637570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169637570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169637570">Johan Commelin (Jul 04 2019 at 10:41)</a>:</h4>
<p>Sure <code>refine</code> is great as Swiss army knife. But it doesn't give you the semantics that <code>induction</code> has.</p>

<a name="169637621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169637621" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169637621">Johan Commelin (Jul 04 2019 at 10:42)</a>:</h4>
<p>If you want people to see in a glance what the idea behind the proof is...</p>

<a name="169637631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169637631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169637631">Johan Commelin (Jul 04 2019 at 10:42)</a>:</h4>
<p>Of course you can get almost every where with <code>refine</code>, <code>rw</code> and maybe occasionally a <code>simp [foo,bar]</code>.</p>

<a name="169637678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169637678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169637678">Johan Commelin (Jul 04 2019 at 10:43)</a>:</h4>
<p>But if you want to write "beautiful, beginner-friendly proofs"...</p>

<a name="169698599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169698599" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169698599">Kevin Buzzard (Jul 05 2019 at 10:19)</a>:</h4>
<p>What I need are non-leaky tactics, maybe called <code>induction'</code> and <code>cases'</code>, so that</p>
<div class="codehilite"><pre><span></span><span class="n">induction&#39;</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
</pre></div>


<p>is the same as</p>
<div class="codehilite"><pre><span></span>  <span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">all_goals</span> <span class="o">{</span><span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="n">mynat</span><span class="bp">.</span><span class="n">zero</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">mynat</span><span class="o">),</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">)</span> <span class="n">at</span> <span class="bp">*</span><span class="o">}},</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">all_goals</span> <span class="o">{</span><span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="n">mynat</span><span class="bp">.</span><span class="n">le</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">has_le</span><span class="bp">.</span><span class="n">le</span> <span class="n">mynat</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">)</span> <span class="n">at</span> <span class="bp">*</span><span class="o">}},</span>
</pre></div>


<p>etc etc</p>
<p>and <code>induction'</code> should fail iff <code>induction</code> fails.</p>
<p>Are these trivial to write?</p>

<a name="169698901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169698901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169698901">Kevin Buzzard (Jul 05 2019 at 10:25)</a>:</h4>
<p>I also want a rewrite tactic which does <em>not</em> try <code>rfl</code> at the end. Is this already in Lean?</p>

<a name="169698952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169698952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169698952">Chris Hughes (Jul 05 2019 at 10:26)</a>:</h4>
<p>Does this work?</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">open</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span> <span class="n">interactive</span><span class="bp">.</span><span class="n">types</span> <span class="n">expr</span> <span class="n">lean</span> <span class="n">lean</span><span class="bp">.</span><span class="n">parser</span> <span class="n">tactic</span> <span class="n">interactive</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">induction&#39;</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">cases_arg_p</span><span class="o">)</span> <span class="o">(</span><span class="n">ids</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">with_ident_list</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span><span class="bp">.</span><span class="n">induction</span> <span class="n">hp</span> <span class="n">none</span> <span class="n">ids</span> <span class="n">none</span><span class="o">,</span>
<span class="bp">`</span><span class="o">[</span><span class="n">repeat</span> <span class="o">{</span><span class="n">all_goals</span> <span class="o">{</span><span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="n">mynat</span><span class="bp">.</span><span class="n">zero</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">mynat</span><span class="o">),</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">)</span> <span class="n">at</span> <span class="bp">*</span><span class="o">}},</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">all_goals</span> <span class="o">{</span><span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="n">mynat</span><span class="bp">.</span><span class="n">le</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">has_le</span><span class="bp">.</span><span class="n">le</span> <span class="n">mynat</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">)</span> <span class="n">at</span> <span class="bp">*</span><span class="o">}}]</span>

<span class="kn">end</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>
</pre></div>

<a name="169698965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169698965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169698965">Chris Hughes (Jul 05 2019 at 10:27)</a>:</h4>
<p>You could also write a recursor using <code>has_zero.zero</code> and do <code>induction ... using</code></p>

<a name="169699058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169699058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169699058">Mario Carneiro (Jul 05 2019 at 10:28)</a>:</h4>
<p>It would be better to use <code>change mynat.zero with 0 at *</code> instead of <code>rw rfl</code> like that</p>

<a name="169699986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169699986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169699986">Kevin Buzzard (Jul 05 2019 at 10:49)</a>:</h4>
<p>For the rw with no refl I just copied a bunch of private defs from core and then deleted a random line and I think I got lucky:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">open</span> <span class="n">lean</span>
<span class="kn">open</span> <span class="n">lean</span><span class="bp">.</span><span class="n">parser</span>

<span class="n">local</span> <span class="kn">postfix</span> <span class="bp">`</span><span class="err">?</span><span class="bp">`</span><span class="o">:</span><span class="mi">9001</span> <span class="o">:=</span> <span class="n">optional</span>
<span class="n">local</span> <span class="kn">postfix</span> <span class="bp">*</span><span class="o">:</span><span class="mi">9001</span> <span class="o">:=</span> <span class="n">many</span>

<span class="kn">namespace</span> <span class="n">tactic</span>
<span class="kn">namespace</span> <span class="n">interactive</span>
<span class="kn">open</span> <span class="n">interactive</span> <span class="n">interactive</span><span class="bp">.</span><span class="n">types</span> <span class="n">expr</span>

<span class="kn">private</span> <span class="n">meta</span> <span class="n">def</span> <span class="n">resolve_name&#39;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">expr</span> <span class="o">:=</span>
<span class="n">do</span> <span class="o">{</span>
  <span class="n">p</span> <span class="err">←</span> <span class="n">resolve_name</span> <span class="n">n</span><span class="o">,</span>
  <span class="k">match</span> <span class="n">p</span> <span class="k">with</span>
  <span class="bp">|</span> <span class="n">expr</span><span class="bp">.</span><span class="n">const</span> <span class="n">n</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">mk_const</span> <span class="n">n</span> <span class="c1">-- create metavars for universe levels</span>
  <span class="bp">|</span> <span class="bp">_</span>              <span class="o">:=</span> <span class="n">i_to_expr</span> <span class="n">p</span>
  <span class="kn">end</span>
<span class="o">}</span>

<span class="kn">private</span> <span class="n">meta</span> <span class="n">def</span> <span class="n">rw_goal</span> <span class="o">(</span><span class="n">cfg</span> <span class="o">:</span> <span class="n">rewrite_cfg</span><span class="o">)</span> <span class="o">(</span><span class="n">rs</span> <span class="o">:</span> <span class="n">list</span> <span class="n">rw_rule</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">rs</span><span class="bp">.</span><span class="n">mmap&#39;</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span> <span class="n">do</span>
 <span class="n">save_info</span> <span class="n">r</span><span class="bp">.</span><span class="n">pos</span><span class="o">,</span>
 <span class="n">eq_lemmas</span> <span class="err">←</span> <span class="n">get_rule_eqn_lemmas</span> <span class="n">r</span><span class="o">,</span>
 <span class="n">orelse&#39;</span>
   <span class="o">(</span><span class="n">do</span> <span class="n">e</span> <span class="err">←</span> <span class="n">to_expr&#39;</span> <span class="n">r</span><span class="bp">.</span><span class="n">rule</span><span class="o">,</span> <span class="n">rewrite_target</span> <span class="n">e</span> <span class="o">{</span><span class="n">symm</span> <span class="o">:=</span> <span class="n">r</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="bp">..</span><span class="n">cfg</span><span class="o">})</span>
   <span class="o">(</span><span class="n">eq_lemmas</span><span class="bp">.</span><span class="n">mfirst</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">do</span> <span class="n">e</span> <span class="err">←</span> <span class="n">mk_const</span> <span class="n">n</span><span class="o">,</span> <span class="n">rewrite_target</span> <span class="n">e</span> <span class="o">{</span><span class="n">symm</span> <span class="o">:=</span> <span class="n">r</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="bp">..</span><span class="n">cfg</span><span class="o">})</span>
   <span class="o">(</span><span class="n">eq_lemmas</span><span class="bp">.</span><span class="n">empty</span><span class="o">)</span>

<span class="kn">private</span> <span class="n">meta</span> <span class="n">def</span> <span class="n">uses_hyp</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="n">e</span><span class="bp">.</span><span class="n">fold</span> <span class="n">ff</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">t</span> <span class="bp">_</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span> <span class="bp">||</span> <span class="n">to_bool</span> <span class="o">(</span><span class="n">t</span> <span class="bp">=</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">private</span> <span class="n">meta</span> <span class="n">def</span> <span class="n">rw_hyp</span> <span class="o">(</span><span class="n">cfg</span> <span class="o">:</span> <span class="n">rewrite_cfg</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">rw_rule</span> <span class="bp">→</span> <span class="n">expr</span> <span class="bp">→</span> <span class="n">tactic</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="o">[]</span>      <span class="n">hyp</span> <span class="o">:=</span> <span class="n">skip</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">r</span><span class="bp">::</span><span class="n">rs</span><span class="o">)</span> <span class="n">hyp</span> <span class="o">:=</span> <span class="n">do</span>
  <span class="n">save_info</span> <span class="n">r</span><span class="bp">.</span><span class="n">pos</span><span class="o">,</span>
  <span class="n">eq_lemmas</span> <span class="err">←</span> <span class="n">get_rule_eqn_lemmas</span> <span class="n">r</span><span class="o">,</span>
  <span class="n">orelse&#39;</span>
    <span class="o">(</span><span class="n">do</span> <span class="n">e</span> <span class="err">←</span> <span class="n">to_expr&#39;</span> <span class="n">r</span><span class="bp">.</span><span class="n">rule</span><span class="o">,</span> <span class="n">when</span> <span class="o">(</span><span class="n">not</span> <span class="o">(</span><span class="n">uses_hyp</span> <span class="n">e</span> <span class="n">hyp</span><span class="o">))</span> <span class="err">$</span> <span class="n">rewrite_hyp</span> <span class="n">e</span> <span class="n">hyp</span> <span class="o">{</span><span class="n">symm</span> <span class="o">:=</span> <span class="n">r</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="bp">..</span><span class="n">cfg</span><span class="o">}</span> <span class="bp">&gt;&gt;=</span> <span class="n">rw_hyp</span> <span class="n">rs</span><span class="o">)</span>
    <span class="o">(</span><span class="n">eq_lemmas</span><span class="bp">.</span><span class="n">mfirst</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">do</span> <span class="n">e</span> <span class="err">←</span> <span class="n">mk_const</span> <span class="n">n</span><span class="o">,</span> <span class="n">rewrite_hyp</span> <span class="n">e</span> <span class="n">hyp</span> <span class="o">{</span><span class="n">symm</span> <span class="o">:=</span> <span class="n">r</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="bp">..</span><span class="n">cfg</span><span class="o">}</span> <span class="bp">&gt;&gt;=</span> <span class="n">rw_hyp</span> <span class="n">rs</span><span class="o">)</span>
    <span class="o">(</span><span class="n">eq_lemmas</span><span class="bp">.</span><span class="n">empty</span><span class="o">)</span>

<span class="kn">private</span> <span class="n">meta</span> <span class="n">def</span> <span class="n">rw_core</span> <span class="o">(</span><span class="n">rs</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">rw_rules</span><span class="o">)</span> <span class="o">(</span><span class="n">loca</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">location</span><span class="o">)</span> <span class="o">(</span><span class="n">cfg</span> <span class="o">:</span> <span class="n">rewrite_cfg</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">loca</span> <span class="k">with</span>
<span class="bp">|</span> <span class="n">loc</span><span class="bp">.</span><span class="n">wildcard</span> <span class="o">:=</span> <span class="n">loca</span><span class="bp">.</span><span class="n">try_apply</span> <span class="o">(</span><span class="n">rw_hyp</span> <span class="n">cfg</span> <span class="n">rs</span><span class="bp">.</span><span class="n">rules</span><span class="o">)</span> <span class="o">(</span><span class="n">rw_goal</span> <span class="n">cfg</span> <span class="n">rs</span><span class="bp">.</span><span class="n">rules</span><span class="o">)</span>
<span class="bp">|</span> <span class="bp">_</span>            <span class="o">:=</span> <span class="n">loca</span><span class="bp">.</span><span class="n">apply</span> <span class="o">(</span><span class="n">rw_hyp</span> <span class="n">cfg</span> <span class="n">rs</span><span class="bp">.</span><span class="n">rules</span><span class="o">)</span> <span class="o">(</span><span class="n">rw_goal</span> <span class="n">cfg</span> <span class="n">rs</span><span class="bp">.</span><span class="n">rules</span><span class="o">)</span>
<span class="kn">end</span> <span class="bp">&gt;&gt;</span> <span class="o">(</span><span class="n">returnopt</span> <span class="n">rs</span><span class="bp">.</span><span class="n">end_pos</span> <span class="bp">&gt;&gt;=</span> <span class="n">save_info</span> <span class="bp">&lt;|&gt;</span> <span class="n">skip</span><span class="o">)</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">rw&#39;</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">rw_rules</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">parse</span> <span class="n">location</span><span class="o">)</span> <span class="o">(</span><span class="n">cfg</span> <span class="o">:</span> <span class="n">rewrite_cfg</span> <span class="o">:=</span> <span class="o">{})</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">propagate_tags</span> <span class="o">(</span><span class="n">rw_core</span> <span class="n">q</span> <span class="n">l</span> <span class="n">cfg</span><span class="o">)</span>

<span class="kn">end</span> <span class="n">interactive</span>
<span class="kn">end</span> <span class="n">tactic</span>
</pre></div>


<p>Is this a silly way to do it? I just deleted one of the <code>&gt;&gt;</code> lines after <code>end</code> in <code>rw_core</code></p>

<a name="169700707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169700707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169700707">Mario Carneiro (Jul 05 2019 at 11:04)</a>:</h4>
<p>like I said, use <code>change with</code> instead of <code>rw</code></p>

<a name="169700739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169700739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169700739">Kenny Lau (Jul 05 2019 at 11:04)</a>:</h4>
<p>use <code>erw</code></p>

<a name="169701636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169701636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169701636">Kevin Buzzard (Jul 05 2019 at 11:25)</a>:</h4>
<p><code>change with</code> just looks more complicated than <code>rw</code>. I have a working <code>rw'</code>. I don't mind writing new tactics. To be honest I don't even mind modding core Lean for this project, it's a standalone thing.</p>

<a name="169701647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169701647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169701647">Kevin Buzzard (Jul 05 2019 at 11:25)</a>:</h4>
<p>Chris I'll try your induction code when I get back in front of Lean. Thanks!</p>

<a name="169702257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169702257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169702257">Johan Commelin (Jul 05 2019 at 11:39)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> I think Mario means that you should use <code>change with</code> inside <code>induction'</code> instead of using <code>rw</code> there.</p>

<a name="169702285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169702285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169702285">Kevin Buzzard (Jul 05 2019 at 11:39)</a>:</h4>
<p>I just want one tactic which is simple to apply and which doesn't leak. I am not sure I understand what is being suggested.</p>

<a name="169702334"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169702334" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169702334">Kevin Buzzard (Jul 05 2019 at 11:40)</a>:</h4>
<p>At the minute I am writing</p>
<div class="codehilite"><pre><span></span><span class="n">induction</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span><span class="o">,</span>
<span class="n">clear_up_leaks</span><span class="o">,</span>
<span class="o">{</span> <span class="bp">...</span> <span class="o">}</span> <span class="o">{</span> <span class="bp">...</span> <span class="o">}</span>
</pre></div>

<a name="169702353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169702353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169702353">Kevin Buzzard (Jul 05 2019 at 11:40)</a>:</h4>
<p>and I want to write </p>
<div class="codehilite"><pre><span></span><span class="n">induction&#39;</span> <span class="n">n</span> <span class="k">with</span> <span class="n">d</span> <span class="n">hd</span>
<span class="o">{</span> <span class="c1">-- no leaks here}</span>
<span class="o">{</span> <span class="c1">-- or here}</span>
</pre></div>

<a name="169702611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169702611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169702611">Johan Commelin (Jul 05 2019 at 11:46)</a>:</h4>
<p>Right, and Mario says that <code>clear_up_leaks</code> should use <code>change</code> instead of <code>rw</code>.</p>

<a name="169702649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169702649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169702649">Johan Commelin (Jul 05 2019 at 11:47)</a>:</h4>
<p>We might want an attribute <code>@antileak</code> or something like that, that will change terms into defeq terms that are more canonical.</p>

<a name="169702654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169702654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169702654">Johan Commelin (Jul 05 2019 at 11:47)</a>:</h4>
<p>I guess we could also use <code>dsimp</code> for this?</p>

<a name="169702725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169702725" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169702725">Johan Commelin (Jul 05 2019 at 11:48)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> what happens if you write a simp lemma (tagged with <code>@[simp]</code> that says <code>mynat.zero = 0 := rfl</code>.<br>
And then you call <code>induction n with d hd; dsimp</code>.</p>

<a name="169702749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169702749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169702749">Johan Commelin (Jul 05 2019 at 11:49)</a>:</h4>
<p>Similarly you will want <code>mynat.succ n = n + 1 := rfl</code>.</p>

<a name="169702759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169702759" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169702759">Johan Commelin (Jul 05 2019 at 11:49)</a>:</h4>
<p>Is that sufficient to clear up the leaks?</p>

<a name="169702763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notational%20leakage/near/169702763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/11556notationalleakage.html#169702763">Kevin Buzzard (Jul 05 2019 at 11:49)</a>:</h4>
<p>That's strictly worse than <code>clear_up_leaks</code> because formally it's the same thing ("apply a tactic and then type something which you don't want") and secondly <code>simp</code> will close various goals, like <code>rfl</code> goals -- it does too much.</p>


{% endraw %}

{% include archive_update.html %}