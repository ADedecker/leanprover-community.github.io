---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/37335cleaningiff.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html">cleaning iff</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="174212351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174212351">Patrick Massot (Aug 27 2019 at 09:47)</a>:</h4>
<p><span class="user-mention" data-user-id="110865">@Jeremy Avigad</span> in particular: another area (besides calculations) where I'm always angry about automation is many proofs that are only unpackaging and repackaging stuff. The following is an example abstracted from a topological groups and filter context:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">has_sub</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">S</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="err">$</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
 <span class="o">(</span><span class="bp">∀</span> <span class="o">{</span><span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">},</span> <span class="n">V</span> <span class="err">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">t</span> <span class="err">∈</span> <span class="n">T</span><span class="o">),</span> <span class="n">set</span><span class="bp">.</span><span class="n">prod</span> <span class="n">t</span> <span class="n">t</span> <span class="err">⊆</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">V</span><span class="o">))</span> <span class="bp">↔</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">),</span> <span class="n">U</span> <span class="err">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">M</span> <span class="err">∈</span> <span class="n">T</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">-</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="174212424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174212424">Patrick Massot (Aug 27 2019 at 09:48)</a>:</h4>
<p>This has no mathematical content (in the sense that a mathematician wouldn't understand what requires a proof here).</p>

<a name="174212570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174212570">Patrick Massot (Aug 27 2019 at 09:50)</a>:</h4>
<p>What I would like Lean to do is at least to peel-off layers that are common to both lines.</p>

<a name="174212582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174212582">Patrick Massot (Aug 27 2019 at 09:50)</a>:</h4>
<p>Note that in this specific example, <code>by simp [subset_def]</code> works.</p>

<a name="174212794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174212794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174212794">Patrick Massot (Aug 27 2019 at 09:53)</a>:</h4>
<p>But it takes time to reach that conclusion. I also experimented writing the following stupid tactic:</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">tactic</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">clean_step</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">tgt</span> <span class="err">←</span> <span class="n">target</span><span class="o">,</span>
   <span class="k">match</span> <span class="n">tgt</span> <span class="k">with</span>
   <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">a</span> <span class="bp">→</span> <span class="err">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">intros</span><span class="o">]</span>
   <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">a</span> <span class="bp">↔</span> <span class="err">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
                     <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="err">%%</span><span class="n">c</span> <span class="bp">→</span> <span class="err">%%</span><span class="n">d</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">c</span><span class="bp">.</span><span class="n">has_var</span> <span class="k">then</span> <span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">imp_congr</span><span class="o">]</span> <span class="k">else</span> <span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">forall_congr</span><span class="o">]</span>
                     <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">Exists</span> <span class="err">%%</span><span class="n">c</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">exists_congr</span><span class="o">]</span>
                     <span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="n">iff</span><span class="bp">.</span><span class="n">rfl</span><span class="o">]</span>
                     <span class="kn">end</span>
   <span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">fail</span> <span class="s2">&quot;Goal is not a forall, implies or iff&quot;</span>
   <span class="kn">end</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span><span class="bp">.</span><span class="n">clean_iff</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">do</span> <span class="n">repeat</span> <span class="n">clean_step</span>
</pre></div>


<p>doing the peeling-off. In the example above, it reduces the goal to <code>set.prod s s ⊆ (λ (x : α × α), x.snd - x.fst) ⁻¹' a ↔  ∀ (x y : α), x ∈ s → y ∈ s → y - x ∈ a</code> which can be closed by <code>library_search</code>, which is pretty good I think. Should we try to make a smarter version of that tactic?</p>

<a name="174213553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174213553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174213553">Johan Commelin (Aug 27 2019 at 10:04)</a>:</h4>
<p>I've wanted such a "mild" congr tactic as well.</p>

<a name="174226236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174226236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174226236">Reid Barton (Aug 27 2019 at 13:04)</a>:</h4>
<p>This does feel like something within the scope of congr</p>

<a name="174229806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174229806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174229806">Jeremy Avigad (Aug 27 2019 at 13:41)</a>:</h4>
<p>I have had to do similar things, with crazy lambdas and corner brackets. It is funny how much of mathematics is just unpacking and repacking information. This is something that a decent tableau prover should do. (I am disappointed that <code>finish</code> is no help.) It is worth experimenting to see how useful a <code>congr</code>-like tactic is, though eventually it would be nice to see this subsumed by general automation.</p>

<a name="174229918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174229918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174229918">Patrick Massot (Aug 27 2019 at 13:42)</a>:</h4>
<p>I have no opinion about what kind of automation should do it, I only say <em>I</em> don't want to do it.</p>

<a name="174230252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174230252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174230252">Patrick Massot (Aug 27 2019 at 13:46)</a>:</h4>
<p>Here is my short answer to your "automation for the working mathematician" wish-list question:</p>
<ul>
<li>elaboration that works, including coercions, especially to functions, and type class resolution</li>
<li>calculations where I only give the intermediate steps I would write on paper, using <code>ring</code>, <code>abel</code> and their non-existent extensions to other algebraic structures, and non-linear <code>linarith</code></li>
<li>packing/unpacking stuff</li>
</ul>

<a name="174231499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/cleaning%20iff/near/174231499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/37335cleaningiff.html#174231499">Jeremy Avigad (Aug 27 2019 at 13:58)</a>:</h4>
<p>Thanks! I really am taking notes and gathering all the comments I received.</p>


{% endraw %}

{% include archive_update.html %}