---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/49207vmoverrides.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/49207vmoverrides.html">vm overrides</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="160292995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/vm%20overrides/near/160292995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49207vmoverrides.html#160292995">Edward Ayers (Mar 08 2019 at 14:21)</a>:</h4>
<p>I was thinking about VM overrides a little this week. I hacked around with the Lean source code a little and I got the VM to swap out vm_declarations  when one attaches a <code>vm_override</code> attribute to a declaration. <br>
<a href="https://github.com/EdAyers/lean/tree/vm_override" target="_blank" title="https://github.com/EdAyers/lean/tree/vm_override">https://github.com/EdAyers/lean/tree/vm_override</a><br>
The branch is not usable and crashes lean all of the time, it's just an experiment. <br>
The conclusions of my experiment are:</p>
<p>I get stack mismanagement errors if the VM overridden type has a different size to the original type. So just swapping out declarations isn't good enough. The VM needs to keep a registry of what is overridden.<br>
My proposal for VM overrides is to use typeclasses or similar to give a pseudo-bijection between the original data and the override data:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">float</span> <span class="o">:=</span> <span class="bp">...</span><span class="n">IEEE</span> <span class="kn">definition</span> <span class="n">of</span> <span class="n">float</span> <span class="n">goes</span> <span class="n">here</span>

<span class="n">meta</span> <span class="kn">instance</span> <span class="o">:</span> <span class="n">has_vm_override</span> <span class="n">float</span> <span class="n">native</span><span class="bp">.</span><span class="n">float</span> <span class="o">:=</span>  <span class="bp">⟨</span><span class="n">to_native</span><span class="o">,</span> <span class="n">from_native</span><span class="bp">⟩</span>

  <span class="c1">-- now the VM is aware that all floats should be converted to native.floats.</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">vm_override</span> <span class="n">native</span><span class="bp">.</span><span class="n">float</span><span class="bp">.</span><span class="n">add</span><span class="o">]</span>
  <span class="n">def</span> <span class="n">add</span> <span class="o">:</span> <span class="n">float</span> <span class="bp">→</span> <span class="n">float</span> <span class="bp">→</span> <span class="n">float</span> <span class="o">:=</span>   <span class="bp">...</span> <span class="n">IEEE</span> <span class="kn">definition</span>
  <span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">float</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">add</span><span class="bp">⟩</span>
</pre></div>


<p>The VM will use the given <code>to_native</code> and <code>from_native</code> functions to convert between the formats. This means that if you define some operation on floats but you forget to give the VM override, then it won't completely break the VM because the VM can convert between the native and nonnative versions of the data as necessary.</p>

<a name="160310542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/vm%20overrides/near/160310542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49207vmoverrides.html#160310542">Mario Carneiro (Mar 08 2019 at 18:00)</a>:</h4>
<p>It shouldn't be possible to forget to give the VM override once the basics are set up. In particular, all core operations that reference the overridden type (of which there are O(1) of them) must be overridden. In your example that means all the <code>float</code> constructors and <code>float.rec</code>. In practice I would instead define a separate inductive type <code>inductive IEEE_float := ...</code> like you are envisioning, and then <code>structure float := (to_IEEE: IEEE_float)</code> is a newtype that gets overridden. Now you only need a few overrides: <code>to_IEEE</code> is overriden to <code>from_native</code>, <code>mk</code> is overridden to <code>to_native</code>, and <code>float.rec</code> is overridden to a function that uses <code>from_native</code>.</p>

<a name="160310593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/vm%20overrides/near/160310593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/49207vmoverrides.html#160310593">Mario Carneiro (Mar 08 2019 at 18:01)</a>:</h4>
<p>Could you elaborate on the stack mismanagement errors? It is possible that we need to hint to lean that the type itself is being overridden (and it's also good documentation), but I didn't think this would be necessary.</p>


{% endraw %}
