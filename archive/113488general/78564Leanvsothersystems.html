---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/78564Leanvsothersystems.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html">Lean vs other systems</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="179166943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179166943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179166943">Juho Kupiainen (Oct 27 2019 at 11:24)</a>:</h4>
<p>There are many systems that allow you to write and check proofs written in a formal language. Lean, Metamath, Isabelle HOL, Coq, ACL2, Agda, Albatross, F*, HOL Light, HOL4, LEGO, Mizar, NuPRL, PVS, Twelf</p>
<p>I'm just wondering if we are better or worse off having all these different systems. Should we all just stick to one and build a good library in it, or is there some fundamental reasons why one is better than another. Yes, Lean has a computational component that Metamath doesn't, but nothing is stopping you from writing a model of a real computer in Metamath. Yes, Lean has proof automation that Metamath doesn't have, but aren't big general  theorems exactly the same as proof automation? I'd personally be especially interested in hearing <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> s thoughts on this. Pondering this I'm reminded of  a song called "One Vision" by Queen..</p>

<a name="179167011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167011" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167011">Mario Carneiro (Oct 27 2019 at 11:27)</a>:</h4>
<p>I am largely agnostic as to foundations. But I do think that we should make every effort to connect all the proof systems together, because how else can we make proofs "stick"? It would be quite the nightmare if we can never get off the ground because we reinvent natural number addition every five years in a new system</p>

<a name="179167069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167069">Mario Carneiro (Oct 27 2019 at 11:29)</a>:</h4>
<p>Actually, I prefer simple foundations to complex ones because the complex foundations fool you into thinking that you have something that is easier than it is; as soon as you stray from what the axioms give you things become hard again</p>

<a name="179167129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167129">Juho Kupiainen (Oct 27 2019 at 11:30)</a>:</h4>
<p>Are things easier in Lean though, than in Metamath, after having actually tried to do complicated things in Metamath?</p>

<a name="179167145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167145">Mario Carneiro (Oct 27 2019 at 11:31)</a>:</h4>
<p>The most important feature a foundation has is <em>expressivity</em>, the ability to define the things people care about, with proportional overhead (not exponential overhead!). If you can't write X in the system, then you are doomed, although you can delay the inevitable for a while</p>

<a name="179167190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167190" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167190">Mario Carneiro (Oct 27 2019 at 11:32)</a>:</h4>
<p>The problem with questions like that is it presupposes that Metamath and Lean are trying to solve the same problems, and they aren't</p>

<a name="179167198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167198">Mario Carneiro (Oct 27 2019 at 11:32)</a>:</h4>
<p>Metamath is a logical foundation and a verification system. It has a "build your own" user experience</p>

<a name="179167208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167208">Mario Carneiro (Oct 27 2019 at 11:33)</a>:</h4>
<p>so asking if Metamath has tactics is beside the point; it's not supposed to have tactics, it's a foundational system</p>

<a name="179167268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167268">Mario Carneiro (Oct 27 2019 at 11:34)</a>:</h4>
<p>Of course you want tactics and a nice user experience, but I think metamath is one of the few systems that conciously separates this from the verification aspect</p>

<a name="179167276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167276">Juho Kupiainen (Oct 27 2019 at 11:35)</a>:</h4>
<p>I'm just wondering whether there is any fundamental reason why writing general theorems in metamath in order to help proving things is any different from writing tactics in Lean?</p>

<a name="179167290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167290">Mario Carneiro (Oct 27 2019 at 11:35)</a>:</h4>
<p>Theorems and tactics are different. A tactic is more like a metatheorem, a family of related theorems that are all provable</p>

<a name="179167340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167340" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167340">Kevin Kappelmann (Oct 27 2019 at 11:36)</a>:</h4>
<p>btw. there are efforts to connect theorem provers, e.g. <a href="http://logipedia.inria.fr/about/about.php" target="_blank" title="http://logipedia.inria.fr/about/about.php">Logipedia/Dedukti</a></p>

<a name="179167341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167341" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167341">Mario Carneiro (Oct 27 2019 at 11:36)</a>:</h4>
<p>the downside of a tactic is that you have to run it every time you want a new proof, whereas you can check a theorem once and use it as many times as you like</p>

<a name="179167349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167349">Juho Kupiainen (Oct 27 2019 at 11:36)</a>:</h4>
<p>I'm not an expert on this so please correct me if I'm completely wrong, but doesn't expressive foundations allow you to write category theory kinds of general theorems that are basically the same thing as tactics? I'm just guessing.</p>

<a name="179167367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167367">Mario Carneiro (Oct 27 2019 at 11:37)</a>:</h4>
<p>An example of something that can't be proven by a single theorem is <code>norm_num</code></p>

<a name="179167373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167373">Mario Carneiro (Oct 27 2019 at 11:37)</a>:</h4>
<p>that is, evaluating arbitrary arithmetic expressions</p>

<a name="179167424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167424">Juho Kupiainen (Oct 27 2019 at 11:38)</a>:</h4>
<p>So the problem is that you can't make the metamath proof checker do complex calculations? You have to spell out the calculations in the proof? and then you need to have a metasystem that writes those long calculations?</p>

<a name="179167425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167425">Mario Carneiro (Oct 27 2019 at 11:38)</a>:</h4>
<p>yes</p>

<a name="179167427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167427">Juho Kupiainen (Oct 27 2019 at 11:38)</a>:</h4>
<p>But is this actually true?</p>

<a name="179167433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167433">Mario Carneiro (Oct 27 2019 at 11:39)</a>:</h4>
<p>This is a benefit</p>

<a name="179167437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167437">Mario Carneiro (Oct 27 2019 at 11:39)</a>:</h4>
<p>By an appropriate sequence of lemmas, you can make the metamath proof checker perform any computation in NP</p>

<a name="179167480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167480">Mario Carneiro (Oct 27 2019 at 11:40)</a>:</h4>
<p>the same holds true for lean btw</p>

<a name="179167496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167496">Juho Kupiainen (Oct 27 2019 at 11:41)</a>:</h4>
<p>So there is no way to make metamath proof checker perform an arbitrary calculation by writing down the definition of the calculation as a turing machine and proving that the calculation terminates? Because if you could, couldn't you somehow transfer the calculation work on to the proof checker side? that is make a tactic that's written inside the system?</p>

<a name="179167538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167538" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167538">Juho Kupiainen (Oct 27 2019 at 11:42)</a>:</h4>
<p>As in you can't say, this theorem holds because this tactic proof searching algorithm is proven to terminate, and the proof is simply to run the program?</p>

<a name="179167539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167539">Mario Carneiro (Oct 27 2019 at 11:42)</a>:</h4>
<p>You have to provide a proof that the TM evaluates to some particular value, and that means roughly one proof step per TM step</p>

<a name="179167546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167546">Mario Carneiro (Oct 27 2019 at 11:43)</a>:</h4>
<p>so the longer the program runs, the longer the proof gets</p>

<a name="179167551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167551">Mario Carneiro (Oct 27 2019 at 11:43)</a>:</h4>
<p>metamath doesn't support extending the kernel by a verified computation. I hope to add this capability to MM0 after the bootstrap</p>

<a name="179167593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167593">Mario Carneiro (Oct 27 2019 at 11:44)</a>:</h4>
<p>It's still pretty darn fast without it</p>

<a name="179167611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167611">Juho Kupiainen (Oct 27 2019 at 11:45)</a>:</h4>
<p>So, the point is that tactics may not terminate, and you can't make a proof checker run something that may not terminate. and metamath is only a proof checker.</p>

<a name="179167654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167654">Mario Carneiro (Oct 27 2019 at 11:46)</a>:</h4>
<blockquote>
<p>this theorem holds because this tactic proof searching algorithm is proven to terminate</p>
</blockquote>
<p>It would be a very strange theorem that would not be provable outright if you had this property</p>

<a name="179167660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167660" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167660">Mario Carneiro (Oct 27 2019 at 11:46)</a>:</h4>
<p>the only reason it doesn't work for things like <code>norm_num</code> is because the theorems are not uniformly describable</p>

<a name="179167708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167708">Mario Carneiro (Oct 27 2019 at 11:48)</a>:</h4>
<p>termination or lack thereof is not a problem. Metamath simply doesn't know how computers work so it can't extend itself with a computer program given by the user</p>

<a name="179167721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167721">Mario Carneiro (Oct 27 2019 at 11:48)</a>:</h4>
<p>If we're running the program, then there is no problem with termination - we continue verification only after it returns, so if it never returns then we never finish the proof</p>

<a name="179167731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167731">Mario Carneiro (Oct 27 2019 at 11:49)</a>:</h4>
<p>If we are not running the program, and are simply using the existence of the program to prove the theorem, then we may as well chuck the program and prove the theorem directly</p>

<a name="179167780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167780">Juho Kupiainen (Oct 27 2019 at 11:50)</a>:</h4>
<p>I'm just guessing again but isn't the point of all these new type theory systems to kind of make a unification algorithm that can be easily used as a general purpose computer?</p>

<a name="179167782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167782">Mario Carneiro (Oct 27 2019 at 11:50)</a>:</h4>
<p>that's the theory...</p>

<a name="179167791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167791">Mario Carneiro (Oct 27 2019 at 11:51)</a>:</h4>
<p>turns out computers are better at being computers than unification algorithms are at being computers</p>

<a name="179167798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167798">Kenny Lau (Oct 27 2019 at 11:51)</a>:</h4>
<p>theory and practice are the same in theory but not in practice</p>

<a name="179167863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167863">Juho Kupiainen (Oct 27 2019 at 11:53)</a>:</h4>
<p>I like how metamath is such a simple system and then you just have a list of axioms. Could we do kind of a similar thing where we could extend the unification algorithm by just adding an extra axiom?</p>

<a name="179167910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167910">Mario Carneiro (Oct 27 2019 at 11:54)</a>:</h4>
<p>Lean is actually extensible in this way, but it's a "big boy" feature and was not entrusted to us. Currently the only extensions to the normalization algorithm are quotients and inductive types</p>

<a name="179167920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167920">Mario Carneiro (Oct 27 2019 at 11:54)</a>:</h4>
<p>If you add your own rules it becomes very easy to loop or lose some metatheoretic property</p>

<a name="179167928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167928">Mario Carneiro (Oct 27 2019 at 11:55)</a>:</h4>
<p>and you will almost certainly make defeq undecidable</p>

<a name="179167978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167978">Mario Carneiro (Oct 27 2019 at 11:56)</a>:</h4>
<p>Basically, in DTT defeq is "second class" equality - it's never strong enough, but you can't just ignore it. I like that in metamath there is only one equality</p>

<a name="179167983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167983" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167983">Juho Kupiainen (Oct 27 2019 at 11:56)</a>:</h4>
<p>But couldn't you just add a feature that allows you to prove things by saying that the proof exist because a computation terminates, and then you can just add a "proof by termination" and the checker runs the computation. Of course you may not actually have the proof.</p>

<a name="179167986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167986">Juho Kupiainen (Oct 27 2019 at 11:56)</a>:</h4>
<p>But thats basically what a tactic is.</p>

<a name="179167988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167988" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167988">Mario Carneiro (Oct 27 2019 at 11:56)</a>:</h4>
<p>right, that's what I mean by extending the kernel with a verified computation</p>

<a name="179167994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167994">Mario Carneiro (Oct 27 2019 at 11:57)</a>:</h4>
<p>that's not the same as a tactic, which is a <em>proof-producing program</em></p>

<a name="179167999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167999">Mario Carneiro (Oct 27 2019 at 11:57)</a>:</h4>
<p>metamath prefers to deal with tactics in that sense, because the checker doesn't have to know anything about the tactic for the system to work</p>

<a name="179168000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168000">Juho Kupiainen (Oct 27 2019 at 11:57)</a>:</h4>
<p>Well, basically the same, as the program may not actually terminate when you write "proof by termination" and run the checker?</p>

<a name="179168042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168042">Mario Carneiro (Oct 27 2019 at 11:58)</a>:</h4>
<p>The checker is given the output of the tactic as its input. It is never given the opportunity to run the tactic itself</p>

<a name="179168057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168057" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168057">Mario Carneiro (Oct 27 2019 at 11:59)</a>:</h4>
<p>so when you start the checker you already have the proof of termination in hand</p>

<a name="179168058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168058">Juho Kupiainen (Oct 27 2019 at 11:59)</a>:</h4>
<p>Ah, right. A tactic would be adding that the program terminates as an axiom.</p>

<a name="179168060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168060">Juho Kupiainen (Oct 27 2019 at 11:59)</a>:</h4>
<p>And seeing what happens.</p>

<a name="179168064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168064">Mario Carneiro (Oct 27 2019 at 11:59)</a>:</h4>
<p>Lean doesn't have trusted computations either btw</p>


{% endraw %}

{% include archive_update.html %}