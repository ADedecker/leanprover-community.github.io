---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/78564Leanvsothersystems.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html">Lean vs other systems</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="179166943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179166943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179166943">Juho Kupiainen (Oct 27 2019 at 11:24)</a>:</h4>
<p>There are many systems that allow you to write and check proofs written in a formal language. Lean, Metamath, Isabelle HOL, Coq, ACL2, Agda, Albatross, F*, HOL Light, HOL4, LEGO, Mizar, NuPRL, PVS, Twelf</p>
<p>I'm just wondering if we are better or worse off having all these different systems. Should we all just stick to one and build a good library in it, or is there some fundamental reasons why one is better than another. Yes, Lean has a computational component that Metamath doesn't, but nothing is stopping you from writing a model of a real computer in Metamath. Yes, Lean has proof automation that Metamath doesn't have, but aren't big general  theorems exactly the same as proof automation? I'd personally be especially interested in hearing <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> s thoughts on this. Pondering this I'm reminded of  a song called "One Vision" by Queen..</p>

<a name="179167011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167011" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167011">Mario Carneiro (Oct 27 2019 at 11:27)</a>:</h4>
<p>I am largely agnostic as to foundations. But I do think that we should make every effort to connect all the proof systems together, because how else can we make proofs "stick"? It would be quite the nightmare if we can never get off the ground because we reinvent natural number addition every five years in a new system</p>

<a name="179167069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167069">Mario Carneiro (Oct 27 2019 at 11:29)</a>:</h4>
<p>Actually, I prefer simple foundations to complex ones because the complex foundations fool you into thinking that you have something that is easier than it is; as soon as you stray from what the axioms give you things become hard again</p>

<a name="179167129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167129">Juho Kupiainen (Oct 27 2019 at 11:30)</a>:</h4>
<p>Are things easier in Lean though, than in Metamath, after having actually tried to do complicated things in Metamath?</p>

<a name="179167145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167145">Mario Carneiro (Oct 27 2019 at 11:31)</a>:</h4>
<p>The most important feature a foundation has is <em>expressivity</em>, the ability to define the things people care about, with proportional overhead (not exponential overhead!). If you can't write X in the system, then you are doomed, although you can delay the inevitable for a while</p>

<a name="179167190"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167190" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167190">Mario Carneiro (Oct 27 2019 at 11:32)</a>:</h4>
<p>The problem with questions like that is it presupposes that Metamath and Lean are trying to solve the same problems, and they aren't</p>

<a name="179167198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167198">Mario Carneiro (Oct 27 2019 at 11:32)</a>:</h4>
<p>Metamath is a logical foundation and a verification system. It has a "build your own" user experience</p>

<a name="179167208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167208">Mario Carneiro (Oct 27 2019 at 11:33)</a>:</h4>
<p>so asking if Metamath has tactics is beside the point; it's not supposed to have tactics, it's a foundational system</p>

<a name="179167268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167268">Mario Carneiro (Oct 27 2019 at 11:34)</a>:</h4>
<p>Of course you want tactics and a nice user experience, but I think metamath is one of the few systems that conciously separates this from the verification aspect</p>

<a name="179167276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167276">Juho Kupiainen (Oct 27 2019 at 11:35)</a>:</h4>
<p>I'm just wondering whether there is any fundamental reason why writing general theorems in metamath in order to help proving things is any different from writing tactics in Lean?</p>

<a name="179167290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167290">Mario Carneiro (Oct 27 2019 at 11:35)</a>:</h4>
<p>Theorems and tactics are different. A tactic is more like a metatheorem, a family of related theorems that are all provable</p>

<a name="179167340"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167340" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167340">Kevin Kappelmann (Oct 27 2019 at 11:36)</a>:</h4>
<p>btw. there are efforts to connect theorem provers, e.g. <a href="http://logipedia.inria.fr/about/about.php" target="_blank" title="http://logipedia.inria.fr/about/about.php">Logipedia/Dedukti</a></p>

<a name="179167341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167341" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167341">Mario Carneiro (Oct 27 2019 at 11:36)</a>:</h4>
<p>the downside of a tactic is that you have to run it every time you want a new proof, whereas you can check a theorem once and use it as many times as you like</p>

<a name="179167349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167349">Juho Kupiainen (Oct 27 2019 at 11:36)</a>:</h4>
<p>I'm not an expert on this so please correct me if I'm completely wrong, but doesn't expressive foundations allow you to write category theory kinds of general theorems that are basically the same thing as tactics? I'm just guessing.</p>

<a name="179167367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167367">Mario Carneiro (Oct 27 2019 at 11:37)</a>:</h4>
<p>An example of something that can't be proven by a single theorem is <code>norm_num</code></p>

<a name="179167373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167373">Mario Carneiro (Oct 27 2019 at 11:37)</a>:</h4>
<p>that is, evaluating arbitrary arithmetic expressions</p>

<a name="179167424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167424">Juho Kupiainen (Oct 27 2019 at 11:38)</a>:</h4>
<p>So the problem is that you can't make the metamath proof checker do complex calculations? You have to spell out the calculations in the proof? and then you need to have a metasystem that writes those long calculations?</p>

<a name="179167425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167425">Mario Carneiro (Oct 27 2019 at 11:38)</a>:</h4>
<p>yes</p>

<a name="179167427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167427">Juho Kupiainen (Oct 27 2019 at 11:38)</a>:</h4>
<p>But is this actually true?</p>

<a name="179167433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167433">Mario Carneiro (Oct 27 2019 at 11:39)</a>:</h4>
<p>This is a benefit</p>

<a name="179167437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167437">Mario Carneiro (Oct 27 2019 at 11:39)</a>:</h4>
<p>By an appropriate sequence of lemmas, you can make the metamath proof checker perform any computation in NP</p>

<a name="179167480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167480">Mario Carneiro (Oct 27 2019 at 11:40)</a>:</h4>
<p>the same holds true for lean btw</p>

<a name="179167496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167496">Juho Kupiainen (Oct 27 2019 at 11:41)</a>:</h4>
<p>So there is no way to make metamath proof checker perform an arbitrary calculation by writing down the definition of the calculation as a turing machine and proving that the calculation terminates? Because if you could, couldn't you somehow transfer the calculation work on to the proof checker side? that is make a tactic that's written inside the system?</p>

<a name="179167538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167538" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167538">Juho Kupiainen (Oct 27 2019 at 11:42)</a>:</h4>
<p>As in you can't say, this theorem holds because this tactic proof searching algorithm is proven to terminate, and the proof is simply to run the program?</p>

<a name="179167539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167539">Mario Carneiro (Oct 27 2019 at 11:42)</a>:</h4>
<p>You have to provide a proof that the TM evaluates to some particular value, and that means roughly one proof step per TM step</p>

<a name="179167546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167546">Mario Carneiro (Oct 27 2019 at 11:43)</a>:</h4>
<p>so the longer the program runs, the longer the proof gets</p>

<a name="179167551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167551">Mario Carneiro (Oct 27 2019 at 11:43)</a>:</h4>
<p>metamath doesn't support extending the kernel by a verified computation. I hope to add this capability to MM0 after the bootstrap</p>

<a name="179167593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167593">Mario Carneiro (Oct 27 2019 at 11:44)</a>:</h4>
<p>It's still pretty darn fast without it</p>

<a name="179167611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167611">Juho Kupiainen (Oct 27 2019 at 11:45)</a>:</h4>
<p>So, the point is that tactics may not terminate, and you can't make a proof checker run something that may not terminate. and metamath is only a proof checker.</p>

<a name="179167654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167654">Mario Carneiro (Oct 27 2019 at 11:46)</a>:</h4>
<blockquote>
<p>this theorem holds because this tactic proof searching algorithm is proven to terminate</p>
</blockquote>
<p>It would be a very strange theorem that would not be provable outright if you had this property</p>

<a name="179167660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167660" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167660">Mario Carneiro (Oct 27 2019 at 11:46)</a>:</h4>
<p>the only reason it doesn't work for things like <code>norm_num</code> is because the theorems are not uniformly describable</p>

<a name="179167708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167708">Mario Carneiro (Oct 27 2019 at 11:48)</a>:</h4>
<p>termination or lack thereof is not a problem. Metamath simply doesn't know how computers work so it can't extend itself with a computer program given by the user</p>

<a name="179167721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167721">Mario Carneiro (Oct 27 2019 at 11:48)</a>:</h4>
<p>If we're running the program, then there is no problem with termination - we continue verification only after it returns, so if it never returns then we never finish the proof</p>

<a name="179167731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167731">Mario Carneiro (Oct 27 2019 at 11:49)</a>:</h4>
<p>If we are not running the program, and are simply using the existence of the program to prove the theorem, then we may as well chuck the program and prove the theorem directly</p>

<a name="179167780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167780">Juho Kupiainen (Oct 27 2019 at 11:50)</a>:</h4>
<p>I'm just guessing again but isn't the point of all these new type theory systems to kind of make a unification algorithm that can be easily used as a general purpose computer?</p>

<a name="179167782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167782">Mario Carneiro (Oct 27 2019 at 11:50)</a>:</h4>
<p>that's the theory...</p>

<a name="179167791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167791">Mario Carneiro (Oct 27 2019 at 11:51)</a>:</h4>
<p>turns out computers are better at being computers than unification algorithms are at being computers</p>

<a name="179167798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167798">Kenny Lau (Oct 27 2019 at 11:51)</a>:</h4>
<p>theory and practice are the same in theory but not in practice</p>

<a name="179167863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167863">Juho Kupiainen (Oct 27 2019 at 11:53)</a>:</h4>
<p>I like how metamath is such a simple system and then you just have a list of axioms. Could we do kind of a similar thing where we could extend the unification algorithm by just adding an extra axiom?</p>

<a name="179167910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167910">Mario Carneiro (Oct 27 2019 at 11:54)</a>:</h4>
<p>Lean is actually extensible in this way, but it's a "big boy" feature and was not entrusted to us. Currently the only extensions to the normalization algorithm are quotients and inductive types</p>

<a name="179167920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167920">Mario Carneiro (Oct 27 2019 at 11:54)</a>:</h4>
<p>If you add your own rules it becomes very easy to loop or lose some metatheoretic property</p>

<a name="179167928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167928">Mario Carneiro (Oct 27 2019 at 11:55)</a>:</h4>
<p>and you will almost certainly make defeq undecidable</p>

<a name="179167978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167978">Mario Carneiro (Oct 27 2019 at 11:56)</a>:</h4>
<p>Basically, in DTT defeq is "second class" equality - it's never strong enough, but you can't just ignore it. I like that in metamath there is only one equality</p>

<a name="179167983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167983" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167983">Juho Kupiainen (Oct 27 2019 at 11:56)</a>:</h4>
<p>But couldn't you just add a feature that allows you to prove things by saying that the proof exist because a computation terminates, and then you can just add a "proof by termination" and the checker runs the computation. Of course you may not actually have the proof.</p>

<a name="179167986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167986">Juho Kupiainen (Oct 27 2019 at 11:56)</a>:</h4>
<p>But thats basically what a tactic is.</p>

<a name="179167988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167988" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167988">Mario Carneiro (Oct 27 2019 at 11:56)</a>:</h4>
<p>right, that's what I mean by extending the kernel with a verified computation</p>

<a name="179167994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167994">Mario Carneiro (Oct 27 2019 at 11:57)</a>:</h4>
<p>that's not the same as a tactic, which is a <em>proof-producing program</em></p>

<a name="179167999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179167999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179167999">Mario Carneiro (Oct 27 2019 at 11:57)</a>:</h4>
<p>metamath prefers to deal with tactics in that sense, because the checker doesn't have to know anything about the tactic for the system to work</p>

<a name="179168000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168000">Juho Kupiainen (Oct 27 2019 at 11:57)</a>:</h4>
<p>Well, basically the same, as the program may not actually terminate when you write "proof by termination" and run the checker?</p>

<a name="179168042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168042">Mario Carneiro (Oct 27 2019 at 11:58)</a>:</h4>
<p>The checker is given the output of the tactic as its input. It is never given the opportunity to run the tactic itself</p>

<a name="179168057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168057" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168057">Mario Carneiro (Oct 27 2019 at 11:59)</a>:</h4>
<p>so when you start the checker you already have the proof of termination in hand</p>

<a name="179168058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168058">Juho Kupiainen (Oct 27 2019 at 11:59)</a>:</h4>
<p>Ah, right. A tactic would be adding that the program terminates as an axiom.</p>

<a name="179168060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168060">Juho Kupiainen (Oct 27 2019 at 11:59)</a>:</h4>
<p>And seeing what happens.</p>

<a name="179168064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168064">Mario Carneiro (Oct 27 2019 at 11:59)</a>:</h4>
<p>Lean doesn't have trusted computations either btw</p>

<a name="179168096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168096">Mario Carneiro (Oct 27 2019 at 12:00)</a>:</h4>
<p>It very nearly does, but you can't use <code>#eval</code> to prove a reflexivity</p>

<a name="179168142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168142" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168142">Juho Kupiainen (Oct 27 2019 at 12:01)</a>:</h4>
<p>I want to build my own proof system. Maybe we should collaborate on extending metamath? Personally, I'd like to build a system where you can solve real world problems by checking proofs in order of length.</p>

<a name="179168186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168186">Mario Carneiro (Oct 27 2019 at 12:02)</a>:</h4>
<p>that will never scale unfortunately</p>

<a name="179168188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168188">Mario Carneiro (Oct 27 2019 at 12:02)</a>:</h4>
<p>the number of proofs grows exponentially</p>

<a name="179168203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168203">Juho Kupiainen (Oct 27 2019 at 12:03)</a>:</h4>
<p>Well, it of course depends on the language. There's always some weird language where it works, of course. Because you can always put the computation on the checker side.</p>

<a name="179168206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168206">Mario Carneiro (Oct 27 2019 at 12:03)</a>:</h4>
<p>There actually was a competition of sorts to find the shortest proofs of a bunch of basic propositional logic problems, and many of them were found by exhaustive search, but you hit a wall at about 18 steps</p>

<a name="179168260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168260">Juho Kupiainen (Oct 27 2019 at 12:05)</a>:</h4>
<p>I think a big problem in computer systems is fragility, that is, systems work great, until they don't.</p>

<a name="179168307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168307">Juho Kupiainen (Oct 27 2019 at 12:06)</a>:</h4>
<p>Like, some tactic might work great, until it doesn't. And then the next best thing is basically to go through proofs in order of length.</p>

<a name="179168308"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168308" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168308">Mario Carneiro (Oct 27 2019 at 12:06)</a>:</h4>
<p>Whenever you are solving an exponential problem it always looks like that. You might push the wall back a few steps with a different formalism, but you can't eliminate it unless your language is trivial</p>

<a name="179168311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168311">Juho Kupiainen (Oct 27 2019 at 12:06)</a>:</h4>
<p>Having reasonable solutions there in between is where the improvements in systems happen.</p>

<a name="179168330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168330">Mario Carneiro (Oct 27 2019 at 12:07)</a>:</h4>
<p>machine learning is all about trying to solve these problems by finding structure in the search (something better than "shorter is better")</p>

<a name="179168331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168331">Juho Kupiainen (Oct 27 2019 at 12:07)</a>:</h4>
<p>I mean reasonable solutions for practical problems, you obviously can't have reasonable solutions for all problems.</p>

<a name="179168417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168417">Juho Kupiainen (Oct 27 2019 at 12:09)</a>:</h4>
<p>I think trying to build something between the two ends of search proofs by length and a few tactics that solve simple problems would be to work on trying to "dig a tunnel" from both ends, trying to make searching proofs in order of length better while making tactics better.</p>

<a name="179168476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168476">Mario Carneiro (Oct 27 2019 at 12:10)</a>:</h4>
<p>that at most doubles the distance to the wall</p>

<a name="179168532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168532">Juho Kupiainen (Oct 27 2019 at 12:12)</a>:</h4>
<p>I mean I just think it could provide ideas to look at things from many angles.</p>

<a name="179168537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168537">Kevin Buzzard (Oct 27 2019 at 12:12)</a>:</h4>
<blockquote>
<p>I'm just wondering if we are better or worse off having all these different systems. Should we all just stick to one and build a good library in it</p>
</blockquote>
<p>Of course the problem with this is that everyone thinks that everybody else should be using their system. It also all depends on what your goals are.</p>
<p>The work of Rob Lewis and his collaborators, and the perfectoid project, are attempts to prove that Lean is capable of doing modern mathematics which "proper mathematicians" are interested in (this is a tongue-in-cheek phrase referring to people doing stuff like number theory/algebra/analysis/geometry etc in maths departments, as opposed to all the category theory / type theory people working on foundations). Sebastian Gouezel has produced work in Isabelle/HOL which is also mainstream mathematics done in a theorem prover. But we are in the minority here -- most work done in these systems is not an attempt to do modern mathematics on a computer. For example my impression is that Agda is a fascinating experiment to see what kinds of fancy inductive-recursive-inductive types one can get away with whilst preserving soundness. That's great, but guess what? The perfectoid project <em>does not contain one single instance of the <code>inductive</code> command</em>. Us "proper mathematicians" just need structures. </p>
<blockquote>
<p>or is there some fundamental reasons why one is better than another.</p>
</blockquote>
<p>People can certainly argue about this point all day. I think that dependent type theory is currently our best option for "all of pure mathematics" and I think that Lean is currently our best option for dependent type theory, but plenty of people have plenty of other opinions. The reason I like my opinion best is that I am one of few "proper mathematicians" who is even in a position to have an opinion, and when I hear other people talking about what they think mathematics is and how it fits best into their systems, I often find that the underlying disagreement is actually the question of what mathematics <em>is</em>. I am attempting to represent the generic pure mathematician who works in a generic mathematics department. </p>
<p>As is the case for programming languages in general, the best tool for the job depends very heavily on what the job is. An analogue of your question might be "I'm just wondering if we are better of worse off having all these different programming languages -- C, Rust, Java, Python, x86 assembly. Should we all just stick to one?"</p>

<a name="179168864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168864">Juho Kupiainen (Oct 27 2019 at 12:23)</a>:</h4>
<p>To me, as someone who isn't that knowledgeable of foundational systems, it seems like a pretty practical way to describe a foundational system would be a list of axtioms that state that a computer program terminates. The lengths of various proofs and relative (between theorems) performance of the checker would be determined by which axioms you add. You could make a checker that both runs a computation to check for the proof and at the same time searches for proofs that the computation terminates so as to not have to do the computation. And I guess you can also describe the axiomatic content this way as well.</p>

<a name="179168990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean%20vs%20other%20systems/near/179168990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/78564Leanvsothersystems.html#179168990">Chris Hughes (Oct 27 2019 at 12:27)</a>:</h4>
<blockquote>
<p>To me, as someone who isn't that knowledgeable of foundational systems, it seems like a pretty practical way to describe a foundational system would be a list of axtioms that state that a computer program terminates. The lengths of various proofs and relative (between theorems) performance of the checker would be determined by which axioms you add. And of course you can describe the axiomatic content this way as well.</p>
</blockquote>
<p>I guess this list of axioms are more or less the rules for recursors of inductive types.</p>


{% endraw %}

{% include archive_update.html %}