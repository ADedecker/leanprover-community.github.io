---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/96988abrfl.html
---

## Stream: [general](index.html)
### Topic: [`a = b := rfl`](96988abrfl.html)

---


{% raw %}
#### [ Kevin Buzzard (Aug 12 2018 at 13:48)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994333):
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">xena</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kn">theorem</span> <span class="n">easy</span> <span class="o">:</span> <span class="n">xena</span><span class="bp">.</span><span class="n">zero</span> <span class="bp">=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>


<p>I usually stop thinking when it's got to this point -- my zeros are equal by definition and we're done. Yesterday, perhaps inspired by Ed's barrage, which reminded me how little I still knew about some aspects of Lean, I decided to dig a bit deeper into this easy theorem. I tried to take it apart completely given what I knew.</p>
<p>Setting <code>pp.all true</code> shows me that my goal is</p>
<div class="codehilite"><pre><span></span>@eq.{1} nat xena.zero nat.zero
</pre></div>


<p>which is fine. My first question is how <code>rfl</code> is proving this. I'm assuming that the output of <code>#print rfl</code> is the code that's being run here. </p>
<div class="codehilite"><pre><span></span>@[pattern]
def rfl : ∀ {α : Sort u} {a : α}, @eq.{u} α a a :=
λ {α : Sort u} {a : α}, @eq.refl.{u} α a
</pre></div>


<p>I have some things to solve here. I will set <code>u=1</code> for the universe, and now for the <code>{}</code> brackets I need to solve for <code>α</code> and <code>a</code>. Well <code>α</code> is easy, it's <code>nat</code>, but for <code>a</code> I seem to have two choices. <code>a = xena.zero</code> and <code>a=nat.zero</code> and neither of them are on the face of it right. One seems to create a term of type <code>@eq.{1} nat xena.zero xena.zero</code> and the other a term of type <code>@eq.{1} nat nat.zero nat.zero</code>. </p>
<p>Whichever one Lean chooses, it -- by which I mean <em>something</em> -- is now faced with the problem that I am claiming that two types are equal when they are not literally the same thing. The same what? The same expressions? </p>
<p>Proving that these two types are equal (<code>@eq.{1} nat xena.zero nat.zero</code> and <code>@eq.{1} nat a a</code> for whatever <code>rfl</code> decided to let <code>a</code> be -- how do I find out, by the way?) seems to be a case of proving <code>xena.zero</code> and <code>nat.zero</code> are the same term of type <code>nat</code>. So Lean has somehow now reduced to checking that these terms are the same. But the expressions (if they are expressions) are presumably different. </p>
<p>What presumably happens next is that Lean has to try and check that both terms evaluate to the same term of type <code>nat</code>. Now <code>nat.zero</code> seems like it's somehow "fully evaluated" -- <code>#print nat.zero</code> indicates that it's a constructor of <code>nat</code> and we somehow can't get any further. On the other hand, <code>#print xena.zero</code> seems to indicate that more work needs to be done. The parser, or something, has interpreted <code>0 : nat</code> as <code>@has_zero.zero.{0} nat nat.has_zero</code>. I can't quite work out how -- <code>0</code> does not seem to be notation. I think Mario once told me that it was the "number literal parser" which changes <code>0</code> to <code>@has_zero.zero.{0} nat nat.has_zero</code>. So...<em>something</em> is now faced with the of verifying that <code>@has_zero.zero.{0} nat nat.has_zero</code> evaluates to <code>nat.zero</code>. I can understand that <code>nat.has_zero</code> has magically appeared because the type class inference system produced it, and looking at the definition of <code>has_zero.zero</code> I can see that this term evaluates to <code>nat.has_zero.zero</code>. This is a funny...term? expr? because I can't <code>#print</code> it even though I can <code>#check</code> it. I can <code>#reduce</code> it but I feel like this might be cheating -- I can <code>#reduce xena.zero</code> and everything gets unravelled. What is <code>#reduce</code> doing here? Is this all the alpha-equivalence beta-reduction stuff? </p>
<p>Feeling like <code>#reduce nat.has_zero.zero</code> was cheating, I right-clicked on it -- I don't know any other way of seeing the definition, because <code>#print</code> doesn't work and <code>#reduce</code> does too much. Is there a way to investivate more carefully what type class inference did here? Right-clicking takes me to core Lean where I find <code>instance : has_zero nat := ⟨nat.zero⟩</code>, so indeed it was <code>nat.zero</code> after all.</p>
<p>Whose job am I doing here? What does all this have to do with <code>expr</code>s and <code>pexpr</code>s?</p>

#### [ Mario Carneiro (Aug 12 2018 at 13:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994536):
<p>You are doing the job of the kernel here, which is unfortunately not so verbose when it does things</p>

#### [ Mario Carneiro (Aug 12 2018 at 13:59)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994590):
<blockquote>
<p>for whatever rfl decided to let a be -- how do I find out, by the way?</p>
</blockquote>
<p>If you <code>#print easy</code> with <code>pp.all</code> you will see <code>@rfl.{1} nat xena.zero</code>, so rfl chose the LHS, forcing it to check <code>@eq.{1} nat xena.zero xena.zero =?= @eq.{1} nat xena.zero nat.zero</code>.</p>

#### [ Kevin Buzzard (Aug 12 2018 at 14:03)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994704):
<p>I've seen you write <code>=?=</code> many times here, and I still don't know what it means. I understand that the job Lean has to somehow do is to check LHS = RHS. What does <code>=?=</code> indicate though?</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:03)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994706):
<p>It is a defeq "goal"</p>

#### [ Kenny Lau (Aug 12 2018 at 14:03)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994709):
<p>so a sort of unification, I guess</p>

#### [ Kevin Buzzard (Aug 12 2018 at 14:04)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994748):
<p>And what thing solves this goal? The kernel? Can we be more precise? Is it anything to do with the unifier or elaborator or something?</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:04)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994751):
<p>yes, it is used in unification and also pure defeq checking</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:04)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994758):
<p>the elaborator also solves this problem (both the kernel and the elaborator have slightly different approaches to solving defeq problems)</p>

#### [ Kevin Buzzard (Aug 12 2018 at 14:05)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994760):
<p>Right, I think I've also seen it in the context <code>?m_1 =?= nat</code> with metavariables. That's the same usage?</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:05)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994771):
<p>yes</p>

#### [ Kevin Buzzard (Aug 12 2018 at 14:05)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994773):
<p>So at any stage in time, does Lean have a list of <code>A =?= B</code> goals?</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:07)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994827):
<p>somewhere deep in the kernel, yes, more or less, although that list is spread over the recursive calls to <code>is_def_eq</code> rather than explicitly maintained</p>

#### [ Kevin Buzzard (Aug 12 2018 at 14:11)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131994964):
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm">- Succeeds if `t` and `s` can be unified using the given transparency setting. -/</span>
<span class="n">meta</span> <span class="kn">constant</span> <span class="n">unify</span> <span class="o">(</span><span class="n">t</span> <span class="n">s</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">md</span> <span class="o">:=</span> <span class="n">semireducible</span><span class="o">)</span> <span class="o">(</span><span class="n">approx</span> <span class="o">:=</span> <span class="n">ff</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span>
<span class="c">/-</span><span class="cm">- Similar to `unify`, but it treats metavariables as constants. -/</span>
<span class="n">meta</span> <span class="kn">constant</span> <span class="n">is_def_eq</span> <span class="o">(</span><span class="n">t</span> <span class="n">s</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">(</span><span class="n">md</span> <span class="o">:=</span> <span class="n">semireducible</span><span class="o">)</span> <span class="o">(</span><span class="n">approx</span> <span class="o">:=</span> <span class="n">ff</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span>
</pre></div>


<p>The fact that these are constants somehow indicates that they are not written in Lean but perhaps in C++. How does Lean know that these are any different to <code>meta constant foo : nat</code> ? And what told Lean to use <code>is_def_eq</code>? Again is this something written in <code>C++</code>? I don't want to read any <code>C++</code> at this point, but I'd like to be able to get as far as it (hence at some point I'm going to have to read some tactic code, but not today)</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:12)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995011):
<p>Here's the process for checking defeq:</p>
<ul>
<li>Since <code>eq</code> is an axiomatic constant, it can't be unfolded, so it checks that the parts are equal, reducing to <code>xena.zero =?= nat.zero</code>.</li>
<li>Since <code>xena.zero</code> has greater definitional height, and <code>nat.zero</code> is a constant anyway, it unfolds <code>xena.zero := @has_zero.zero.{0} nat nat.has_zero</code>.</li>
<li><code>has_zero.zero</code> is a builtin projection, which I'm not sure how lean handles - if it is unfolded you see a macro for the projection and it's tricky to unfold these. For now let's just pretend that this term is an axiomatic constant.</li>
<li>Since <code>has_zero.zero</code> is a projection, it tries to reduce the major premise, which is <code>nat.has_zero</code>.</li>
<li>Since <code>nat.has_zero</code> is a definition, it is unfolded, to <code>@has_zero.mk.{0} nat nat.zero</code>.</li>
<li>Since <code>has_zero.mk</code> is a constructor, unfolding stops.</li>
<li>Now we have <code>@has_zero.zero.{0} nat (@has_zero.mk.{0} nat nat.zero)</code>, which is a projection applied to a constructor, so it iota reduces to <code>nat.zero</code>.</li>
<li>We now have to show <code>nat.zero =?= nat.zero</code>, so we are done.</li>
</ul>

#### [ Mario Carneiro (Aug 12 2018 at 14:13)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995021):
<p>Those constants are written in C++; they hook into the elaborator code for defeq and unification</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:15)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995076):
<p>They are not any different from other meta constants, but when you <code>#eval</code> a meta constant it checks if it has builtin code for the constant</p>
<div class="codehilite"><pre><span></span>meta constant foo : nat
#eval foo
-- code generation failed, VM does not have code for &#39;foo&#39;
#eval (undefined : nat)
-- undefined
</pre></div>

#### [ Mario Carneiro (Aug 12 2018 at 14:17)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995164):
<p>the <code>DECLARE_VM_BUILTIN</code> function in C++ hooks a C++ function to a meta constant by name, so if you want to find out what function handles <code>unify</code>, say, you can just look for this in the code</p>

#### [ Kevin Buzzard (Aug 12 2018 at 14:18)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995218):
<p>Is there a formal definition of "axiomatic constant"? I thought <code>eq</code> was a Pi type and <code>nat.zero</code> was a constructor. They're also both constants somehow?</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:19)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995229):
<p><code>eq</code> has <em>type</em> <code>Π {α : Sort u}, α → α → Prop</code> but it has no <em>definition</em></p>

#### [ Mario Carneiro (Aug 12 2018 at 14:20)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995283):
<p>similarly <code>nat.zero : nat</code> but <code>nat.zero :=</code> nothing</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:21)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995306):
<p>yes there is a formal definition. These are both constants introduced through the declaration of an inductive type. If you recall each inductive type comes axiomatically with a type (being declared), a list of constructors, and a recursor</p>

#### [ Kevin Buzzard (Aug 12 2018 at 14:21)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995321):
<p>Yes, inductive types I'm completely happy with.</p>

#### [ Kevin Buzzard (Aug 12 2018 at 14:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995326):
<p>I see. <code>#print eq</code> and <code>#print nat.zero</code> both return answers with no <code>:=</code> in</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995369):
<p>the important part is that this is a way to introduce constants that have no definition</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:22)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995373):
<p>all constants are either axiomatic from an inductive, declared via <code>axiom</code> or <code>constant</code>, or are definitions</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:23)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995382):
<p>or are <code>quot</code>, <code>quot.mk</code>, <code>quot.lift</code> or <code>quot.sound</code> which are special</p>

#### [ Kevin Buzzard (Aug 12 2018 at 14:23)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995385):
<p>So the type, the constructors and the recursor for an inductive type are all constants?</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:23)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995389):
<p>yes</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:24)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995442):
<p>Above I pretended that the projection of a structure is also a constant, but I'm not sure if lean unfolds that too</p>

#### [ Kevin Buzzard (Aug 12 2018 at 14:24)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995451):
<p>I'm happy with the explanation that "it's iota reduction"</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:25)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995462):
<p>technically the projections are defined in terms of the recursor, with a major premise like <code>(\lam x y z, y)</code>, and it's an iota reduction and some betas to get to where I said</p>

#### [ Kevin Buzzard (Aug 12 2018 at 14:26)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995505):
<p><code>#print has_zero.zero</code> seems to give out some sort of junk answer -- it has no content somehow</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:26)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995507):
<p><code>has_zero.zero</code> is apparently defined in terms of a macro, also called <code>has_zero.zero</code></p>

#### [ Kevin Buzzard (Aug 12 2018 at 14:27)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995517):
<p>Oh so that's a different <code>has_zero.zero</code> in the output?</p>

#### [ Kenny Lau (Aug 12 2018 at 14:27)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995518):
<p>so basically <code>eq</code> is a constant and <code>eq a a</code> for every <code>a</code> is an axiom</p>

#### [ Kevin Buzzard (Aug 12 2018 at 14:28)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995557):
<p><code>eq a a</code> is a proposition and I know a way of constructing a term of that type</p>

#### [ Kenny Lau (Aug 12 2018 at 14:29)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995559):
<p>ok</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:35)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995739):
<p>ah, unfolding success</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">tactic</span>
<span class="n">run_cmd</span> <span class="n">do</span>
  <span class="n">d</span> <span class="err">←</span> <span class="n">get_decl</span> <span class="bp">``</span><span class="n">has_zero</span><span class="bp">.</span><span class="n">zero</span><span class="o">,</span>
  <span class="n">expr</span><span class="bp">.</span><span class="n">lam</span> <span class="n">n</span> <span class="n">u</span> <span class="n">bi</span> <span class="n">v</span> <span class="err">←</span> <span class="n">return</span> <span class="n">d</span><span class="bp">.</span><span class="n">value</span><span class="o">,</span>
  <span class="n">x</span> <span class="err">←</span> <span class="n">mk_local&#39;</span> <span class="n">n</span> <span class="n">u</span> <span class="n">bi</span><span class="o">,</span>
  <span class="n">expr</span><span class="bp">.</span><span class="n">lam</span> <span class="n">n</span> <span class="n">u</span> <span class="n">bi</span> <span class="n">v</span> <span class="err">←</span> <span class="n">return</span> <span class="o">(</span><span class="n">v</span><span class="bp">.</span><span class="n">instantiate_var</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">c</span> <span class="err">←</span> <span class="n">mk_local&#39;</span> <span class="n">n</span> <span class="n">u</span> <span class="n">bi</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">v</span><span class="bp">.</span><span class="n">instantiate_var</span> <span class="n">c</span><span class="o">,</span>
  <span class="n">trace</span> <span class="n">v</span><span class="o">,</span>
  <span class="c1">-- [has_zero.zero c]</span>
  <span class="n">whnf</span> <span class="n">v</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span>
<span class="c1">-- @has_zero.rec.{u+1 u} α (λ [c : has_zero.{u} α], α) (λ (zero : α), zero) c</span>
</pre></div>

#### [ Mario Carneiro (Aug 12 2018 at 14:36)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131995789):
<p>I am sure there is a function for opening the lambdas there at the beginning, but I've forgotten what it is</p>

#### [ Kevin Buzzard (Aug 12 2018 at 14:54)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996289):
<p>Aah this is what I want to see. I have an underlying question really, which is basically how I can do all the unfolding which I did "on paper" above, but step by step, within Lean.</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996368):
<p>the key step there is <code>whnf</code></p>

#### [ Mario Carneiro (Aug 12 2018 at 14:57)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996373):
<p>which will unfold a term until it hits a constructor, a pi, or other constant at head position</p>

#### [ Mario Carneiro (Aug 12 2018 at 14:58)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996413):
<p>the name means "weak head normal form"</p>

#### [ Kevin Buzzard (Aug 12 2018 at 15:07)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996658):
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">xena</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="kn">open</span> <span class="n">tactic</span>
<span class="n">run_cmd</span> <span class="n">do</span>
  <span class="n">whnf</span> <span class="bp">``</span><span class="n">xena</span><span class="bp">.</span><span class="n">zero</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span> <span class="c1">-- fails because I wrote nonsense</span>
</pre></div>


<p>How do I get to the <code>expr</code>? Ooh this might be in PIL.</p>

#### [ Mario Carneiro (Aug 12 2018 at 15:08)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996713):
<p>that's what the first lines are for</p>

#### [ Mario Carneiro (Aug 12 2018 at 15:09)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996726):
<p><code>get_decl</code> gets a declaration, from which you can get the value with <code>d.value</code></p>

#### [ Mario Carneiro (Aug 12 2018 at 15:10)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996786):
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">tactic</span>
<span class="n">run_cmd</span> <span class="n">do</span>
  <span class="n">d</span> <span class="err">←</span> <span class="n">get_decl</span> <span class="bp">``</span><span class="n">xena</span><span class="bp">.</span><span class="n">zero</span><span class="o">,</span>
  <span class="n">whnf</span> <span class="n">d</span><span class="bp">.</span><span class="n">value</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span> <span class="c1">-- nat.zero</span>
</pre></div>

#### [ Mario Carneiro (Aug 12 2018 at 15:12)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996842):
<p>alternatively, you could just construct the expression <code>xena.zero</code> and reduce that, rather than getting the definition of <code>xena.zero</code> to reduce as I just did</p>
<div class="codehilite"><pre><span></span><span class="n">run_cmd</span> <span class="n">do</span>
  <span class="n">e</span> <span class="err">←</span> <span class="n">mk_const</span> <span class="bp">``</span><span class="n">xena</span><span class="bp">.</span><span class="n">zero</span><span class="o">,</span>
  <span class="n">whnf</span> <span class="n">e</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span> <span class="c1">-- nat.zero</span>
</pre></div>

#### [ Mario Carneiro (Aug 12 2018 at 15:12)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996843):
<p><code>whnf `(xena.zero) &gt;&gt;= trace</code> also works</p>

#### [ Kevin Buzzard (Aug 12 2018 at 15:13)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996853):
<p>I don't see <code>nat.zero</code> -- I just see <code>0</code>. This is the pretty printer folding stuff up again, I guess?</p>

#### [ Mario Carneiro (Aug 12 2018 at 15:13)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996855):
<p>I have <code>pp.all</code> enabled</p>

#### [ Kevin Buzzard (Aug 12 2018 at 15:13)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996856):
<p>got it -- so have I now</p>

#### [ Mario Carneiro (Aug 12 2018 at 15:14)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996901):
<p>right, the pretty printer prints <code>nat.zero</code> as <code>0</code>. Which is actually kind of confusing since that would usually be reserved for <code>@has_zero.zero _ _</code></p>

#### [ Kevin Buzzard (Aug 12 2018 at 15:14)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996904):
<p>So it's all happening too fast -- <code>whnf</code> turns <code>xena.zero</code> straight into <code>nat.zero</code> like <code>#reduce</code>?</p>

#### [ Mario Carneiro (Aug 12 2018 at 15:15)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996916):
<p>right, <code>whnf</code> unfolds definitions until it reaches something which isn't a definition</p>

#### [ Mario Carneiro (Aug 12 2018 at 15:15)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996926):
<p>it is similar to <code>#reduce</code>, but it doesn't reduce everything, only stuff at the head</p>

#### [ Mario Carneiro (Aug 12 2018 at 15:16)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996972):
<p>for example:</p>
<div class="codehilite"><pre><span></span><span class="n">run_cmd</span> <span class="n">whnf</span> <span class="bp">`</span><span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">xena</span><span class="bp">.</span><span class="n">zero</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span> <span class="c1">-- λ (x : nat), xena.zero</span>
</pre></div>

#### [ Kevin Buzzard (Aug 12 2018 at 15:17)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996982):
<p><code>d.value</code> seems to have type <code>expr bool.tt</code>. What's that bool doing there?</p>

#### [ Mario Carneiro (Aug 12 2018 at 15:17)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131996986):
<p>the idea is that if <code>e1</code> unfolds to <code>sum A B</code> and <code>e2</code> unfolds to <code>prod C D</code>, then it is impossible for <code>e1 == e2</code></p>

#### [ Mario Carneiro (Aug 12 2018 at 15:18)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997025):
<p>even if <code>A B C D</code> are not completely unfolded</p>

#### [ Kevin Buzzard (Aug 12 2018 at 15:18)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997026):
<p>What does <code>==</code> mean?</p>

#### [ Mario Carneiro (Aug 12 2018 at 15:18)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997028):
<p>defeq</p>

#### [ Kevin Buzzard (Aug 12 2018 at 15:19)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997030):
<p>It's different to <code>=</code> because if two things are equal they must have the same type.</p>

#### [ Mario Carneiro (Aug 12 2018 at 15:19)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997038):
<p>it's not heq, I should use a better notation</p>

#### [ Kevin Buzzard (Aug 12 2018 at 15:19)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997041):
<p>Oh I see</p>

#### [ Mario Carneiro (Aug 12 2018 at 15:19)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997042):
<p>defeq things have to have the same type btw</p>

#### [ Kevin Buzzard (Aug 12 2018 at 15:19)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997043):
<p>great</p>

#### [ Mario Carneiro (Aug 12 2018 at 15:20)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997088):
<p><code>expr tt</code> is <code>expr</code> and <code>expr ff</code> is <code>pexpr</code></p>

#### [ Kevin Buzzard (Aug 12 2018 at 15:20)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997092):
<p>Oh!</p>

#### [ Mario Carneiro (Aug 12 2018 at 15:20)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997094):
<p>they have the same definition as inductive types so this saves some duplication</p>

#### [ Kevin Buzzard (Aug 12 2018 at 15:20)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997095):
<p>Oh these are optional paramaters</p>

#### [ Kevin Buzzard (Aug 12 2018 at 15:25)](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/%60a%20%3D%20b%20%3A%3D%20rfl%60/near/131997237):
<div class="codehilite"><pre><span></span><span class="n">run_cmd</span> <span class="n">do</span>
  <span class="n">e</span> <span class="err">←</span> <span class="n">mk_const</span> <span class="bp">``</span><span class="n">xena</span><span class="bp">.</span><span class="n">zero</span><span class="o">,</span>
  <span class="n">return</span> <span class="n">e</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span>
</pre></div>


<p>woo I wrote something that worked.</p>


{% endraw %}
