---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/82242CryptographicHashing.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html">Cryptographic Hashing</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="185267826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185267826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185267826">Tim Daly (Jan 09 2020 at 23:26)</a>:</h4>
<p>Axiom will include proofs (presumably validated by Lean) for its algorithms. Ideally, when a computation is requested from Lean for a GCD, the result as well as a GCD algorithm proof is returned. Lean can then verify that the proof is valid. But it is computationally more efficient if both Axiom and Lean use a cryptographic hash, such as SHA1. That way the proof doesn't need to be 'reproven', only the hash computation over the proof text needs to be performed. Hashes are blazingly fast. This allows proofs to be exchanged without the need to re-run the proof mechanism. Since a large computation request from Lean might involve many algorithms there would be considerable overhead to recompute each proof. A hash simplifies the issue yet provides proof integrity.</p>


{% endraw %}

{% include archive_update.html %}