---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/82242CryptographicHashing.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html">Cryptographic Hashing</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="185267826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185267826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185267826">Tim Daly (Jan 09 2020 at 23:26)</a>:</h4>
<p>Axiom will include proofs (presumably validated by Lean) for its algorithms. Ideally, when a computation is requested from Lean for a GCD, the result as well as a GCD algorithm proof is returned. Lean can then verify that the proof is valid. But it is computationally more efficient if both Axiom and Lean use a cryptographic hash, such as SHA1. That way the proof doesn't need to be 'reproven', only the hash computation over the proof text needs to be performed. Hashes are blazingly fast. This allows proofs to be exchanged without the need to re-run the proof mechanism. Since a large computation request from Lean might involve many algorithms there would be considerable overhead to recompute each proof. A hash simplifies the issue yet provides proof integrity.</p>

<a name="185272854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185272854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185272854">Jason Rute (Jan 10 2020 at 00:49)</a>:</h4>
<p>Reid was once telling me about some theoretical elliptic curve cryptographic hash mechanism for proofs.  I’m having trouble remembering the main idea, much less the details. But in you case, is the idea that Axiom (or Lean) would store the hashes of previously checked proofs, so if a hash is in the list of checked hashes, it could safely avoid checking it again?  Why hash the proof?  Couldn’t you store (or hash) the theorem statement itself?  Maybe I am misunderstanding.</p>

<a name="185280116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185280116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185280116">Jalex Stark (Jan 10 2020 at 03:48)</a>:</h4>
<p>I think you want the notion of a probabilistically checkable proof?</p>

<a name="185284911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185284911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185284911">Johan Commelin (Jan 10 2020 at 06:05)</a>:</h4>
<p><span class="user-mention" data-user-id="223495">@Tim Daly</span> Note that SHA1 is getting less and less secure every day. Just this week people announced chosen prefix collision attacks.</p>

<a name="185284981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185284981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185284981">Johan Commelin (Jan 10 2020 at 06:07)</a>:</h4>
<p>Also, I don't see why you can't just ask Lean: "Hey, do you have some precompiled binary of this theorem? Please answer with 1 bit".</p>

<a name="185285117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185285117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185285117">Tim Daly (Jan 10 2020 at 06:10)</a>:</h4>
<p>You could simply character compare the prior proof given to Axiom with the proof sent by Axiom. Of course, that assumes you stored the proof. Hashes are generally smaller. Either solution works fine. It's a question of scale. If Axiom uses 100 algorithms to perform a computation and sends 100 proofs along with the answer it pays to be efficient.</p>

<a name="185288365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185288365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185288365">Tim Daly (Jan 10 2020 at 07:33)</a>:</h4>
<p>So instead of shipping whole proof scripts back and forth, all that would be needed is a hash code. The proof script still exists but the hash code can be a table lookup. If the lookup fails for any reason, then request the associated proof script to re-validate the proof. This is especially useful if Lean is a network server. It just keeps a table of hashes of proofs it has validated.</p>


{% endraw %}

{% include archive_update.html %}