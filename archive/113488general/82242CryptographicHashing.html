---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113488general/82242CryptographicHashing.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html">Cryptographic Hashing</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="185267826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185267826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185267826">Tim Daly (Jan 09 2020 at 23:26)</a>:</h4>
<p>Axiom will include proofs (presumably validated by Lean) for its algorithms. Ideally, when a computation is requested from Lean for a GCD, the result as well as a GCD algorithm proof is returned. Lean can then verify that the proof is valid. But it is computationally more efficient if both Axiom and Lean use a cryptographic hash, such as SHA1. That way the proof doesn't need to be 'reproven', only the hash computation over the proof text needs to be performed. Hashes are blazingly fast. This allows proofs to be exchanged without the need to re-run the proof mechanism. Since a large computation request from Lean might involve many algorithms there would be considerable overhead to recompute each proof. A hash simplifies the issue yet provides proof integrity.</p>

<a name="185272854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185272854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185272854">Jason Rute (Jan 10 2020 at 00:49)</a>:</h4>
<p>Reid was once telling me about some theoretical elliptic curve cryptographic hash mechanism for proofs.  I’m having trouble remembering the main idea, much less the details. But in you case, is the idea that Axiom (or Lean) would store the hashes of previously checked proofs, so if a hash is in the list of checked hashes, it could safely avoid checking it again?  Why hash the proof?  Couldn’t you store (or hash) the theorem statement itself?  Maybe I am misunderstanding.</p>

<a name="185280116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185280116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185280116">Jalex Stark (Jan 10 2020 at 03:48)</a>:</h4>
<p>I think you want the notion of a probabilistically checkable proof?</p>

<a name="185284911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185284911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185284911">Johan Commelin (Jan 10 2020 at 06:05)</a>:</h4>
<p><span class="user-mention" data-user-id="223495">@Tim Daly</span> Note that SHA1 is getting less and less secure every day. Just this week people announced chosen prefix collision attacks.</p>

<a name="185284981"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185284981" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185284981">Johan Commelin (Jan 10 2020 at 06:07)</a>:</h4>
<p>Also, I don't see why you can't just ask Lean: "Hey, do you have some precompiled binary of this theorem? Please answer with 1 bit".</p>

<a name="185285117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185285117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185285117">Tim Daly (Jan 10 2020 at 06:10)</a>:</h4>
<p>You could simply character compare the prior proof given to Axiom with the proof sent by Axiom. Of course, that assumes you stored the proof. Hashes are generally smaller. Either solution works fine. It's a question of scale. If Axiom uses 100 algorithms to perform a computation and sends 100 proofs along with the answer it pays to be efficient.</p>

<a name="185288365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185288365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185288365">Tim Daly (Jan 10 2020 at 07:33)</a>:</h4>
<p>So instead of shipping whole proof scripts back and forth, all that would be needed is a hash code. The proof script still exists but the hash code can be a table lookup. If the lookup fails for any reason, then request the associated proof script to re-validate the proof. This is especially useful if Lean is a network server. It just keeps a table of hashes of proofs it has validated.</p>

<a name="185290098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185290098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185290098">Tim Daly (Jan 10 2020 at 08:13)</a>:</h4>
<p>Indeed, one can get ever more clever. One could hash all of the hashes for all of the proven algorithms into one hash. Then all that needs to be exchanged for, say, a Groebner basis computation would be a single meta-hash.</p>

<a name="185290175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185290175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185290175">Tim Daly (Jan 10 2020 at 08:15)</a>:</h4>
<p>So there would be a single meta-hash for each algorithm, one for GCD, one for Groebner, etc. It is all very efficient and can scale. The server doesn't need to store proof scripts since if the hash lookup fails, it just asks the client for the proof.</p>

<a name="185291969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185291969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185291969">Johan Commelin (Jan 10 2020 at 08:52)</a>:</h4>
<p>I've been thinking a bit about Unison (<a href="http://unisonweb.org" target="_blank" title="http://unisonweb.org">unisonweb.org</a>) recently. It's a type-theoretic functional programming language based on content addressable storage. So everything is hashed and then stored. Renaming a function is a 1-line change in the metadata, and doesn't break any code. You no longer store your code in files, but in this content addressable store managed by Unison. If you want to read the definition of a function, the system renders a textual representation for you, based on the content of some hashes + the names in the metadata. So you don't actually see the hashes.<br>
It should make things like distributed code, reproducibility, refactoring code, etc... easier.</p>

<a name="185291988"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Cryptographic%20Hashing/near/185291988" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/82242CryptographicHashing.html#185291988">Johan Commelin (Jan 10 2020 at 08:53)</a>:</h4>
<p>I wonder if a similar system might be usable for an ITP as well. It seems closely related to what <span class="user-mention" data-user-id="223495">@Tim Daly</span> is suggesting</p>


{% endraw %}

{% include archive_update.html %}