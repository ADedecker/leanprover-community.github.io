---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/58200bundlingmulhoms.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html">bundling mul_homs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="171137073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137073">Kevin Buzzard (Jul 18 2019 at 04:21)</a>:</h4>
<p>Mathlib has the unbundled <code>is_mul_hom</code> class (a Prop), and then it has <code>mul_equiv</code> which references this unbundled <code>is_mul_hom</code>. If we were to bundle <code>mul_hom</code>s, how would we define <code>mul_equiv</code>?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">γ</span><span class="o">]</span>
<span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">P</span><span class="o">]</span>

<span class="c">/-</span><span class="cm"> Mathlib:</span>

<span class="cm">class is_mul_hom {α β : Type*} [has_mul α] [has_mul β] (f : α → β) : Prop :=</span>
<span class="cm">(map_mul : ∀ x y, f (x * y) = f x * f y)</span>

<span class="cm">structure mul_equiv (α β : Type*) [has_mul α] [has_mul β] extends α ≃ β :=</span>
<span class="cm">(hom : is_mul_hom to_fun)</span>

<span class="cm">notation ≃* for mul_equiv, proved to be reflexive, symmetric and transitive</span>

<span class="cm">-- not yet found a use for this instance. Should `is_mul_hom` be a structure?</span>
<span class="cm">instance (h : α ≃* β) : is_mul_hom h.to_equiv := h.hom</span>

<span class="cm">-/</span>

<span class="kn">namespace</span> <span class="n">mul</span>

<span class="c">/-</span><span class="cm">- bundled homs FTW -/</span>
<span class="kn">structure</span> <span class="n">hom</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- but now if I delete `is_mul_hom`, how do I define `mul_equiv`?</span>
<span class="c1">-- notation for homs</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="bp">→*</span> <span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="o">:=</span> <span class="n">hom</span>
</pre></div>

<a name="171137127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137127">Mario Carneiro (Jul 18 2019 at 04:22)</a>:</h4>
<p><code>mul_equiv A B extends equiv A B, mul_hom A B</code></p>

<a name="171137144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137144">Kevin Buzzard (Jul 18 2019 at 04:23)</a>:</h4>
<p>Should I be using old or new structures for these things?</p>

<a name="171137148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137148">Mario Carneiro (Jul 18 2019 at 04:23)</a>:</h4>
<p>old structures FTW</p>

<a name="171137150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137150">Kevin Buzzard (Jul 18 2019 at 04:23)</a>:</h4>
<p>Is what you call <code>mul_hom</code> what I called <code>mul.hom</code>?</p>

<a name="171137154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137154">Kevin Buzzard (Jul 18 2019 at 04:23)</a>:</h4>
<p>Did I name it wrong?</p>

<a name="171137158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137158">Mario Carneiro (Jul 18 2019 at 04:23)</a>:</h4>
<p>I don't think so</p>

<a name="171137201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137201">Mario Carneiro (Jul 18 2019 at 04:24)</a>:</h4>
<p><code>mul_hom A B</code> for me is the type of augmented functions from A to B</p>

<a name="171137203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137203">Kevin Buzzard (Jul 18 2019 at 04:24)</a>:</h4>
<p>but <code>mul.hom</code> has got a field <code>f</code> and <code>equiv</code> has got a field <code>to_fun</code> and these are supposed to be defeq and have the same name.</p>

<a name="171137204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137204">Mario Carneiro (Jul 18 2019 at 04:24)</a>:</h4>
<p>I don't see <code>mul.hom</code> in the example</p>

<a name="171137215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137215">Mario Carneiro (Jul 18 2019 at 04:25)</a>:</h4>
<p>Oh there it is</p>

<a name="171137216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137216">Kevin Buzzard (Jul 18 2019 at 04:25)</a>:</h4>
<p>I'm talking about my attempt to bundle homs.</p>

<a name="171137218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137218">Mario Carneiro (Jul 18 2019 at 04:25)</a>:</h4>
<p>I think that should be <code>mul_hom</code></p>

<a name="171137219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137219">Mario Carneiro (Jul 18 2019 at 04:25)</a>:</h4>
<p><code>mul</code> isn't a namespace</p>

<a name="171137266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137266">Mario Carneiro (Jul 18 2019 at 04:26)</a>:</h4>
<p><code>mul_hom</code> should have a field called <code>to_fun</code></p>

<a name="171137267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137267">Mario Carneiro (Jul 18 2019 at 04:26)</a>:</h4>
<p>so that <code>mul_equiv</code> works</p>

<a name="171137396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137396">Kevin Buzzard (Jul 18 2019 at 04:31)</a>:</h4>
<p><code>to_fun</code> is such a horrible name for a function. I guess its canonical name is the coercion so maybe it doesn't matter. Wait -- the map from <code>mul_equiv X Y</code> to <code>mul_hom X Y</code> -- that is no longer an instance, because <code>mul_hom</code> isn't a class. Is this still done with coercions somehow?</p>

<a name="171137439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137439">Mario Carneiro (Jul 18 2019 at 04:32)</a>:</h4>
<p>it's a function called <code>to_mul_hom</code></p>

<a name="171137444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137444">Mario Carneiro (Jul 18 2019 at 04:32)</a>:</h4>
<p>You can try using a coercion but this one tends to trigger rarely</p>

<a name="171137498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137498">Mario Carneiro (Jul 18 2019 at 04:34)</a>:</h4>
<p>given that the parent functions are always called <code>to_*</code>, <code>to_fun</code> seems to match that naming convention</p>

<a name="171138143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138143">Kevin Buzzard (Jul 18 2019 at 04:55)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">mul_hom</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">to_fun</span> <span class="n">y</span><span class="o">)</span>
</pre></div>


<p>Should this have a coercion to fun?</p>

<a name="171138188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138188">Mario Carneiro (Jul 18 2019 at 04:56)</a>:</h4>
<p>yes</p>

<a name="171138401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138401">Kevin Buzzard (Jul 18 2019 at 05:03)</a>:</h4>
<p>My <code>map_mul</code> is crappy:</p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="c">/-</span><span class="cm">- bundled homs FTW -/</span>
<span class="kn">structure</span> <span class="n">mul_hom</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">to_fun</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- notation for homs</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="bp">→*</span> <span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="o">:=</span> <span class="n">mul_hom</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">}</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">mul_hom.map_mul : ∀ (c : ?M_1 →* ?M_2) (x y : ?M_1), c.to_fun (x * y) = c.to_fun x * c.to_fun y</span>
<span class="cm">-- yeah but I want it to be the coercion, not `c.to_fun`</span>
<span class="cm">-/</span>
</pre></div>


<p>It has come out non-canonically. Am I supposed to be doing this:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul</span>
</pre></div>


<p>?</p>

<a name="171138447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138447">Mario Carneiro (Jul 18 2019 at 05:04)</a>:</h4>
<p>with the primes inverted</p>

<a name="171138449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138449">Kevin Buzzard (Jul 18 2019 at 05:04)</a>:</h4>
<p>So you're saying I need to change mathlib</p>

<a name="171138452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138452">Kevin Buzzard (Jul 18 2019 at 05:04)</a>:</h4>
<p>no</p>

<a name="171138456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138456">Kevin Buzzard (Jul 18 2019 at 05:05)</a>:</h4>
<p>you're saying I need to change my structure field's name.</p>

<a name="171138463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138463">Mario Carneiro (Jul 18 2019 at 05:05)</a>:</h4>
<p>yes</p>

<a name="171139112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171139112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171139112">Kevin Buzzard (Jul 18 2019 at 05:25)</a>:</h4>
<p>Should this</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">mul_equiv&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">B</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">equiv</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">mul_hom</span> <span class="n">A</span> <span class="n">B</span>
</pre></div>


<p>have a coercion to fun?</p>

<a name="171139294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171139294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171139294">Mario Carneiro (Jul 18 2019 at 05:31)</a>:</h4>
<p>yes</p>

<a name="171140149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140149">Kevin Buzzard (Jul 18 2019 at 05:56)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">γ</span><span class="o">]</span>
<span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">P</span><span class="o">]</span>

<span class="c1">-- Recall that the unbundled definition of a mul_hom</span>
<span class="c1">-- and the definition of a mul_equiv, with notation ≃*, are in mathlib.</span>

<span class="c">/-</span><span class="cm"> Mathlib:</span>

<span class="cm">-- in root namespace</span>
<span class="cm">class is_mul_hom {α β : Type*} [has_mul α] [has_mul β] (f : α → β) : Prop :=</span>
<span class="cm">(map_mul : ∀ x y, f (x * y) = f x * f y)</span>

<span class="cm">-- root namespace</span>
<span class="cm">structure mul_equiv (α β : Type*) [has_mul α] [has_mul β] extends α ≃ β :=</span>
<span class="cm">(hom : is_mul_hom to_fun)</span>

<span class="cm">notation ≃*, proved to be reflexive, symmetric and transitive (note: it is not a Prop)</span>
<span class="cm">-/</span>


<span class="c1">--. We will define</span>
<span class="c1">-- bundled homomorphisms of muls, with notation →*, and bundled</span>
<span class="c1">-- equivs, with notation ≃*&#39;</span>


<span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="c">/-</span><span class="cm">- bundled homs -/</span>
<span class="kn">structure</span> <span class="n">mul_hom</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">to_fun</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- notation for homs</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="bp">→*</span> <span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="o">:=</span> <span class="n">mul_hom</span>

<span class="c1">-- I want to think of a hom as a function sometimes</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm">- the statement that mul_homs preserve mul, in its canonical form -/</span>
<span class="n">def</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→*</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul&#39;</span>

<span class="c1">-- for structures like this you need to prove `id` and `comp` next.</span>
<span class="kn">namespace</span> <span class="n">mul_hom</span>

<span class="c">/-</span><span class="cm">- the identity is a mul_hom-/</span>
<span class="n">def</span> <span class="n">id</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→*</span> <span class="n">M</span> <span class="o">:=</span> <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span> <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">}</span>

<span class="c">/-</span><span class="cm">- composite of mul_homs is a mul_hom -/</span>
<span class="n">def</span> <span class="n">comp</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→*</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→*</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→*</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">m</span><span class="o">),</span>
  <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">map_mul</span> <span class="n">f</span><span class="o">,</span> <span class="n">map_mul</span> <span class="n">g</span><span class="o">]</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">mul_hom</span>

<span class="c">/-</span><span class="cm">- mul_equiv&#39; (bundled mul_equiv -- the name mul_equiv is currently nicked by unbundled mul_equiv) -/</span>
<span class="kn">structure</span> <span class="n">mul_equiv&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">B</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">equiv</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">mul_hom</span> <span class="n">A</span> <span class="n">B</span>

<span class="c1">-- notation for mul_equiv&#39;</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="o">:=</span> <span class="n">mul_equiv&#39;</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">M</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">mul_equiv&#39;</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">mul_equiv&#39;</span><span class="bp">.</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span>
<span class="o">:=</span> <span class="n">mul_equiv&#39;</span><span class="bp">.</span><span class="n">map_mul&#39;</span>

<span class="c1">-- now need reflexive, symmetric and transitive</span>

<span class="kn">namespace</span> <span class="n">mul_equiv&#39;</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="n">def</span> <span class="n">refl</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
<span class="bp">..</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">}</span>

<span class="c1">-- this one did not go so well.</span>
<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="n">def</span> <span class="n">symm</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n₁</span> <span class="n">n₂</span><span class="o">,</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective_of_left_inverse</span> <span class="n">h</span><span class="bp">.</span><span class="n">left_inv</span> <span class="k">begin</span>
    <span class="k">show</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">*</span> <span class="n">n₂</span><span class="o">))</span> <span class="bp">=</span>
    <span class="n">h</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="n">n₁</span> <span class="bp">*</span> <span class="n">h</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="n">n₂</span><span class="o">),</span> <span class="c1">-- annoying to have to `show`</span>
    <span class="n">rw</span> <span class="n">h</span><span class="bp">.</span><span class="n">right_inv</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">rfl</span><span class="o">,</span> <span class="c1">-- annoying to have to `convert`. This should surely just be rewrites.</span>
      <span class="n">exact</span> <span class="n">h</span><span class="bp">.</span><span class="n">right_inv</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="bp">.</span><span class="n">right_inv</span> <span class="bp">_</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">h</span><span class="bp">.</span><span class="n">to_equiv</span><span class="bp">.</span><span class="n">symm</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="n">def</span> <span class="n">trans</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">β</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">h2</span> <span class="o">(</span><span class="n">h1</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">))</span> <span class="bp">=</span> <span class="n">h2</span> <span class="o">(</span><span class="n">h1</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="n">h2</span> <span class="o">(</span><span class="n">h1</span> <span class="n">y</span><span class="o">),</span>
    <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h1</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span> <span class="n">h2</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">],</span>
  <span class="bp">..</span><span class="n">equiv</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h1</span><span class="bp">.</span><span class="n">to_equiv</span> <span class="n">h2</span><span class="bp">.</span><span class="n">to_equiv</span> <span class="o">}</span>

<span class="c1">-- an ≃*&#39; is a hom</span>
<span class="n">def</span> <span class="n">equiv&#39;</span><span class="bp">.</span><span class="n">to_hom</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_equiv</span><span class="o">,</span>
    <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">map_mul&#39;</span>
  <span class="o">}</span>

<span class="n">def</span> <span class="n">equiv&#39;</span><span class="bp">.</span><span class="n">inv_hom</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→*</span> <span class="n">M</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">to_equiv</span><span class="o">,</span>
  <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">map_mul</span>
  <span class="o">}</span>

<span class="kn">end</span> <span class="n">mul_equiv&#39;</span>
</pre></div>


<p><code>equiv'.symm</code> didn't go well but most of the other stuff looks OK to me</p>

<a name="171140287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140287">Mario Carneiro (Jul 18 2019 at 06:00)</a>:</h4>
<p>People will complain about the order of arguments to <code>comp</code></p>

<a name="171140312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140312">Johan Commelin (Jul 18 2019 at 06:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> You probably know this but <code>mul_hom.map_mul</code> should be a <em>lemma</em>, and it is a very good simp-lemma.</p>

<a name="171140315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140315">Mario Carneiro (Jul 18 2019 at 06:01)</a>:</h4>
<p>What's wrong with <code>symm</code>? It looks like that's the sort of thing that is mathematically substantive anyway</p>

<a name="171140359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140359">Johan Commelin (Jul 18 2019 at 06:02)</a>:</h4>
<p>In fact, that's the most important reason for bundling in the first place. That this is a simp-lemma that actually triggers.</p>

<a name="171140363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140363">Johan Commelin (Jul 18 2019 at 06:02)</a>:</h4>
<p>Also, we'll want simp-lemmas <code>id_apply</code> and <code>comp_apply</code>.</p>

<a name="171141338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171141338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171141338">Kevin Buzzard (Jul 18 2019 at 06:25)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> You probably know this but <code>mul_hom.map_mul</code> should be a <em>lemma</em>, and it is a very good simp-lemma.</p>
</blockquote>
<p>I'm not very good at <code>simp</code> still.</p>


{% endraw %}

{% include archive_update.html %}