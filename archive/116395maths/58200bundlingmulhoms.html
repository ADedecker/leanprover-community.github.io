---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/58200bundlingmulhoms.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html">bundling mul_homs</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="171137073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137073">Kevin Buzzard (Jul 18 2019 at 04:21)</a>:</h4>
<p>Mathlib has the unbundled <code>is_mul_hom</code> class (a Prop), and then it has <code>mul_equiv</code> which references this unbundled <code>is_mul_hom</code>. If we were to bundle <code>mul_hom</code>s, how would we define <code>mul_equiv</code>?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">γ</span><span class="o">]</span>
<span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">P</span><span class="o">]</span>

<span class="c">/-</span><span class="cm"> Mathlib:</span>

<span class="cm">class is_mul_hom {α β : Type*} [has_mul α] [has_mul β] (f : α → β) : Prop :=</span>
<span class="cm">(map_mul : ∀ x y, f (x * y) = f x * f y)</span>

<span class="cm">structure mul_equiv (α β : Type*) [has_mul α] [has_mul β] extends α ≃ β :=</span>
<span class="cm">(hom : is_mul_hom to_fun)</span>

<span class="cm">notation ≃* for mul_equiv, proved to be reflexive, symmetric and transitive</span>

<span class="cm">-- not yet found a use for this instance. Should `is_mul_hom` be a structure?</span>
<span class="cm">instance (h : α ≃* β) : is_mul_hom h.to_equiv := h.hom</span>

<span class="cm">-/</span>

<span class="kn">namespace</span> <span class="n">mul</span>

<span class="c">/-</span><span class="cm">- bundled homs FTW -/</span>
<span class="kn">structure</span> <span class="n">hom</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- but now if I delete `is_mul_hom`, how do I define `mul_equiv`?</span>
<span class="c1">-- notation for homs</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="bp">→*</span> <span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="o">:=</span> <span class="n">hom</span>
</pre></div>

<a name="171137127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137127">Mario Carneiro (Jul 18 2019 at 04:22)</a>:</h4>
<p><code>mul_equiv A B extends equiv A B, mul_hom A B</code></p>

<a name="171137144"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137144" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137144">Kevin Buzzard (Jul 18 2019 at 04:23)</a>:</h4>
<p>Should I be using old or new structures for these things?</p>

<a name="171137148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137148">Mario Carneiro (Jul 18 2019 at 04:23)</a>:</h4>
<p>old structures FTW</p>

<a name="171137150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137150">Kevin Buzzard (Jul 18 2019 at 04:23)</a>:</h4>
<p>Is what you call <code>mul_hom</code> what I called <code>mul.hom</code>?</p>

<a name="171137154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137154">Kevin Buzzard (Jul 18 2019 at 04:23)</a>:</h4>
<p>Did I name it wrong?</p>

<a name="171137158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137158">Mario Carneiro (Jul 18 2019 at 04:23)</a>:</h4>
<p>I don't think so</p>

<a name="171137201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137201">Mario Carneiro (Jul 18 2019 at 04:24)</a>:</h4>
<p><code>mul_hom A B</code> for me is the type of augmented functions from A to B</p>

<a name="171137203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137203">Kevin Buzzard (Jul 18 2019 at 04:24)</a>:</h4>
<p>but <code>mul.hom</code> has got a field <code>f</code> and <code>equiv</code> has got a field <code>to_fun</code> and these are supposed to be defeq and have the same name.</p>

<a name="171137204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137204">Mario Carneiro (Jul 18 2019 at 04:24)</a>:</h4>
<p>I don't see <code>mul.hom</code> in the example</p>

<a name="171137215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137215">Mario Carneiro (Jul 18 2019 at 04:25)</a>:</h4>
<p>Oh there it is</p>

<a name="171137216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137216">Kevin Buzzard (Jul 18 2019 at 04:25)</a>:</h4>
<p>I'm talking about my attempt to bundle homs.</p>

<a name="171137218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137218">Mario Carneiro (Jul 18 2019 at 04:25)</a>:</h4>
<p>I think that should be <code>mul_hom</code></p>

<a name="171137219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137219">Mario Carneiro (Jul 18 2019 at 04:25)</a>:</h4>
<p><code>mul</code> isn't a namespace</p>

<a name="171137266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137266">Mario Carneiro (Jul 18 2019 at 04:26)</a>:</h4>
<p><code>mul_hom</code> should have a field called <code>to_fun</code></p>

<a name="171137267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137267">Mario Carneiro (Jul 18 2019 at 04:26)</a>:</h4>
<p>so that <code>mul_equiv</code> works</p>

<a name="171137396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137396">Kevin Buzzard (Jul 18 2019 at 04:31)</a>:</h4>
<p><code>to_fun</code> is such a horrible name for a function. I guess its canonical name is the coercion so maybe it doesn't matter. Wait -- the map from <code>mul_equiv X Y</code> to <code>mul_hom X Y</code> -- that is no longer an instance, because <code>mul_hom</code> isn't a class. Is this still done with coercions somehow?</p>

<a name="171137439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137439">Mario Carneiro (Jul 18 2019 at 04:32)</a>:</h4>
<p>it's a function called <code>to_mul_hom</code></p>

<a name="171137444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137444">Mario Carneiro (Jul 18 2019 at 04:32)</a>:</h4>
<p>You can try using a coercion but this one tends to trigger rarely</p>

<a name="171137498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171137498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171137498">Mario Carneiro (Jul 18 2019 at 04:34)</a>:</h4>
<p>given that the parent functions are always called <code>to_*</code>, <code>to_fun</code> seems to match that naming convention</p>

<a name="171138143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138143">Kevin Buzzard (Jul 18 2019 at 04:55)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">mul_hom</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">to_fun</span> <span class="n">y</span><span class="o">)</span>
</pre></div>


<p>Should this have a coercion to fun?</p>

<a name="171138188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138188">Mario Carneiro (Jul 18 2019 at 04:56)</a>:</h4>
<p>yes</p>

<a name="171138401"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138401" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138401">Kevin Buzzard (Jul 18 2019 at 05:03)</a>:</h4>
<p>My <code>map_mul</code> is crappy:</p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="c">/-</span><span class="cm">- bundled homs FTW -/</span>
<span class="kn">structure</span> <span class="n">mul_hom</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">to_fun</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- notation for homs</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="bp">→*</span> <span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="o">:=</span> <span class="n">mul_hom</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">}</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">mul_hom.map_mul : ∀ (c : ?M_1 →* ?M_2) (x y : ?M_1), c.to_fun (x * y) = c.to_fun x * c.to_fun y</span>
<span class="cm">-- yeah but I want it to be the coercion, not `c.to_fun`</span>
<span class="cm">-/</span>
</pre></div>


<p>It has come out non-canonically. Am I supposed to be doing this:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">M</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul</span>
</pre></div>


<p>?</p>

<a name="171138447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138447">Mario Carneiro (Jul 18 2019 at 05:04)</a>:</h4>
<p>with the primes inverted</p>

<a name="171138449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138449">Kevin Buzzard (Jul 18 2019 at 05:04)</a>:</h4>
<p>So you're saying I need to change mathlib</p>

<a name="171138452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138452">Kevin Buzzard (Jul 18 2019 at 05:04)</a>:</h4>
<p>no</p>

<a name="171138456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138456">Kevin Buzzard (Jul 18 2019 at 05:05)</a>:</h4>
<p>you're saying I need to change my structure field's name.</p>

<a name="171138463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171138463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171138463">Mario Carneiro (Jul 18 2019 at 05:05)</a>:</h4>
<p>yes</p>

<a name="171139112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171139112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171139112">Kevin Buzzard (Jul 18 2019 at 05:25)</a>:</h4>
<p>Should this</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">mul_equiv&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">B</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">equiv</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">mul_hom</span> <span class="n">A</span> <span class="n">B</span>
</pre></div>


<p>have a coercion to fun?</p>

<a name="171139294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171139294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171139294">Mario Carneiro (Jul 18 2019 at 05:31)</a>:</h4>
<p>yes</p>

<a name="171140149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140149">Kevin Buzzard (Jul 18 2019 at 05:56)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">basic</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">equiv</span><span class="bp">.</span><span class="n">algebra</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">β</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">γ</span><span class="o">]</span>
<span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span>
<span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">P</span><span class="o">]</span>

<span class="c1">-- Recall that the unbundled definition of a mul_hom</span>
<span class="c1">-- and the definition of a mul_equiv, with notation ≃*, are in mathlib.</span>

<span class="c">/-</span><span class="cm"> Mathlib:</span>

<span class="cm">-- in root namespace</span>
<span class="cm">class is_mul_hom {α β : Type*} [has_mul α] [has_mul β] (f : α → β) : Prop :=</span>
<span class="cm">(map_mul : ∀ x y, f (x * y) = f x * f y)</span>

<span class="cm">-- root namespace</span>
<span class="cm">structure mul_equiv (α β : Type*) [has_mul α] [has_mul β] extends α ≃ β :=</span>
<span class="cm">(hom : is_mul_hom to_fun)</span>

<span class="cm">notation ≃*, proved to be reflexive, symmetric and transitive (note: it is not a Prop)</span>
<span class="cm">-/</span>


<span class="c1">--. We will define</span>
<span class="c1">-- bundled homomorphisms of muls, with notation →*, and bundled</span>
<span class="c1">-- equivs, with notation ≃*&#39;</span>


<span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="c">/-</span><span class="cm">- bundled homs -/</span>
<span class="kn">structure</span> <span class="n">mul_hom</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_mul&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">to_fun</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_fun</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">to_fun</span> <span class="n">y</span><span class="o">)</span>

<span class="c1">-- notation for homs</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="bp">→*</span> <span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="o">:=</span> <span class="n">mul_hom</span>

<span class="c1">-- I want to think of a hom as a function sometimes</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">N</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm">- the statement that mul_homs preserve mul, in its canonical form -/</span>
<span class="n">def</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→*</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">mul_hom</span><span class="bp">.</span><span class="n">map_mul&#39;</span>

<span class="c1">-- for structures like this you need to prove `id` and `comp` next.</span>
<span class="kn">namespace</span> <span class="n">mul_hom</span>

<span class="c">/-</span><span class="cm">- the identity is a mul_hom-/</span>
<span class="n">def</span> <span class="n">id</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→*</span> <span class="n">M</span> <span class="o">:=</span> <span class="o">{</span><span class="n">to_fun</span> <span class="o">:=</span> <span class="n">id</span><span class="o">,</span> <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">}</span>

<span class="c">/-</span><span class="cm">- composite of mul_homs is a mul_hom -/</span>
<span class="n">def</span> <span class="n">comp</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→*</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→*</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→*</span> <span class="n">γ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">m</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">m</span><span class="o">),</span>
  <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">map_mul</span> <span class="n">f</span><span class="o">,</span> <span class="n">map_mul</span> <span class="n">g</span><span class="o">]</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">mul_hom</span>

<span class="c">/-</span><span class="cm">- mul_equiv&#39; (bundled mul_equiv -- the name mul_equiv is currently nicked by unbundled mul_equiv) -/</span>
<span class="kn">structure</span> <span class="n">mul_equiv&#39;</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">A</span><span class="o">]</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">B</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">equiv</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">mul_hom</span> <span class="n">A</span> <span class="n">B</span>

<span class="c1">-- notation for mul_equiv&#39;</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="bp">`</span><span class="o">:</span><span class="mi">25</span> <span class="o">:=</span> <span class="n">mul_equiv&#39;</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">M</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">N</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">mul_equiv&#39;</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">mul_equiv&#39;</span><span class="bp">.</span><span class="n">map_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">y</span>
<span class="o">:=</span> <span class="n">mul_equiv&#39;</span><span class="bp">.</span><span class="n">map_mul&#39;</span>

<span class="c1">-- now need reflexive, symmetric and transitive</span>

<span class="kn">namespace</span> <span class="n">mul_equiv&#39;</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="n">def</span> <span class="n">refl</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">has_mul</span> <span class="n">α</span><span class="o">]</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
<span class="bp">..</span><span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">}</span>

<span class="c1">-- this one did not go so well.</span>
<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="n">def</span> <span class="n">symm</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">n₁</span> <span class="n">n₂</span><span class="o">,</span> <span class="n">function</span><span class="bp">.</span><span class="n">injective_of_left_inverse</span> <span class="n">h</span><span class="bp">.</span><span class="n">left_inv</span> <span class="k">begin</span>
    <span class="k">show</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_fun</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">*</span> <span class="n">n₂</span><span class="o">))</span> <span class="bp">=</span>
    <span class="n">h</span> <span class="o">(</span><span class="n">h</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="n">n₁</span> <span class="bp">*</span> <span class="n">h</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="n">n₂</span><span class="o">),</span> <span class="c1">-- annoying to have to `show`</span>
    <span class="n">rw</span> <span class="n">h</span><span class="bp">.</span><span class="n">right_inv</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">rfl</span><span class="o">,</span> <span class="c1">-- annoying to have to `convert`. This should surely just be rewrites.</span>
      <span class="n">exact</span> <span class="n">h</span><span class="bp">.</span><span class="n">right_inv</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">h</span><span class="bp">.</span><span class="n">right_inv</span> <span class="bp">_</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">h</span><span class="bp">.</span><span class="n">to_equiv</span><span class="bp">.</span><span class="n">symm</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="n">def</span> <span class="n">trans</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">β</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">α</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">h2</span> <span class="o">(</span><span class="n">h1</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">))</span> <span class="bp">=</span> <span class="n">h2</span> <span class="o">(</span><span class="n">h1</span> <span class="n">x</span><span class="o">)</span> <span class="bp">*</span> <span class="n">h2</span> <span class="o">(</span><span class="n">h1</span> <span class="n">y</span><span class="o">),</span>
    <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h1</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">,</span> <span class="n">h2</span><span class="bp">.</span><span class="n">map_mul</span><span class="o">],</span>
  <span class="bp">..</span><span class="n">equiv</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h1</span><span class="bp">.</span><span class="n">to_equiv</span> <span class="n">h2</span><span class="bp">.</span><span class="n">to_equiv</span> <span class="o">}</span>

<span class="c1">-- an ≃*&#39; is a hom</span>
<span class="n">def</span> <span class="n">equiv&#39;</span><span class="bp">.</span><span class="n">to_hom</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">M</span> <span class="bp">→*</span> <span class="n">N</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">to_equiv</span><span class="o">,</span>
    <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">map_mul&#39;</span>
  <span class="o">}</span>

<span class="n">def</span> <span class="n">equiv&#39;</span><span class="bp">.</span><span class="n">inv_hom</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">M</span> <span class="err">≃</span><span class="bp">*</span><span class="err">&#39;</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">N</span> <span class="bp">→*</span> <span class="n">M</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">to_fun</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">to_equiv</span><span class="o">,</span>
  <span class="n">map_mul&#39;</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span><span class="bp">.</span><span class="n">map_mul</span>
  <span class="o">}</span>

<span class="kn">end</span> <span class="n">mul_equiv&#39;</span>
</pre></div>


<p><code>equiv'.symm</code> didn't go well but most of the other stuff looks OK to me</p>

<a name="171140287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140287">Mario Carneiro (Jul 18 2019 at 06:00)</a>:</h4>
<p>People will complain about the order of arguments to <code>comp</code></p>

<a name="171140312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140312">Johan Commelin (Jul 18 2019 at 06:01)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> You probably know this but <code>mul_hom.map_mul</code> should be a <em>lemma</em>, and it is a very good simp-lemma.</p>

<a name="171140315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140315">Mario Carneiro (Jul 18 2019 at 06:01)</a>:</h4>
<p>What's wrong with <code>symm</code>? It looks like that's the sort of thing that is mathematically substantive anyway</p>

<a name="171140359"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140359" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140359">Johan Commelin (Jul 18 2019 at 06:02)</a>:</h4>
<p>In fact, that's the most important reason for bundling in the first place. That this is a simp-lemma that actually triggers.</p>

<a name="171140363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171140363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171140363">Johan Commelin (Jul 18 2019 at 06:02)</a>:</h4>
<p>Also, we'll want simp-lemmas <code>id_apply</code> and <code>comp_apply</code>.</p>

<a name="171141338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171141338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171141338">Kevin Buzzard (Jul 18 2019 at 06:25)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> You probably know this but <code>mul_hom.map_mul</code> should be a <em>lemma</em>, and it is a very good simp-lemma.</p>
</blockquote>
<p>I'm not very good at <code>simp</code> still.</p>

<a name="171161924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171161924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171161924">Kevin Buzzard (Jul 18 2019 at 11:49)</a>:</h4>
<p>So anyway, there is a bunch of structure most of which is correctly named, and hopefully defined sensibly.  Do we want all all of this in mathlib? And then there's the equivalent stuff for <code>semigroup</code>, for <code>monoid</code> and for <code>group</code>. I don't care about the <code>mul</code> stuff really, I was just practicing. I <em>do</em> care about equivs of monoids and of groups and would like some students to prepare a mathlib PR. </p>
<p>What are we looking for in such a PR? Should the students try and define everything for <code>semigroup</code> when we don't really need it? Is a PR of this nature for <code>group</code> welcome? <span class="user-mention" data-user-id="110044">@Chris Hughes</span> do you have any opinions on this? I've talked to you before about it and you seem to have a clear head about what should be there.</p>

<a name="171161956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171161956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171161956">Kevin Buzzard (Jul 18 2019 at 11:50)</a>:</h4>
<p>Note that we can define <code>group.hom</code> to be <code>mul_hom</code></p>

<a name="171161995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171161995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171161995">Kevin Buzzard (Jul 18 2019 at 11:50)</a>:</h4>
<p>I think the last time we talked about this, you liked that idea.</p>

<a name="171163113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171163113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171163113">Chris Hughes (Jul 18 2019 at 12:08)</a>:</h4>
<p>Don't bother with <code>semigroup</code> stuff unless it's virtually no effort. I'd actually prefer <code>group_hom</code> and <code>monoid_hom</code> to be the same, since these are the two that are actually used. You could write a custom constructor without the unnecessary axiom.</p>
<p>Same idea goes for <code>ring_hom</code> and <code>semiring_hom</code></p>

<a name="171163615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171163615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171163615">Kevin Buzzard (Jul 18 2019 at 12:16)</a>:</h4>
<p>so you're saying you want <code>group.hom</code> to be called <code>group_hom</code> and to demand that <code>f(1)=1</code>?</p>

<a name="171163633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171163633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171163633">Kevin Buzzard (Jul 18 2019 at 12:16)</a>:</h4>
<p>What should the custom constructor be called?</p>

<a name="171164305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171164305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171164305">Chris Hughes (Jul 18 2019 at 12:26)</a>:</h4>
<p>Yes <code>@[reducible] def group_hom := monoid_hom</code>. </p>
<p><code>group_hom.mk</code></p>

<a name="171164339"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171164339" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171164339">Chris Hughes (Jul 18 2019 at 12:27)</a>:</h4>
<p>That way, simp lemmas you prove about <code>monoid_hom</code>s will work with group homs.</p>

<a name="171195355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171195355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171195355">Kevin Buzzard (Jul 18 2019 at 18:15)</a>:</h4>
<p>And should this be reducible too? [sorry for prime on mul_equiv, mathlib has a slightly more unbundled one]</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">monoid_equiv</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span> <span class="n">mul_equiv&#39;</span> <span class="n">M</span> <span class="n">N</span>
</pre></div>

<a name="171195654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171195654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171195654">Johan Commelin (Jul 18 2019 at 18:18)</a>:</h4>
<p>Is it clear that making some of these definitions does not create leakage?</p>

<a name="171195706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171195706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171195706">Kevin Buzzard (Jul 18 2019 at 18:19)</a>:</h4>
<p>I am just experimenting. I will certainly report back.</p>

<a name="171195897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171195897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171195897">Johan Commelin (Jul 18 2019 at 18:21)</a>:</h4>
<p>Also, I think Lean is quite bad at dealing with situations like this:<br>
I have <code>M1 M2 : Type</code> and <code>[monoid M1] [monoid M2]</code><br>
I also have <code>f : monoid_hom M1 M2</code>.<br>
Then, for some reason, it happens that I can actually prove that <code>M1</code> and <code>M2</code> are groups.<br>
Now I need to work to turn <code>f</code> into a group hom. And if I don't do that, certain lemma's can't be applied, and <code>simp</code> gets stuck etc...</p>

<a name="171195995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171195995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171195995">Kevin Buzzard (Jul 18 2019 at 18:22)</a>:</h4>
<p>This won't happen with Chris' suggesting of defining <code>group_hom</code> to be equal to <code>monoid_hom</code></p>

<a name="171196002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196002">Johan Commelin (Jul 18 2019 at 18:22)</a>:</h4>
<p>I know it is not very beginner-friendly. But I'm becoming more and more of the opinion that we shouldn't have these "shadowing" classes. Like <code>vector_space</code> (and even <code>module</code>). And so, maybe we should also just get rid of <code>group_hom</code>s</p>

<a name="171196013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196013">Johan Commelin (Jul 18 2019 at 18:22)</a>:</h4>
<p>Nope, that's not true.</p>

<a name="171196022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196022">Kevin Buzzard (Jul 18 2019 at 18:22)</a>:</h4>
<p>and making it reducible</p>

<a name="171196045"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196045" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196045">Johan Commelin (Jul 18 2019 at 18:22)</a>:</h4>
<p>If I have a module over a field, I can't apply linear algebra results.</p>

<a name="171196071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196071">Johan Commelin (Jul 18 2019 at 18:23)</a>:</h4>
<p>Even if <code>vector_space</code> is reducibly defined to be a module.</p>

<a name="171196081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196081">Johan Commelin (Jul 18 2019 at 18:23)</a>:</h4>
<p>This has bitten me several times.</p>

<a name="171196137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196137">Kevin Buzzard (Jul 18 2019 at 18:24)</a>:</h4>
<p>We need some way of being able to talk about group homomorphisms. What is your suggestion? Unbundled homs? I thought this had problems too?</p>

<a name="171196206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196206">Johan Commelin (Jul 18 2019 at 18:24)</a>:</h4>
<p>No, it's somewhat orthogonal to bundling, but it's very much related to refactoring.</p>

<a name="171196222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196222">Johan Commelin (Jul 18 2019 at 18:24)</a>:</h4>
<p>I want to propose/discuss just ditching <code>group_hom</code> altogether.</p>

<a name="171196270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196270">Johan Commelin (Jul 18 2019 at 18:25)</a>:</h4>
<p>Just write <code>monoid_hom.mk'</code> for the case that you construct monoid homs between groups.</p>

<a name="171196299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196299">Johan Commelin (Jul 18 2019 at 18:25)</a>:</h4>
<p>It doesn't look nice... but it is more flexible.</p>

<a name="171196390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196390" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196390">Kevin Buzzard (Jul 18 2019 at 18:26)</a>:</h4>
<blockquote>
<p>This has bitten me several times.</p>
</blockquote>
<p>If you try to fix it by making the actual object you want from the object you have (e.g. the vector space over the field from the module), then you then have two objects which mathematicians find completely indistinguishable, but for which Lean finds it hard to port results about one object to results from the other. This sounds like a good place to try out a transfer tactic, no?</p>

<a name="171196448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196448">Johan Commelin (Jul 18 2019 at 18:27)</a>:</h4>
<p>Meh... I would rather let the problem go away.</p>

<a name="171196468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196468">Johan Commelin (Jul 18 2019 at 18:27)</a>:</h4>
<p>Maybe <code>group_hom</code> can be an <code>abbreviation</code>?? I still don't know what this does exactly.</p>

<a name="171196531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196531">Johan Commelin (Jul 18 2019 at 18:28)</a>:</h4>
<p>But it seems to be something like <code>hyper-super-duper-reducible</code>.</p>

<a name="171196542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196542">Chris Hughes (Jul 18 2019 at 18:28)</a>:</h4>
<blockquote>
<p>And should this be reducible too? [sorry for prime on mul_equiv, mathlib has a slightly more unbundled one]</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">monoid_equiv</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span> <span class="n">mul_equiv&#39;</span> <span class="n">M</span> <span class="n">N</span>
</pre></div>


</blockquote>
<p>That shouldn't exist</p>

<a name="171196594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171196594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171196594">Johan Commelin (Jul 18 2019 at 18:29)</a>:</h4>
<p>For the same reason that <code>vector_space</code> shouldn't exist?</p>

<a name="171197093"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171197093" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171197093">Kevin Buzzard (Jul 18 2019 at 18:34)</a>:</h4>
<blockquote>
<p>I want to propose/discuss just ditching <code>group_hom</code> altogether.</p>
</blockquote>
<p>If we ditch <code>group_hom</code> altogether, what will be the canonical way of representing the concept of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>G</mi><mo>→</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">f:G\to H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(xy)=f(x)f(y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> groups?</p>

<a name="171197171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171197171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171197171">Kevin Buzzard (Jul 18 2019 at 18:35)</a>:</h4>
<blockquote>
<blockquote>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">monoid_equiv</span> <span class="o">(</span><span class="n">M</span> <span class="n">N</span><span class="o">)</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">N</span><span class="o">]</span> <span class="o">:=</span> <span class="n">mul_equiv&#39;</span> <span class="n">M</span> <span class="n">N</span>
</pre></div>


</blockquote>
<p>That shouldn't exist</p>
</blockquote>
<p>If that doesn't exist <em>at all</em>, then what happens to the poor newbie who shows up with their two monoids and wants to know where the equiv is?</p>

<a name="171197298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171197298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171197298">Johan Commelin (Jul 18 2019 at 18:37)</a>:</h4>
<p>We tell them to use <code>M1 =* M2</code>.</p>

<a name="171197330"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171197330" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171197330">Johan Commelin (Jul 18 2019 at 18:37)</a>:</h4>
<p>If we ditch <code>group_hom</code> you just write <code>f : G →m H</code></p>

<a name="171197341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171197341" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171197341">Johan Commelin (Jul 18 2019 at 18:37)</a>:</h4>
<p>Or whatever the notation for monoid homs will be.</p>

<a name="171197626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171197626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171197626">Chris Hughes (Jul 18 2019 at 18:41)</a>:</h4>
<p>I started on <code>-&gt;1*</code>, but I propose <code>-&gt;*</code>, and screw mul homs notation.</p>

<a name="171200197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171200197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171200197">Kevin Buzzard (Jul 18 2019 at 19:11)</a>:</h4>
<p>So notation can attempt to solve the issue. Chris are you proposing the notation with no 1 to be overloaded? I am mostly interested in group homs and isoms because a student of mine needs them asap</p>

<a name="171200648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/bundling%20mul_homs/near/171200648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/58200bundlingmulhoms.html#171200648">Chris Hughes (Jul 18 2019 at 19:16)</a>:</h4>
<p>I'm proposing no notation for mul homs, since they're rarely used.</p>


{% endraw %}

{% include archive_update.html %}