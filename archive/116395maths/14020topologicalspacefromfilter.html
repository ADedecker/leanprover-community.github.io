---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/14020topologicalspacefromfilter.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html">topological space from filter</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="189325904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189325904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189325904">Kevin Buzzard (Feb 28 2020 at 16:33)</a>:</h4>
<p>The argument I know to prove that if X is a top space and  X x Y -&gt; Y is a closed map for all Y then X is compact involves a topological structure on <code>option X</code> if X is a set with a filter on it. It looks like this:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">filter_topology</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">option</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_open</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="k">if</span> <span class="n">none</span> <span class="err">∈</span> <span class="n">U</span> <span class="k">then</span> <span class="n">some</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">U</span> <span class="err">∈</span> <span class="n">F</span> <span class="k">else</span> <span class="n">true</span><span class="o">,</span>
  <span class="n">is_open_univ</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">rw</span> <span class="n">if_pos</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">preimage_univ</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">filter</span><span class="bp">.</span><span class="n">univ_mem_sets</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">mem_univ</span> <span class="o">(</span><span class="n">none</span> <span class="o">:</span> <span class="n">option</span> <span class="n">X</span><span class="o">),</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">is_open_inter</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">U</span> <span class="n">V</span> <span class="n">hU</span> <span class="n">hV</span><span class="o">,</span>
    <span class="n">split_ifs</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h0U</span> <span class="n">h0V</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">at</span> <span class="n">hU</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h0U</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">at</span> <span class="n">hV</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h0V</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">some</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">U</span> <span class="err">∩</span> <span class="n">V</span><span class="o">)</span> <span class="err">∈</span> <span class="n">F</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">preimage_inter</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">F</span><span class="bp">.</span><span class="n">inter_sets</span> <span class="n">hU</span> <span class="n">hV</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">is_open_sUnion</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">I</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hI</span><span class="o">,</span>
    <span class="n">split_ifs</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_sUnion</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hU</span><span class="o">,</span> <span class="n">h0U</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">preimage_sUnion</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">hI</span> <span class="o">:=</span> <span class="n">hI</span> <span class="n">U</span> <span class="n">hU</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">at</span> <span class="n">hI</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h0U</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">filter</span><span class="bp">.</span><span class="n">mem_sets_of_superset</span> <span class="n">hI</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">subset_bUnion_of_mem</span> <span class="n">hU</span><span class="o">,</span>
  <span class="kn">end</span>
<span class="o">}</span>
</pre></div>


<p>Is that some well-known topological construction? Do we have it in mathlib?</p>

<a name="189325998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189325998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189325998">Kevin Buzzard (Feb 28 2020 at 16:34)</a>:</h4>
<p>In short, X gets the discrete topology, and the neighbourhoods of the extra points are precisely (the point) + (element of the filter).</p>

<a name="189326205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326205">Reid Barton (Feb 28 2020 at 16:37)</a>:</h4>
<p>The one-point compactification is an instance of this construction, right? With F = the filter of sets whose complement has compact closure, or so?</p>

<a name="189326317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326317">Kevin Buzzard (Feb 28 2020 at 16:38)</a>:</h4>
<p>X has the discrete topology in my construction, I didn't think about whether it extended to a general top space. In this case F would be the cofinite filter.</p>

<a name="189326324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326324">Patrick Massot (Feb 28 2020 at 16:38)</a>:</h4>
<p>It is well-known, some (deviant) people define filters using it. I don't think it's in mathlib.</p>

<a name="189326326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326326">Reid Barton (Feb 28 2020 at 16:38)</a>:</h4>
<p>Ah yes, I just noticed that too</p>

<a name="189326542"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326542" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326542">Kevin Buzzard (Feb 28 2020 at 16:41)</a>:</h4>
<p>If you know that X x Y -&gt; Y is a closed map for all Y, and you want to prove that X is compact, your problem is that you don't have a clue which Y to use. My first thought was to try Y=X, but I don't know whether it's true that S x S -&gt; S closed implies S compact and I kind of doubt it. The proof I know goes like this: let F be a proper filter on X, and we want to show that F has an adherent point. Let Y be the top space defined above (note: use discrete top on X even though X is a top space) and now consider the closure of the diagonal map {(x,x)}; its image is closed so must contain <code>*</code>, and if <code>(x,*)</code> is in X x Y in the closure of the diagonal then x does the job.</p>

<a name="189326688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326688">Reid Barton (Feb 28 2020 at 16:42)</a>:</h4>
<p>Good thing the computer scientists chose the definition of compact that they did right?</p>

<a name="189326702"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326702" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326702">Kevin Buzzard (Feb 28 2020 at 16:42)</a>:</h4>
<p>Right!</p>

<a name="189326745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189326745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189326745">Kevin Buzzard (Feb 28 2020 at 16:43)</a>:</h4>
<p>And in the proof the other way (showing that if X is compact then pr_2 is always closed) I never have to unfold the definition of compact because we have the tube lemma which is all I need.</p>

<a name="189327237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189327237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189327237">Reid Barton (Feb 28 2020 at 16:48)</a>:</h4>
<p>The new point is always closed in this construction, right?</p>

<a name="189327263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189327263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189327263">Reid Barton (Feb 28 2020 at 16:48)</a>:</h4>
<p>Your original one</p>

<a name="189327301"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189327301" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189327301">Kevin Buzzard (Feb 28 2020 at 16:48)</a>:</h4>
<p>Yes I guess so. Any subset of X is open.</p>

<a name="189327335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189327335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189327335">Kevin Buzzard (Feb 28 2020 at 16:49)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110032">Reid Barton</span> <a href="#narrow/stream/116395-maths/topic/topological.20space.20from.20filter/near/189326688" title="#narrow/stream/116395-maths/topic/topological.20space.20from.20filter/near/189326688">said</a>:</p>
<blockquote>
<p>Good thing the computer scientists chose the definition of compact that they did right?</p>
</blockquote>
<p>I'm just counting myself lucky that they didn't <a href="https://math.stackexchange.com/a/1690753/443634" target="_blank" title="https://math.stackexchange.com/a/1690753/443634">use this approach</a></p>

<a name="189327876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189327876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189327876">Reid Barton (Feb 28 2020 at 16:54)</a>:</h4>
<p>I'm guessing that there is a general construction that takes two topological spaces <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> and tells you what data you need to write down (something like how the neighborhood filters of points of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> look when intersected with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>) to build a space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>U</mi><mo>∪</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">X = U \cup Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> open and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> its complement. Your construction would then be a special case of this where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> is X with the discrete topology and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> is a point.</p>

<a name="189327955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189327955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189327955">Reid Barton (Feb 28 2020 at 16:55)</a>:</h4>
<p>Of course you will recognize this from algebraic geometry, I'm just not sure exactly what the right data is in this setting</p>

<a name="189336789"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189336789" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189336789">Kevin Buzzard (Feb 28 2020 at 18:27)</a>:</h4>
<p>Here's the application:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">maps</span> <span class="n">topology</span><span class="bp">.</span><span class="n">subset_properties</span>

<span class="kn">example</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="mi">691</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">open</span> <span class="n">set</span>

<span class="c">/-</span><span class="cm">- If X is compact then pr₂ : X × Y → Y is a closed map -/</span>
<span class="kn">theorem</span> <span class="n">closed_pr2_of_compact</span>
  <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">compact_space</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span>
  <span class="n">is_closed_map</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">C</span> <span class="n">hC</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">is_open_compl_iff</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">is_open_iff_forall_mem_open</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">y</span> <span class="n">hy</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">generalized_tube_lemma</span> <span class="o">(</span><span class="n">compact_univ</span> <span class="o">:</span> <span class="n">compact</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">))</span>
    <span class="o">(</span><span class="n">compact_singleton</span> <span class="o">:</span> <span class="n">compact</span> <span class="o">{</span><span class="n">y</span><span class="o">})</span> <span class="o">(</span><span class="n">is_open_compl_iff</span><span class="bp">.</span><span class="mi">2</span> <span class="n">hC</span><span class="o">)</span> <span class="bp">_</span> <span class="k">with</span>
    <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">V</span><span class="o">,</span> <span class="n">hU</span><span class="o">,</span> <span class="n">hV</span><span class="o">,</span> <span class="n">hXU</span><span class="o">,</span> <span class="n">hyV</span><span class="o">,</span> <span class="n">hUV</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">use</span> <span class="n">V</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="n">v</span> <span class="n">hvV</span> <span class="bp">⟨</span><span class="n">uv</span><span class="o">,</span> <span class="n">huv</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">revert</span> <span class="n">huv</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">hUV</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_prod</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span>
        <span class="n">apply</span> <span class="n">hXU</span><span class="o">,</span> <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_univ</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hvV</span><span class="o">,</span>
    <span class="o">},</span>
    <span class="n">split</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hV</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hyV</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_singleton</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">xy</span> <span class="n">hxy</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hxyC</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">xy</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hxyC</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_prod</span> <span class="n">at</span> <span class="n">hxy</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hxy</span> <span class="k">with</span> <span class="n">hx</span> <span class="n">hy</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">mem_singleton_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hy</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">filter_topology</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">option</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_open</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="k">if</span> <span class="n">none</span> <span class="err">∈</span> <span class="n">U</span> <span class="k">then</span> <span class="n">some</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="n">U</span> <span class="err">∈</span> <span class="n">F</span> <span class="k">else</span> <span class="n">true</span><span class="o">,</span>
  <span class="n">is_open_univ</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">rw</span> <span class="n">if_pos</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">preimage_univ</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">filter</span><span class="bp">.</span><span class="n">univ_mem_sets</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">mem_univ</span> <span class="o">(</span><span class="n">none</span> <span class="o">:</span> <span class="n">option</span> <span class="n">X</span><span class="o">),</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">is_open_inter</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">U</span> <span class="n">V</span> <span class="n">hU</span> <span class="n">hV</span><span class="o">,</span>
    <span class="n">split_ifs</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h0U</span> <span class="n">h0V</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">at</span> <span class="n">hU</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h0U</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">at</span> <span class="n">hV</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h0V</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">some</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">U</span> <span class="err">∩</span> <span class="n">V</span><span class="o">)</span> <span class="err">∈</span> <span class="n">F</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">preimage_inter</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">F</span><span class="bp">.</span><span class="n">inter_sets</span> <span class="n">hU</span> <span class="n">hV</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="n">is_open_sUnion</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intros</span> <span class="n">I</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hI</span><span class="o">,</span>
    <span class="n">split_ifs</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_sUnion</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hU</span><span class="o">,</span> <span class="n">h0U</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">preimage_sUnion</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">hI</span> <span class="o">:=</span> <span class="n">hI</span> <span class="n">U</span> <span class="n">hU</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">at</span> <span class="n">hI</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h0U</span><span class="o">,</span>
    <span class="n">refine</span> <span class="n">filter</span><span class="bp">.</span><span class="n">mem_sets_of_superset</span> <span class="n">hI</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">subset_bUnion_of_mem</span> <span class="n">hU</span><span class="o">,</span>
  <span class="kn">end</span>
<span class="o">}</span>

<span class="c">/-</span><span class="cm">- Conversely, if pr₂ : X × Y → Y is a closed map for all Y then X is compact -/</span>
<span class="kn">instance</span> <span class="n">compact_space_of_closed_pr2</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>
  <span class="o">(</span><span class="n">hclosed</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">],</span> <span class="n">is_closed_map</span> <span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">compact_space</span> <span class="n">X</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">constructor</span><span class="o">,</span>
  <span class="c1">-- we will show that every proper filter has an adherent point</span>
  <span class="n">intros</span> <span class="n">F</span> <span class="n">hF</span> <span class="n">h</span><span class="o">,</span> <span class="n">clear</span> <span class="n">h</span><span class="o">,</span>
  <span class="c1">-- Let Y be the topological space defined above (X + extra point with nhds F)</span>
  <span class="n">letI</span> <span class="o">:=</span> <span class="n">filter_topology</span> <span class="n">F</span><span class="o">,</span>
  <span class="n">replace</span> <span class="n">hclosed</span> <span class="o">:=</span> <span class="n">hclosed</span> <span class="o">(</span><span class="n">option</span> <span class="n">X</span><span class="o">),</span>
  <span class="c1">-- Let D be the closure of {(x,x)} in X × Y.</span>
  <span class="n">set</span> <span class="n">D</span> <span class="o">:=</span> <span class="n">closure</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">some</span> <span class="n">x</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">×</span> <span class="n">option</span> <span class="n">X</span><span class="o">)))</span> <span class="k">with</span> <span class="n">hD</span><span class="o">,</span>
  <span class="c1">-- Its image in Y is closed.</span>
  <span class="n">replace</span> <span class="n">hclosed</span> <span class="o">:=</span> <span class="n">hclosed</span> <span class="n">D</span> <span class="o">(</span><span class="n">is_closed_closure</span><span class="o">),</span>
  <span class="c1">-- If the image contains the extra point</span>
  <span class="n">by_cases</span> <span class="n">hnone</span> <span class="o">:</span> <span class="n">none</span> <span class="err">∈</span> <span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="err">&#39;&#39;</span> <span class="n">D</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- then (x, extra point) is in the closure of D</span>
    <span class="n">rcases</span> <span class="n">hnone</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">xy</span><span class="o">,</span> <span class="n">hxy</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="c1">-- and we claim this x works</span>
    <span class="n">use</span> <span class="n">xy</span><span class="bp">.</span><span class="n">fst</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span> <span class="n">exact</span> <span class="n">mem_univ</span> <span class="bp">_</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hbot</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">filter</span><span class="bp">.</span><span class="n">empty_in_sets_eq_bot</span> <span class="n">at</span> <span class="n">hbot</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">filter</span><span class="bp">.</span><span class="n">mem_inf_sets</span> <span class="n">at</span> <span class="n">hbot</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hbot</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">A</span><span class="o">,</span> <span class="n">hA</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">hU</span><span class="o">,</span> <span class="n">hAU</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">subset_empty_iff</span> <span class="n">at</span> <span class="n">hAU</span><span class="o">,</span>
    <span class="n">revert</span> <span class="n">hAU</span><span class="o">,</span>
    <span class="n">change</span> <span class="n">A</span> <span class="err">∩</span> <span class="n">U</span> <span class="bp">≠</span> <span class="err">∅</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">ne_empty_iff_nonempty</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_nhds_sets_iff</span> <span class="n">at</span> <span class="n">hU</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hU</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">U&#39;</span><span class="o">,</span> <span class="n">hU&#39;U</span><span class="o">,</span> <span class="n">hU&#39;</span><span class="o">,</span> <span class="n">hxyU&#39;</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">set</span> <span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">X</span> <span class="bp">×</span> <span class="n">option</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">prod</span> <span class="n">U&#39;</span> <span class="o">(</span><span class="n">insert</span> <span class="n">none</span> <span class="o">(</span><span class="n">some</span> <span class="err">&#39;&#39;</span> <span class="n">A</span><span class="o">)),</span>
    <span class="k">have</span> <span class="n">hV</span> <span class="o">:</span> <span class="n">is_open</span> <span class="n">V</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">is_open_prod</span> <span class="n">hU&#39;</span><span class="o">,</span>
      <span class="n">change</span> <span class="k">if</span> <span class="n">none</span> <span class="err">∈</span> <span class="o">(</span><span class="n">insert</span> <span class="n">none</span> <span class="o">(</span><span class="n">some</span> <span class="err">&#39;&#39;</span> <span class="n">A</span><span class="o">))</span> <span class="k">then</span> <span class="n">some</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">insert</span> <span class="n">none</span> <span class="o">(</span><span class="n">some</span> <span class="err">&#39;&#39;</span> <span class="n">A</span><span class="o">))</span> <span class="err">∈</span> <span class="n">F</span> <span class="k">else</span> <span class="n">true</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">if_pos</span><span class="o">,</span>
        <span class="n">convert</span> <span class="n">hA</span> <span class="kn">using</span> <span class="mi">1</span><span class="o">,</span>
        <span class="n">ext</span> <span class="n">a</span><span class="o">,</span>
        <span class="n">simp</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">mem_insert</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hxyV</span> <span class="o">:</span> <span class="n">xy</span> <span class="err">∈</span> <span class="n">V</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_prod</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hxyU&#39;</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">hy</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">mem_insert</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hD</span> <span class="n">at</span> <span class="n">hxy</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_closure_iff</span> <span class="n">at</span> <span class="n">hxy</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">hxy</span> <span class="o">:=</span> <span class="n">hxy</span> <span class="n">V</span> <span class="n">hV</span> <span class="n">hxyV</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">hxy</span> <span class="k">with</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">hp</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">mem_prod</span> <span class="n">at</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hp</span> <span class="k">with</span> <span class="n">hpU</span> <span class="n">hpA</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
      <span class="n">change</span> <span class="n">some</span> <span class="n">p</span> <span class="err">∈</span> <span class="bp">_</span> <span class="n">at</span> <span class="n">hpA</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mem_insert_iff</span> <span class="n">at</span> <span class="n">hpA</span><span class="o">,</span>
      <span class="n">cases</span> <span class="n">hpA</span><span class="o">,</span> <span class="n">cases</span> <span class="n">hpA</span><span class="o">,</span>
      <span class="n">rcases</span> <span class="n">hpA</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">p&#39;</span><span class="o">,</span> <span class="n">hp&#39;</span><span class="o">,</span> <span class="n">hpp&#39;</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">convert</span> <span class="n">hp&#39;</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">option</span><span class="bp">.</span><span class="n">some_inj</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hpp&#39;</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hU&#39;U</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hpU</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- And if the image doesn&#39;t contain the extra point then</span>
    <span class="c1">-- in fact we can get a contradiction.</span>
    <span class="n">exfalso</span><span class="o">,</span>
    <span class="c1">-- Indeed X is a subset of the image because (x,x) ∈ D</span>
    <span class="k">have</span> <span class="n">hX</span> <span class="o">:</span> <span class="n">range</span> <span class="n">some</span> <span class="err">⊆</span> <span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="err">&#39;&#39;</span> <span class="n">D</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">rintros</span> <span class="bp">_</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">use</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">some</span> <span class="n">x</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span> <span class="n">swap</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">subset_closure</span><span class="o">,</span>
      <span class="n">use</span> <span class="n">x</span>
    <span class="o">},</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">is_open_compl_iff</span> <span class="n">at</span> <span class="n">hclosed</span><span class="o">,</span>
    <span class="n">change</span> <span class="k">if</span> <span class="n">none</span> <span class="err">∈</span> <span class="bp">-</span><span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="err">&#39;&#39;</span> <span class="n">D</span><span class="o">)</span> <span class="k">then</span> <span class="n">some</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="bp">-</span><span class="o">(</span><span class="n">prod</span><span class="bp">.</span><span class="n">snd</span> <span class="err">&#39;&#39;</span> <span class="n">D</span><span class="o">)</span> <span class="err">∈</span> <span class="n">F</span>
      <span class="k">else</span> <span class="n">true</span> <span class="n">at</span> <span class="n">hclosed</span><span class="o">,</span>
    <span class="n">replace</span> <span class="n">hnone</span> <span class="o">:=</span> <span class="n">mem_compl</span> <span class="n">hnone</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">if_pos</span> <span class="n">hnone</span> <span class="n">at</span> <span class="n">hclosed</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hF</span><span class="o">,</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">filter</span><span class="bp">.</span><span class="n">empty_in_sets_eq_bot</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">hclosed</span><span class="o">,</span>
    <span class="n">symmetry</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">eq_empty_iff_forall_not_mem</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hx</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hX</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>I have said before that I feel like I write Lean code like a child, just stepping through carefully with each basic tactic. I never really get stuck any more and I really enjoy going through these sorts of proofs in Lean. But what should I be doing to make my Lean code better? I kind of suspect that (a) this result would be fine to put in mathlib but (b) this proof would be not acceptable.</p>

<a name="189338780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189338780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189338780">Scott Morrison (Feb 28 2020 at 18:46)</a>:</h4>
<p>Maybe golf some bits into term mode? I remain unconvinced that the proofs get better, but they certainly get shorter and that makes me feel more grown-up. :-)</p>

<a name="189338815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189338815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189338815">Scott Morrison (Feb 28 2020 at 18:46)</a>:</h4>
<p>I doubt the last one should be an <code>instance</code>, as the <code>hclosed</code> argument can't be found by typeclass search.</p>

<a name="189338963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189338963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189338963">Scott Morrison (Feb 28 2020 at 18:48)</a>:</h4>
<p>I like shorter proofs, with more lemmas, so another stage of golfing might be to do that. e.g. prove that last result in the special case <code>Y =  (option X)</code>, then deduce the universally quantified one from it trivially. You could also separate the two branches of <code>by_cases</code> into lemmas, I guess.</p>

<a name="189339053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189339053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189339053">Scott Morrison (Feb 28 2020 at 18:49)</a>:</h4>
<p>I would certainly add more braces: you're using pythonic indenting to simulate proper braces. :-)</p>

<a name="189339210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/topological%20space%20from%20filter/near/189339210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/14020topologicalspacefromfilter.html#189339210">Scott Morrison (Feb 28 2020 at 18:51)</a>:</h4>
<p>But I think it's pretty reasonable. We should have more "all tactics" proofs in mathlib, to reduce the stigma. You do you! :-)</p>


{% endraw %}

{% include archive_update.html %}