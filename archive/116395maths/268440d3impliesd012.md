---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/268440d3impliesd012.html
---

## Stream: [maths](index.html)
### Topic: [0<=d<3 implies d=0,1,2](268440d3impliesd012.html)

---


{% raw %}
#### [ Kevin Buzzard (Aug 30 2018 at 16:09)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133062403):
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">easy</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">d</span> <span class="bp">∧</span> <span class="n">d</span> <span class="bp">&lt;</span> <span class="mi">3</span> <span class="bp">→</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>I can prove this by cases on <code>d</code> but it's a bit horrible. Is there a tactic which does this painlessly?</p>

#### [ Kevin Buzzard (Aug 30 2018 at 16:13)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133062639):
<p>aargh an undergrad just told me that they need this mod 8 :-/</p>

#### [ cbailey (Aug 30 2018 at 16:15)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133062778):
<p>If Lean has Omega, that will definitely take care of the original one by itself.</p>

#### [ Kevin Buzzard (Aug 30 2018 at 16:16)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133062894):
<p>Apparently what they actually need is <code>example (d : ℤ) : d ^ 2 ≡ 0 [ZMOD 8] ∨ d ^ 2 ≡ 1 [ZMOD 8] ∨ d ^ 2 ≡ 4 [ZMOD 8] := sorry</code></p>

#### [ Kevin Buzzard (Aug 30 2018 at 16:17)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133062911):
<p>which can done by cases on d mod 8 (check it's true for all 8 values)</p>

#### [ Kevin Buzzard (Aug 30 2018 at 16:18)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133062991):
<p>(and use the fact that <code>a ≡ b [ZMOD 8] -&gt; a ^ 2 ≡ b ^ 2[ZMOD 8]</code>. <span class="user-mention" data-user-id="110044">@Chris Hughes</span> how far is this from <code>dec_trivial</code>?</p>

#### [ Johan Commelin (Aug 30 2018 at 16:19)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133063069):
<p>Would the original one be something that <code>linarith</code> could do? I have no good feeling for this yet...</p>

#### [ Kevin Buzzard (Aug 30 2018 at 16:20)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133063121):
<p>I think Lean does not have Omega yet.</p>

#### [ Johan Commelin (Aug 30 2018 at 16:20)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133063144):
<p>But it has <code>linarith</code> (but not on my laptop, because compiling Lean takes forever...)</p>

#### [ Kenny Lau (Aug 30 2018 at 16:21)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133063167):
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">theorem</span> <span class="n">easy</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">d</span> <span class="bp">∧</span> <span class="n">d</span> <span class="bp">&lt;</span> <span class="mi">3</span> <span class="bp">→</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">∨</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">∨</span> <span class="n">d</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">H</span> <span class="k">with</span> <span class="n">H1</span> <span class="n">H2</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">d</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">replace</span> <span class="n">H2</span> <span class="o">:=</span> <span class="n">int</span><span class="bp">.</span><span class="n">lt_of_coe_nat_lt_coe_nat</span> <span class="n">H2</span><span class="o">,</span>
    <span class="n">clear</span> <span class="n">H1</span><span class="o">,</span> <span class="n">revert</span> <span class="n">d</span><span class="o">,</span> <span class="k">from</span> <span class="n">dec_trivial</span> <span class="o">},</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">H1</span>
<span class="kn">end</span>
</pre></div>

#### [ Rob Lewis (Aug 30 2018 at 16:21)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133063190):
<p>No, <code>linarith</code> won't work for a few reasons. In particular, it's only complete for dense orders.</p>

#### [ Rob Lewis (Aug 30 2018 at 16:21)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133063234):
<p>It's also not set up to handle disjunctions or proving equality goals right now, although in principle that can happen.</p>

#### [ Johan Commelin (Aug 30 2018 at 16:29)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133063792):
<blockquote>
<p>No, <code>linarith</code> won't work for a few reasons. In particular, it's only complete for dense orders.</p>
</blockquote>
<p>What is a dense order? You had examples with <code>int</code> right?</p>

#### [ Kenny Lau (Aug 30 2018 at 16:31)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133063915):
<p>a dense order is one such that for every a and b there is c with a&lt;c&lt;b</p>

#### [ Rob Lewis (Aug 30 2018 at 16:31)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133063916):
<p>Something like <code>∀ x y, x &lt; y → ∃ z, x &lt; z ∧ y &lt; z</code>. It will work on many problems in <code>int</code>, but it isn't complete, meaning there are provable things it will fail on.</p>

#### [ Rob Lewis (Aug 30 2018 at 16:32)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133063984):
<p>In theory, over <code>real</code> or <code>rat</code> it will either succeed with a proof or fail with a counterexample.</p>

#### [ Rob Lewis (Aug 30 2018 at 16:32)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133064004):
<p>(I didn't implement counterexamples yet.)</p>

#### [ Johan Commelin (Aug 30 2018 at 16:40)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133064475):
<p>Right, so dense orders are what I thought they were. And <code>int</code> is not a dense order. So every time <code>linarith</code> succeeds on <code>int</code> we are just being lucky?</p>

#### [ Kenny Lau (Aug 30 2018 at 16:40)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133064488):
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">int</span><span class="bp">.</span><span class="n">modeq</span>

<span class="kn">lemma</span> <span class="n">why_isnt_this_in_mathlib</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="err">%</span> <span class="n">c</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="err">%</span> <span class="n">c</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="err">%</span> <span class="n">c</span><span class="o">)</span> <span class="err">%</span> <span class="n">c</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">conv</span> <span class="k">in</span> <span class="o">((</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="err">%</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">mod_add_div</span> <span class="n">a</span> <span class="n">c</span> <span class="o">},</span>
  <span class="n">conv</span> <span class="k">in</span> <span class="o">((</span><span class="bp">_</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="err">%</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">mod_add_div</span> <span class="n">b</span> <span class="n">c</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">,</span> <span class="err">←</span> <span class="n">add_assoc</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">add_mul_mod_self_left</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_left_comm</span> <span class="o">(</span><span class="n">a</span><span class="err">%</span><span class="n">c</span><span class="o">)],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">add_mul_mod_self_left</span><span class="o">],</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">add_mul_mod_self_left</span><span class="o">]</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">≡</span> <span class="mi">0</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">8</span><span class="o">]</span> <span class="bp">∨</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">≡</span> <span class="mi">1</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">8</span><span class="o">]</span> <span class="bp">∨</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">≡</span> <span class="mi">4</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">8</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="err">←</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs_mul_self</span><span class="o">,</span>
  <span class="n">generalize</span> <span class="o">:</span> <span class="n">int</span><span class="bp">.</span><span class="n">nat_abs</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">clear</span> <span class="n">d</span><span class="o">,</span>
  <span class="n">change</span> <span class="err">↑</span><span class="o">(</span><span class="n">n</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="bp">≡</span> <span class="err">↑</span><span class="mi">0</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="err">↑</span><span class="mi">8</span><span class="o">]</span> <span class="bp">∨</span> <span class="err">↑</span><span class="o">(</span><span class="n">n</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="bp">≡</span> <span class="err">↑</span><span class="mi">1</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="err">↑</span><span class="mi">8</span><span class="o">]</span> <span class="bp">∨</span> <span class="err">↑</span><span class="o">(</span><span class="n">n</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="bp">≡</span> <span class="err">↑</span><span class="mi">4</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="err">↑</span><span class="mi">8</span><span class="o">],</span>
  <span class="n">rw</span> <span class="n">int</span><span class="bp">.</span><span class="n">modeq</span><span class="bp">.</span><span class="n">coe_nat_modeq_iff</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">int</span><span class="bp">.</span><span class="n">modeq</span><span class="bp">.</span><span class="n">coe_nat_modeq_iff</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">int</span><span class="bp">.</span><span class="n">modeq</span><span class="bp">.</span><span class="n">coe_nat_modeq_iff</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">nat</span><span class="bp">.</span><span class="n">modeq</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">why_isnt_this_in_mathlib</span> <span class="n">n</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">generalize</span> <span class="n">H</span> <span class="o">:</span> <span class="n">n</span> <span class="err">%</span> <span class="mi">8</span> <span class="bp">=</span> <span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H1</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="mi">8</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">H</span><span class="o">,</span> <span class="k">from</span> <span class="n">nat</span><span class="bp">.</span><span class="n">mod_lt</span> <span class="bp">_</span> <span class="n">dec_trivial</span> <span class="o">},</span>
  <span class="n">clear</span> <span class="n">H</span> <span class="n">n</span><span class="o">,</span>
  <span class="n">revert</span> <span class="n">H1</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">dec_trivial</span>
<span class="kn">end</span>
</pre></div>

#### [ Kenny Lau (Aug 30 2018 at 16:40)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133064490):
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> done</p>

#### [ Rob Lewis (Aug 30 2018 at 16:44)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133064697):
<blockquote>
<p>Right, so dense orders are what I thought they were. And <code>int</code> is not a dense order. So every time <code>linarith</code> succeeds on <code>int</code> we are just being lucky?</p>
</blockquote>
<p>Yep. You'll get lucky on any problem that doesn't depend on the discrete-ness of integers.</p>

#### [ Chris Hughes (Aug 30 2018 at 17:05)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133065783):
<p>This is my attempt</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">zmod</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">≡</span> <span class="mi">0</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">8</span><span class="o">]</span> <span class="bp">∨</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">≡</span> <span class="mi">1</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">8</span><span class="o">]</span> <span class="bp">∨</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">≡</span> <span class="mi">4</span> <span class="o">[</span><span class="n">ZMOD</span> <span class="mi">8</span><span class="o">]</span> <span class="o">:=</span>
<span class="k">have</span> <span class="bp">∀</span> <span class="n">d</span> <span class="o">:</span> <span class="n">zmod</span> <span class="mi">8</span><span class="o">,</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">∨</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">4</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="k">from</span> <span class="n">dec_trivial</span><span class="o">,</span>
<span class="k">by</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">this</span> <span class="n">d</span><span class="bp">;</span>
  <span class="n">rwa</span> <span class="o">[</span><span class="err">←</span> <span class="n">int</span><span class="bp">.</span><span class="n">cast_mul</span><span class="o">,</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">eq_iff_modeq_int</span><span class="o">,</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">eq_iff_modeq_int</span><span class="o">,</span> <span class="n">zmod</span><span class="bp">.</span><span class="n">eq_iff_modeq_int</span><span class="o">]</span> <span class="n">at</span> <span class="n">this</span>
</pre></div>


<p>Although this is not as easy as I'd like it to be.</p>

#### [ Kenny Lau (Aug 30 2018 at 17:10)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133066087):
<p>ah!!! you did zmod</p>

#### [ Kenny Lau (Aug 30 2018 at 17:10)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133066093):
<p>I was reducing it to nat instead</p>

#### [ Kevin Buzzard (Aug 30 2018 at 17:37)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133067558):
<p>Thanks Kenny. I had tried <code>dec_trivial</code> but before applying <code>int.le_of_coe_nat_lt_coe_nat</code>.</p>

#### [ Kevin Buzzard (Aug 30 2018 at 17:40)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/0%3C%3Dd%3C3%20implies%20d%3D0%2C1%2C2/near/133067797):
<p>So Chris reduces it to something which is known to be finite. That's another trick. But <code>dec_trivial</code> doesn't work with <code>int</code>? Is this because it could work but there's just some missing code? Is it possible for someone to write some behind-the-scenes code and then after that we have things like <code>example (d : ℤ) : -3 &lt; d ∧ d &lt; 2 → d = -2 ∨ d = -1 ∨ d = 0 ∨ d = 1 := dec_trivial</code>?</p>


{% endraw %}
