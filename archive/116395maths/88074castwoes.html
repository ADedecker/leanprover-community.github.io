---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/88074castwoes.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html">cast woes</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="160656265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160656265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160656265">Johan Commelin (Mar 13 2019 at 11:52)</a>:</h4>
<p>It's quite humiliating, but how do I kill:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">p</span><span class="bp">.</span><span class="n">prime</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="160656373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160656373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160656373">Kenny Lau (Mar 13 2019 at 11:54)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">prime</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">universes</span> <span class="n">u</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">p</span><span class="bp">.</span><span class="n">prime</span><span class="o">]</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">show</span> <span class="bp">_</span> <span class="bp">&lt;</span> <span class="bp">_</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">cast_one</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">cast_lt</span><span class="o">]</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">nat</span><span class="bp">.</span><span class="n">prime</span><span class="bp">.</span><span class="n">gt_one</span><span class="bp">;</span> <span class="n">assumption</span>
</pre></div>

<a name="160656379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160656379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160656379">Mario Carneiro (Mar 13 2019 at 11:54)</a>:</h4>
<p><code>pp.gt_one</code>?</p>

<a name="160656397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160656397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160656397">Kenny Lau (Mar 13 2019 at 11:55)</a>:</h4>
<p>why is <code>[p.prime]</code> an instance though</p>

<a name="160656399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160656399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160656399">Johan Commelin (Mar 13 2019 at 11:55)</a>:</h4>
<p>We really need a <code>cast</code> tactic.</p>

<a name="160656404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160656404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160656404">Kenny Lau (Mar 13 2019 at 11:55)</a>:</h4>
<p>and also why does <code>data.nat.prime</code> use ge and gt <span class="user-mention" data-user-id="110049">@Mario Carneiro</span></p>

<a name="160656475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160656475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160656475">Johan Commelin (Mar 13 2019 at 11:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Thanks</p>

<a name="160656504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160656504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160656504">Mario Carneiro (Mar 13 2019 at 11:57)</a>:</h4>
<p>I guess it's a bit more natural to read <code>prime.gt_one</code>? not a strong argument</p>

<a name="160656525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160656525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160656525">Mario Carneiro (Mar 13 2019 at 11:57)</a>:</h4>
<p>you can make them all le and lt if you want</p>

<a name="160656679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160656679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160656679">Johan Commelin (Mar 13 2019 at 12:00)</a>:</h4>
<p>I would love to be able to prove this via</p>
<div class="codehilite"><pre><span></span><span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span>
<span class="o">{</span> <span class="n">cast_magic</span> <span class="kn">using</span> <span class="n">this</span> <span class="o">},</span>
<span class="bp">...</span>
</pre></div>

<a name="160658825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160658825" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160658825">Kevin Buzzard (Mar 13 2019 at 12:37)</a>:</h4>
<p>Did you read my docs on cast?</p>

<a name="160658839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160658839" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160658839">Kevin Buzzard (Mar 13 2019 at 12:37)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/casts.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/casts.md">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/casts.md</a></p>

<a name="160658875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160658875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160658875">Johan Commelin (Mar 13 2019 at 12:38)</a>:</h4>
<p>Yes, I read those... but I guess I also forgot them</p>

<a name="160658888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160658888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160658888">Kevin Buzzard (Mar 13 2019 at 12:38)</a>:</h4>
<p>I feel like at least there's an algorithm in there, even if not a tactic</p>

<a name="160658892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160658892" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160658892">Kevin Buzzard (Mar 13 2019 at 12:38)</a>:</h4>
<p>I wrote them, and I certainly also forgot them.</p>

<a name="160658894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160658894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160658894">Kevin Buzzard (Mar 13 2019 at 12:38)</a>:</h4>
<p>That's why I wrote them :-)</p>

<a name="160660252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160660252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160660252">Kevin Buzzard (Mar 13 2019 at 13:01)</a>:</h4>
<p>My docs don't seem to help.</p>

<a name="160660253"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160660253" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160660253">Kevin Buzzard (Mar 13 2019 at 13:01)</a>:</h4>
<p>"1=1" can be proved by simp, but for <code>a&lt;b iff a&lt;b</code> it helps a lot if you know the statement of the lemma.</p>

<a name="160660254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160660254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160660254">Kevin Buzzard (Mar 13 2019 at 13:01)</a>:</h4>
<p><code>simp</code> uses this:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">coe_nat_inj&#39;</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="err">↑</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">n</span> <span class="bp">↔</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_eq_coe_nat_iff</span> <span class="n">m</span> <span class="n">n</span>
</pre></div>


<p>Actually I don't understand this. What does <code>simp</code> to do goals of the form <code>X -&gt; Y</code>? It tries to simplify <code>X</code> and <code>Y</code> and then sees if it has got lucky and the goal has become <code>Z -&gt; Z</code>?</p>

<a name="160660255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160660255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160660255">Kevin Buzzard (Mar 13 2019 at 13:01)</a>:</h4>
<p>This works now:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">=</span> <span class="n">r</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span>
</pre></div>


<p>It didn't used to, apparently. But I am a bit weirded out by this -- I thought that it wasn't <code>simp</code>s job to prove this sort of thing? It's an implication, not an iff or an equality.</p>

<a name="160660256"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160660256" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160660256">Kevin Buzzard (Mar 13 2019 at 13:01)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="kn">using</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">rwa</span> <span class="n">nat</span><span class="bp">.</span><span class="n">cast_lt</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>It wasn't hard for me to construct a proof, but I had to know the general route.</p>

<a name="160660257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160660257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160660257">Kevin Buzzard (Mar 13 2019 at 13:01)</a>:</h4>
<p><code>simp</code> uses this:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">coe_nat_inj&#39;</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="err">↑</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="err">↑</span><span class="n">n</span> <span class="bp">↔</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">int</span><span class="bp">.</span><span class="n">coe_nat_eq_coe_nat_iff</span> <span class="n">m</span> <span class="n">n</span>
</pre></div>


<p>Actually I don't understand this. What does <code>simp</code> to do goals of the form <code>X -&gt; Y</code>? It tries to simplify <code>X</code> and <code>Y</code> and then sees if it has got lucky and the goal has become <code>Z -&gt; Z</code>?</p>
<p>Oh -- ha ha -- </p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">imp_self</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">→</span> <span class="n">a</span><span class="o">)</span> <span class="bp">↔</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">iff_true_intro</span> <span class="n">id</span>
</pre></div>

<a name="160660272"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160660272" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160660272">Kevin Buzzard (Mar 13 2019 at 13:01)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="kn">using</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">revert</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p</span> <span class="bp">↔</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">this</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="c1">-- ⊢ ↑1 &lt; ↑p ↔ 1 &lt; p</span>
  <span class="n">simp</span><span class="o">,</span> <span class="c1">-- gaargh you stupid algorithm</span>
  <span class="c1">-- ⊢ 1 &lt; ↑p ↔ 1 &lt; p</span>
  <span class="n">sorry</span>
<span class="kn">end</span>

<span class="c1">-- @[simp] theorem nat.cast_lt [linear_ordered_semiring α] {m n : ℕ} :</span>
<span class="c1">--  (m : α) &lt; n ↔ m &lt; n := ...</span>
</pre></div>

<a name="160661118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661118">Kevin Buzzard (Mar 13 2019 at 13:10)</a>:</h4>
<p>It's a bit of a challenge to make <code>simp</code> use <code>nat.cast_lt</code> apparently. Can this be fixed somehow? I was seeing if I could construct a proof which did not involve needing to know the name of <code>nat.cast_lt</code> but just relied on the fact that it was a simp lemma.</p>

<a name="160661175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661175">Kevin Buzzard (Mar 13 2019 at 13:11)</a>:</h4>
<p>I want <code>nat.cast_lt</code> to have greater precedence than \u 1 = 1.</p>

<a name="160661235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661235">Mario Carneiro (Mar 13 2019 at 13:12)</a>:</h4>
<p>it's not a question of precedence, it's that 1 is not \u 1</p>

<a name="160661266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661266">Mario Carneiro (Mar 13 2019 at 13:12)</a>:</h4>
<p><code>simp</code> cannot solve cast problems, it's just not an appropriate tool</p>

<a name="160661271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661271">Kevin Buzzard (Mar 13 2019 at 13:12)</a>:</h4>
<p>If I change 1 to <code>q</code> it works.</p>

<a name="160661306"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661306" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661306">Mario Carneiro (Mar 13 2019 at 13:13)</a>:</h4>
<p>it will sometimes get lucky but that's all it is</p>

<a name="160661347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661347">Kevin Buzzard (Mar 13 2019 at 13:13)</a>:</h4>
<p>I see.</p>

<a name="160661384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661384">Kevin Buzzard (Mar 13 2019 at 13:14)</a>:</h4>
<p>I don't really understand why <code>simp</code> doesn't solve it.</p>

<a name="160661434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661434">Kevin Buzzard (Mar 13 2019 at 13:14)</a>:</h4>
<p>It is exactly <code>nat.cast_lt</code>, no?</p>

<a name="160661437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661437">Mario Carneiro (Mar 13 2019 at 13:14)</a>:</h4>
<p>what?</p>

<a name="160661462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661462">Kevin Buzzard (Mar 13 2019 at 13:14)</a>:</h4>
<div class="codehilite"><pre><span></span>  -- ⊢ ↑1 &lt; ↑p ↔ 1 &lt; p
  simp, -- gaargh you stupid algorithm
  -- ⊢ 1 &lt; ↑p ↔ 1 &lt; p
</pre></div>

<a name="160661497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661497">Mario Carneiro (Mar 13 2019 at 13:15)</a>:</h4>
<p><code>1 &lt; ↑p ↔ 1 &lt; p</code> is defeq to an application of <code>nat.cast_lt</code>, but the pattern <code>↑?M1 &lt; ↑?M2</code> doesn't match syntactically</p>

<a name="160661511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661511">Kevin Buzzard (Mar 13 2019 at 13:15)</a>:</h4>
<p>I made it match syntactically, no?</p>

<a name="160661568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661568">Kevin Buzzard (Mar 13 2019 at 13:16)</a>:</h4>
<p>I got 1 into \u 1 form</p>

<a name="160661572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661572">Kevin Buzzard (Mar 13 2019 at 13:16)</a>:</h4>
<p>simp sent it back</p>

<a name="160661578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661578" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661578">Mario Carneiro (Mar 13 2019 at 13:16)</a>:</h4>
<p>Oh I see</p>

<a name="160661616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661616">Kevin Buzzard (Mar 13 2019 at 13:16)</a>:</h4>
<p>So is it a question of precedence?</p>

<a name="160661636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661636">Mario Carneiro (Mar 13 2019 at 13:16)</a>:</h4>
<p>The problem is that <code>nat.cast_lt</code> is not in a simp normal form, so it rarely triggers</p>

<a name="160661654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661654">Mario Carneiro (Mar 13 2019 at 13:17)</a>:</h4>
<p><code>simp</code> is not confluent as a result</p>

<a name="160661768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661768">Mario Carneiro (Mar 13 2019 at 13:18)</a>:</h4>
<p>The honest approach would just be to have <code>nat.cast_lt</code> not be a simp rule at all, but it works opportunistically sometimes</p>

<a name="160661824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661824" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661824">Kevin Buzzard (Mar 13 2019 at 13:19)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">nat</span><span class="o">))</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="o">((</span><span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">simpa</span> <span class="kn">using</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">revert</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="o">((</span><span class="n">q</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">p</span> <span class="bp">↔</span> <span class="n">q</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">this</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>That works, which is kind of cool, because it meant that I didn't need to know the names of any obscure lemmas.</p>

<a name="160661859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661859">Mario Carneiro (Mar 13 2019 at 13:19)</a>:</h4>
<blockquote>
<p>names of any obscure lemmas</p>
</blockquote>
<p>You mean "names of anything at all", right?</p>

<a name="160661866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661866">Mario Carneiro (Mar 13 2019 at 13:20)</a>:</h4>
<p>These are not difficult names</p>

<a name="160661923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661923">Mario Carneiro (Mar 13 2019 at 13:20)</a>:</h4>
<p>there is much worse than this in the library</p>

<a name="160661927"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661927" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661927">Kevin Buzzard (Mar 13 2019 at 13:20)</a>:</h4>
<p>:-)</p>

<a name="160661941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661941">Kevin Buzzard (Mar 13 2019 at 13:20)</a>:</h4>
<p>To a beginning maths undergraduate, they're all obscure lemmas :-)</p>

<a name="160661976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160661976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160661976">Kevin Buzzard (Mar 13 2019 at 13:21)</a>:</h4>
<p>To me, they're a little obscure because some have <code>cast</code> and some have <code>coe</code></p>

<a name="160662027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160662027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160662027">Mario Carneiro (Mar 13 2019 at 13:21)</a>:</h4>
<p>This is unfortunate; most of the <code>coe</code> names have to do with coercions from nat to int in core</p>

<a name="160662973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160662973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160662973">Johan Commelin (Mar 13 2019 at 13:34)</a>:</h4>
<p>I really don't like these goals.</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">[</span><span class="n">p</span><span class="bp">.</span><span class="n">prime</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="o">(((</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="err">^</span> <span class="bp">-</span><span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="err">^</span> <span class="bp">-</span><span class="n">n</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="160663305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160663305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160663305">Kevin Buzzard (Mar 13 2019 at 13:39)</a>:</h4>
<p>I don't think you need that p is prime there</p>

<a name="160663318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160663318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160663318">Kevin Buzzard (Mar 13 2019 at 13:39)</a>:</h4>
<p>;-)</p>

<a name="160663329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160663329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160663329">Kevin Buzzard (Mar 13 2019 at 13:39)</a>:</h4>
<p>Did you read my docs about cast?</p>

<a name="160663765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160663765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160663765">Johan Commelin (Mar 13 2019 at 13:44)</a>:</h4>
<p>Kevin, I'd rather not prove these things by hand. Even if I can after reading a bunch of docs etc... I'm providing motivation for tactic-writers (-;</p>

<a name="160667482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160667482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160667482">Patrick Massot (Mar 13 2019 at 14:22)</a>:</h4>
<p>They don't need motivation, they need pity</p>

<a name="160669571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160669571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160669571">Rob Lewis (Mar 13 2019 at 14:25)</a>:</h4>
<p>I haven't fully read this thread (and I can't right now, I need to run in two minutes). But: we have a new intern in Amsterdam, as of last week, who's probably going to think about a cast tactic as his first project. We have some ideas about how to proceed. But if you have thoughts, desiderata, etc, put a list together for us.</p>

<a name="160673278"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160673278" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160673278">Johan Commelin (Mar 13 2019 at 15:03)</a>:</h4>
<p>Awesome!</p>

<a name="160678780"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160678780" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160678780">Kevin Buzzard (Mar 13 2019 at 15:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110596">@Rob Lewis</span> a general spec would be "if a mathematician who thinks <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="double-struck">N</mi></mrow><mo>⊂</mo><mrow><mi mathvariant="double-struck">Z</mi></mrow><mo>⊂</mo><mrow><mi mathvariant="double-struck">Q</mi></mrow><mo>⊂</mo><mrow><mi mathvariant="double-struck">R</mi></mrow><mrow><mi mathvariant="double-struck">C</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbb{N}\subset\mathbb{Z}\subset\mathbb{Q}\subset\mathbb{R}\mathbb{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68889em;"></span><span class="strut bottom" style="height:0.85556em;vertical-align:-0.16667em;"></span><span class="base"><span class="mord"><span class="mord mathbb">N</span></span><span class="mrel">⊂</span><span class="mord"><span class="mord mathbb">Z</span></span><span class="mrel">⊂</span><span class="mord"><span class="mord mathbb">Q</span></span><span class="mrel">⊂</span><span class="mord"><span class="mord mathbb">R</span></span><span class="mord"><span class="mord mathbb">C</span></span></span></span></span> can't figure out why something even needs to be proved here, the tactic should prove it. I would be very interested in working with you or others on making a more formal spec, because I do not really understand what goes into the process and yet I feel like I have some understanding of what we mathematicians are missing. Should I just formalise some unit tests?</p>

<a name="160699722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160699722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160699722">Kevin Buzzard (Mar 13 2019 at 16:49)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">complex</span><span class="bp">.</span><span class="n">basic</span> <span class="c1">-- ℕ, ℤ, ℚ, ℝ, ℂ</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">an</span> <span class="n">bn</span> <span class="n">cn</span> <span class="n">dn</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">az</span> <span class="n">bz</span> <span class="n">cz</span> <span class="n">dz</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">aq</span> <span class="n">bq</span> <span class="n">cq</span> <span class="n">dq</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">ar</span> <span class="n">br</span> <span class="n">cr</span> <span class="n">dr</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">ac</span> <span class="n">bc</span> <span class="n">cc</span> <span class="n">dc</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">an</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">bn</span> <span class="bp">→</span> <span class="n">an</span> <span class="bp">=</span> <span class="n">bn</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">an</span> <span class="bp">=</span> <span class="n">bn</span> <span class="bp">→</span> <span class="o">(</span><span class="n">an</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">bn</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">az</span> <span class="bp">=</span> <span class="n">bz</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">az</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">bz</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">aq</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">br</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">aq</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">br</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">an</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">bz</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">an</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">bz</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">(((</span><span class="n">an</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">bq</span> <span class="bp">↔</span> <span class="o">((</span><span class="n">an</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">bq</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">an</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">bn</span> <span class="bp">↔</span> <span class="n">an</span> <span class="bp">&lt;</span> <span class="n">bn</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">an</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">bz</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">an</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">bz</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">((</span><span class="n">an</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">bq</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">an</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">bq</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c1">-- zero and one cause special problems</span>
<span class="kn">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="n">bq</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">↔</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">bq</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">aq</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">aq</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">an</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">bn</span> <span class="bp">=</span> <span class="o">(</span><span class="n">an</span> <span class="bp">+</span> <span class="n">bn</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">an</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">bq</span> <span class="bp">=</span> <span class="o">((</span><span class="n">an</span> <span class="bp">+</span> <span class="n">bq</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">(((</span><span class="n">an</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">bn</span> <span class="bp">=</span> <span class="o">(</span><span class="n">an</span> <span class="bp">+</span> <span class="o">(</span><span class="n">bn</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(((((</span><span class="n">an</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">*</span> <span class="n">bq</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">cq</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="err">^</span> <span class="n">dn</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">an</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">bq</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">cq</span> <span class="err">^</span> <span class="n">dn</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">((</span><span class="n">an</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">bq</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">cr</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="err">^</span> <span class="mi">2</span> <span class="bp">=</span> <span class="n">dz</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">an</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">bq</span> <span class="bp">∧</span> <span class="o">((</span><span class="n">cr</span> <span class="err">^</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℂ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">dz</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>There are some example goals. Some, but not all, can be solved with <code>simp</code>. One or two might be even solvable with <code>rfl</code>.  I got a bit silly with the last one in the sense that I introduced \and -- this just shows my inexperience with this sort of thing.  I don't know what is reasonable. What is reasonable? If you give me a subset of these things, I can tell you how I would prove them following the tricks I've picked up. Problems such as this were constantly showing up last summer when I was working with a team of undergraduates solving undergraduate level mathematics problems -- you might think some of the examples are artificial but when students have a question about natural numbers and they start subtracting and dividing, they do drift into Z and Q, and I would sometimes see \u \u as a consequence.</p>

<a name="160700808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160700808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160700808">Kevin Buzzard (Mar 13 2019 at 16:52)</a>:</h4>
<p>I don't even know if \iff is asking more than one might naturally expect a tactic to deliver. Rob I would be very happy to work with you on developing a spec, but of course I can tell you nothing about tactic design. Even a tactic which only proves one-way implications and equalities would be useful, but I have seen with my own eyes that mathematicians sometimes want one-way implications and sometimes two-way ones.</p>

<a name="160761499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160761499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160761499">Rob Lewis (Mar 14 2019 at 08:49)</a>:</h4>
<p>Thanks, Kevin. This is a good start. The <code>\u \u</code> examples are definitely not trivial, I come across those often enough too.</p>

<a name="160761559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/160761559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#160761559">Rob Lewis (Mar 14 2019 at 08:50)</a>:</h4>
<p>We'll come back and talk about a formal spec once Paul-Nicolas has made some more progress, but these examples help a lot for the moment.</p>

<a name="161748819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/161748819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#161748819">Patrick Massot (Mar 26 2019 at 10:36)</a>:</h4>
<p>One more data point about casts and stupid arithmetic goal. This afternoon I want students to prove that if <code>f : ℝ → ℝ</code> sequentially tends to <code>y₀</code> at <code>x₀</code> then it tends to <code>y₀</code> en <code>x₀</code>. I almost gave on this idea, although this is the perfect illustration for the current chapter (negation of quantified statements). I ended writing in the assignment Lean file:</p>
<div class="codehilite"><pre><span></span><span class="kn">axiom</span> <span class="n">limite_inv_succ</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">N</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">N</span><span class="o">,</span> <span class="mi">1</span><span class="bp">/</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">≤</span> <span class="n">ε</span>

<span class="kn">axiom</span> <span class="n">inv_succ_pos</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="mi">1</span><span class="bp">/</span><span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="mi">0</span>
</pre></div>


<p>because I couldn't see a way to prove them without devoting a whole lecture to casts and coes.</p>

<a name="161749221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/161749221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#161749221">Neil Strickland (Mar 26 2019 at 10:42)</a>:</h4>
<p>I've been doing some basic undergraduate exercises.  I think that this one is a good test case for the cast infrastructure:</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm"></span>
<span class="cm"> We are asked to pass judgement on the following &quot;definition&quot; :</span>

<span class="cm">  k : ℝ → ℤ sends x ∈ ℝ to the closest integer.</span>

<span class="cm"> We define precisely what it means for n to be the closest</span>
<span class="cm"> integer to x : we should have | x - m | &gt; | x - n | for any</span>
<span class="cm"> integer m ≠ n.  We then show that if m ∈ ℤ, there is no</span>
<span class="cm"> closest integer to m + 1/2.  From this we deduce that there</span>
<span class="cm"> is no function k with the expected properties.</span>

<span class="cm"> This is much harder work than you might think.  A lot of the</span>
<span class="cm"> problem is caused by the cast maps ℤ → ℚ → ℝ</span>
<span class="cm">-/</span>

<span class="n">def</span> <span class="n">is_closest_integer</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
 <span class="bp">∀</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span> <span class="n">m</span> <span class="bp">≠</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">abs</span> <span class="o">(</span> <span class="n">x</span> <span class="bp">-</span> <span class="n">m</span> <span class="o">)</span> <span class="bp">&gt;</span> <span class="n">abs</span> <span class="o">(</span> <span class="n">x</span> <span class="bp">-</span> <span class="n">n</span> <span class="o">)</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm"> Even basic identities like 1/2 - 1 = -1/2 cannot easily be</span>
<span class="cm"> proved directly in ℝ, because there are no general algorithms</span>
<span class="cm"> for exact calculation in ℝ.  We need to work in ℚ and then</span>
<span class="cm"> apply the cast map.</span>
<span class="cm">-/</span>

<span class="n">def</span> <span class="n">half_Q</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">2</span>
<span class="n">def</span> <span class="n">neg_half_Q</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="bp">-</span> <span class="n">half_Q</span>
<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">half_R</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">half_Q</span>
<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">neg_half_R</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="n">neg_half_Q</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm"> Here is a small identity that could in principle be proved</span>
<span class="cm"> by a long string of applications of the commutative ring axioms.</span>
<span class="cm"> The &quot;ring&quot; tactic automates the process of finding this string.</span>

<span class="cm"> For reasons that I do not fully understand, the ring tactic</span>
<span class="cm"> seems to work more reliably if we do it in a separate lemma</span>
<span class="cm"> so that the terms are just free variables.  We can then</span>
<span class="cm"> substitute values for this variables as an extra step.  In</span>
<span class="cm"> particular, we will substitute h = 1/2, and then give a</span>
<span class="cm"> separate argument that the final term 2 * h - 1 is zero.</span>
<span class="cm">-/</span>
<span class="kn">lemma</span> <span class="n">misc_identity</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="n">h</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
 <span class="o">(</span><span class="n">m</span> <span class="bp">+</span> <span class="n">h</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">-</span> <span class="o">((</span><span class="n">m</span> <span class="bp">+</span> <span class="n">h</span><span class="o">)</span> <span class="bp">-</span> <span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">h</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">by</span> <span class="n">ring</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm"> We now prove that there is no closest integer to m + 1/2.</span>
<span class="cm"> The obvious approach would be to focus attention on the</span>
<span class="cm"> candidates n = m and n = m + 1, but it turns out that that</span>
<span class="cm"> creates more work than necessary.  It is more efficient to</span>
<span class="cm"> prove that for all n, the integer k = 2 m + 1 - n is different</span>
<span class="cm"> from n and lies at the same distance from m + 1/2, so</span>
<span class="cm"> n does not have the required property.</span>
<span class="cm">-/</span>
<span class="kn">lemma</span> <span class="n">no_closest_integer</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span>
 <span class="bp">¬</span> <span class="o">(</span><span class="n">is_closest_integer</span> <span class="n">n</span> <span class="o">((</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">half_R</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">intro</span> <span class="n">h0</span><span class="o">,</span>
 <span class="k">let</span> <span class="n">x_Q</span> <span class="o">:</span> <span class="n">ℚ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">half_Q</span><span class="o">,</span>
 <span class="k">let</span> <span class="n">x_R</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">half_R</span><span class="o">,</span>
 <span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">-</span> <span class="n">n</span><span class="o">,</span>
 <span class="n">by_cases</span> <span class="n">e0</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span>
 <span class="o">{</span><span class="c1">-- In this block we consider the possibility that k = n, and</span>
  <span class="c1">-- show that it is impossible.</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">dsimp</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">at</span> <span class="n">e0</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">e1</span> <span class="o">:=</span> <span class="k">calc</span>
   <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">m</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">+</span> <span class="bp">-</span><span class="n">n</span><span class="o">)</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">m</span> <span class="o">:</span> <span class="k">by</span> <span class="n">ring</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">-</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">m</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span><span class="o">[</span><span class="n">e0</span><span class="o">]</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">ring</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">e2</span> <span class="o">:=</span> <span class="k">calc</span>
   <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">int</span><span class="bp">.</span><span class="n">mod</span> <span class="mi">1</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">rfl</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="n">int</span><span class="bp">.</span><span class="n">mod</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">m</span><span class="o">))</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">congr_arg</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">int</span><span class="bp">.</span><span class="n">mod</span> <span class="n">x</span> <span class="mi">2</span><span class="o">)</span> <span class="n">e1</span>
   <span class="bp">...</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">int</span><span class="bp">.</span><span class="n">mul_mod_right</span> <span class="mi">2</span> <span class="o">(</span><span class="n">n</span> <span class="bp">-</span> <span class="n">m</span><span class="o">),</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">dec_trivial</span> <span class="o">:</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">)</span> <span class="n">e2</span><span class="o">,</span>
 <span class="o">},{</span>
  <span class="k">let</span> <span class="n">h1</span> <span class="o">:=</span> <span class="n">ne_of_gt</span> <span class="o">(</span><span class="n">h0</span> <span class="n">k</span> <span class="n">e0</span><span class="o">),</span>
  <span class="k">let</span> <span class="n">u_R</span> <span class="o">:=</span> <span class="n">x_R</span> <span class="bp">-</span> <span class="n">n</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">v_R</span> <span class="o">:=</span> <span class="n">x_R</span> <span class="bp">-</span> <span class="n">k</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">v_R</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">u_R</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">half_R</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">begin</span>
   <span class="n">dsimp</span><span class="o">[</span><span class="n">u_R</span><span class="o">,</span><span class="n">v_R</span><span class="o">,</span><span class="n">x_R</span><span class="o">,</span><span class="n">k</span><span class="o">],</span>
   <span class="n">rw</span><span class="o">[</span><span class="n">int</span><span class="bp">.</span><span class="n">cast_add</span><span class="o">,</span><span class="n">int</span><span class="bp">.</span><span class="n">cast_add</span><span class="o">,</span><span class="n">int</span><span class="bp">.</span><span class="n">cast_mul</span><span class="o">,</span><span class="n">int</span><span class="bp">.</span><span class="n">cast_bit0</span><span class="o">],</span>
   <span class="n">rw</span><span class="o">[</span><span class="n">int</span><span class="bp">.</span><span class="n">cast_one</span><span class="o">,</span><span class="n">int</span><span class="bp">.</span><span class="n">cast_neg</span><span class="o">],</span>
   <span class="n">exact</span> <span class="n">misc_identity</span> <span class="o">(</span><span class="err">↑</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="err">↑</span> <span class="n">n</span><span class="o">)</span> <span class="n">half_R</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h3</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">half_Q</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">dec_trivial</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h4</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">half_R</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">=</span> <span class="o">(((</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">half_Q</span> <span class="bp">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℚ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">begin</span>
   <span class="n">dsimp</span><span class="o">[</span><span class="n">half_R</span><span class="o">],</span>
   <span class="n">rw</span><span class="o">[</span><span class="n">rat</span><span class="bp">.</span><span class="n">cast_add</span><span class="o">,</span><span class="n">rat</span><span class="bp">.</span><span class="n">cast_mul</span><span class="o">,</span><span class="n">rat</span><span class="bp">.</span><span class="n">cast_bit0</span><span class="o">,</span><span class="n">rat</span><span class="bp">.</span><span class="n">cast_neg</span><span class="o">,</span><span class="n">rat</span><span class="bp">.</span><span class="n">cast_one</span><span class="o">],</span>
  <span class="kn">end</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h5</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">half_R</span> <span class="bp">-</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span><span class="o">[</span><span class="n">h4</span><span class="o">,</span><span class="n">h3</span><span class="o">,</span><span class="n">rat</span><span class="bp">.</span><span class="n">cast_zero</span><span class="o">],</span>
  <span class="n">rw</span><span class="o">[</span><span class="n">h5</span><span class="o">,</span><span class="n">add_zero</span><span class="o">]</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h6</span> <span class="o">:</span> <span class="n">abs</span> <span class="n">v_R</span> <span class="bp">=</span> <span class="n">abs</span> <span class="n">u_R</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span><span class="o">[</span><span class="n">h2</span><span class="o">,</span><span class="n">abs_neg</span><span class="o">],</span>
  <span class="n">exact</span> <span class="n">h1</span> <span class="n">h6</span><span class="o">,</span>
 <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">k_does_not_exist</span> <span class="o">:</span> <span class="bp">¬</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="bp">ℤ</span><span class="o">),</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">is_closest_integer</span> <span class="o">(</span><span class="n">k</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">k</span><span class="o">,</span><span class="n">k_spec</span><span class="bp">⟩</span><span class="o">,</span>
 <span class="k">let</span> <span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="bp">+</span> <span class="n">half_R</span><span class="o">,</span>
 <span class="n">exact</span> <span class="n">no_closest_integer</span> <span class="o">(</span><span class="n">k</span> <span class="n">x</span><span class="o">)</span> <span class="mi">0</span> <span class="o">(</span><span class="n">k_spec</span> <span class="n">x</span><span class="o">)</span>
<span class="kn">end</span>
</pre></div>

<a name="161749440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/cast%20woes/near/161749440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/88074castwoes.html#161749440">Sebastien Gouezel (Mar 26 2019 at 10:46)</a>:</h4>
<p>Instead of <code>1/(n+1)</code>, you can use <code>((1:R)/2)^n</code> (and the fact that this sequence tends to <code>0</code>, which should already be there). No need to cast with this one.</p>


{% endraw %}
