---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/12393acombinatorialchallenge.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html">a combinatorial challenge</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="157604832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157604832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157604832">Johan Commelin (Feb 05 2019 at 13:05)</a>:</h4>
<p>Here is a nice little challenge that I don't really know how to formalise.<br>
We need graphs. What is a graph? In this case it will be a bunch of nodes and edges. No multiple edges, no self-loops, no directed edges.<br>
If <code>g</code> is a node, then <code>N(g)</code> is the set of its neighbouring nodes, so <code>{g' : G | (g,g') ∈ E(G)}</code>.</p>
<p>Let <code>G</code> be a finite connected graph. And let <code>w : G → pnat</code> be a function that labels the nodes of <code>G</code> with positive natural numbers. We say that <code>(G, w)</code> is <em>good</em> if it satisfies the following condition: for all <code>g : G</code> we have <code>2 * w(g) = sum_{g' ∈ N(g)} w(g')</code>.</p>
<p>Challenge: enumerate all good finite connected labeled graphs <code>(G, w)</code>.</p>

<a name="157606026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157606026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157606026">Chris Hughes (Feb 05 2019 at 13:26)</a>:</h4>
<p>Define "enumerate"</p>

<a name="157606386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157606386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157606386">Mario Carneiro (Feb 05 2019 at 13:33)</a>:</h4>
<p>ah, this is a step in the CFSG I think</p>

<a name="157606392"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157606392" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157606392">Mario Carneiro (Feb 05 2019 at 13:33)</a>:</h4>
<p>these are dynkin diagrams?</p>

<a name="157608176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608176">Johan Commelin (Feb 05 2019 at 14:02)</a>:</h4>
<p>Bingo! Now how do we put that in Lean?</p>

<a name="157608200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608200" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608200">Johan Commelin (Feb 05 2019 at 14:03)</a>:</h4>
<p>(Note, you don't get all Dynkin diagrams. Only the ones without multi-edges. And you'll also miss <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>.)</p>

<a name="157608351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608351">Mario Carneiro (Feb 05 2019 at 14:05)</a>:</h4>
<p>The list is pretty short, right? I thought it was a simple counting argument, but I doubt some general enumeration mechanism will help</p>

<a name="157608413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608413">Johan Commelin (Feb 05 2019 at 14:06)</a>:</h4>
<p>Should Dynkin diagrams be some sort of inductive type?</p>

<a name="157608422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608422">Johan Commelin (Feb 05 2019 at 14:06)</a>:</h4>
<p>I have no idea how to do graph theory in Lean.</p>

<a name="157608431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608431">Mario Carneiro (Feb 05 2019 at 14:06)</a>:</h4>
<p>Actually I'm thinking more about the math part here</p>

<a name="157608450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608450">Mario Carneiro (Feb 05 2019 at 14:07)</a>:</h4>
<p>the representation depends on how you intend to argue it</p>

<a name="157608541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608541">Johan Commelin (Feb 05 2019 at 14:08)</a>:</h4>
<p>I guess I agree with "a simple counting argument".</p>

<a name="157608666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608666">Mario Carneiro (Feb 05 2019 at 14:10)</a>:</h4>
<p>Do you know why the list is finite or how you argue for this?</p>

<a name="157608667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608667">Johan Commelin (Feb 05 2019 at 14:10)</a>:</h4>
<p>But what does that mean for formalising this?</p>

<a name="157608671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608671" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608671">Johan Commelin (Feb 05 2019 at 14:10)</a>:</h4>
<p>The list isn't exactly finite.</p>

<a name="157608690"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608690" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608690">Mario Carneiro (Feb 05 2019 at 14:10)</a>:</h4>
<p>do you know why it's tightly constrained</p>

<a name="157608693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608693">Johan Commelin (Feb 05 2019 at 14:10)</a>:</h4>
<p>Yes</p>

<a name="157608783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608783">Johan Commelin (Feb 05 2019 at 14:12)</a>:</h4>
<p>First you have to bound <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">#</mi><mi>N</mi><mo>(</mo><mi>g</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\# N(g)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathrm">#</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>.</p>

<a name="157608807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157608807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157608807">Johan Commelin (Feb 05 2019 at 14:12)</a>:</h4>
<p>After that you need a little argument with arithmetic progressions (of very short length).</p>

<a name="157609065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609065">Mario Carneiro (Feb 05 2019 at 14:17)</a>:</h4>
<p>So I guess you have an arbitrary graph, on an arbitrary type, and you produce a bijection to some known graph by cases</p>

<a name="157609086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609086">Mario Carneiro (Feb 05 2019 at 14:17)</a>:</h4>
<p>the graph itself can be represented by a symmetric irreflexive edge relation like you said</p>

<a name="157609400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609400">Mario Carneiro (Feb 05 2019 at 14:23)</a>:</h4>
<p>To prove graph isomorphism formally seems a little tedious. One general method: If you have an injective function on vertices, you know all the degrees of the vertices, and you have a list of edges that are mapped to the other graph, which matches the degrees, then you can prove that the map is a graph isomorphism</p>

<a name="157609467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609467">Mario Carneiro (Feb 05 2019 at 14:24)</a>:</h4>
<p>(I hate doing graphs formally, there's no great method)</p>

<a name="157609552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609552">Johan Commelin (Feb 05 2019 at 14:25)</a>:</h4>
<blockquote>
<p>(I hate doing graphs formally, there's no great method)</p>
</blockquote>
<p>That's discouraging.</p>

<a name="157609604"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609604" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609604">Mario Carneiro (Feb 05 2019 at 14:26)</a>:</h4>
<p>well, general graphs are fine, but small finite graphs are a pain</p>

<a name="157609630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609630" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609630">Mario Carneiro (Feb 05 2019 at 14:26)</a>:</h4>
<p>just like small finite anything</p>

<a name="157609659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609659">Mario Carneiro (Feb 05 2019 at 14:27)</a>:</h4>
<p>the less concretely you have to talk about the stuff, the better</p>

<a name="157609765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609765">Mario Carneiro (Feb 05 2019 at 14:28)</a>:</h4>
<p>so in this case you might be able to avoid doing graph isomorphism entirely, and instead say something like "there is a vertex of degree 3 attached to vertices of degree 2, there is a path to such and such with this pattern, etc"</p>

<a name="157609796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/a%20combinatorial%20challenge/near/157609796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/12393acombinatorialchallenge.html#157609796">Mario Carneiro (Feb 05 2019 at 14:28)</a>:</h4>
<p>and maybe that's good enough for whatever purpose you need this classification</p>


{% endraw %}
