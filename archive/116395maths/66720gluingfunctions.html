---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/66720gluingfunctions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html">gluing functions</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="171359646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171359646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171359646">Kenny Lau (Jul 21 2019 at 06:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">opens</span>

<span class="n">universes</span> <span class="n">v</span> <span class="n">u</span>
<span class="kn">open</span> <span class="n">topological_space</span> <span class="n">lattice</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span>

<span class="kn">set_option</span> <span class="n">old_structure_cmd</span> <span class="n">true</span>

<span class="kn">structure</span> <span class="n">presheaf</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">res</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="n">V</span> <span class="bp">≤</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">res_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="n">x</span><span class="o">,</span> <span class="n">res</span> <span class="n">U</span> <span class="n">U</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">U</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">res_res</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span> <span class="n">HVU</span> <span class="n">x</span><span class="o">,</span> <span class="n">res</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span> <span class="o">(</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">res</span> <span class="n">U</span> <span class="n">W</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">HWV</span> <span class="n">HVU</span><span class="o">)</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span>
<span class="kn">structure</span> <span class="n">covering</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="o">(</span><span class="n">map</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">map</span> <span class="n">i</span> <span class="bp">≤</span> <span class="n">U</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_of_mem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">i</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">map</span> <span class="n">i</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">X</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">sheaf</span> <span class="kn">extends</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">locality</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">OC</span> <span class="o">:</span> <span class="n">covering</span> <span class="n">U</span><span class="o">,</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span><span class="o">)</span> <span class="n">t</span><span class="o">)</span> <span class="bp">→</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">t</span><span class="o">)</span>
<span class="o">(</span><span class="n">gluing</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">OC</span> <span class="o">:</span> <span class="n">covering</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">S</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">F</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">),</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">res</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span> <span class="err">⊓</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">j</span><span class="o">)</span> <span class="n">inf_le_left</span> <span class="o">(</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="bp">=</span>
    <span class="n">res</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">j</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span> <span class="err">⊓</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">j</span><span class="o">)</span> <span class="n">inf_le_right</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">))</span> <span class="bp">→</span>
  <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">S</span> <span class="n">i</span><span class="o">)</span>

<span class="n">def</span> <span class="n">Func</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="n">sheaf</span><span class="bp">.</span><span class="o">{(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="n">u</span><span class="o">}</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">,</span>
  <span class="n">res</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="n">v</span><span class="o">,</span> <span class="n">s</span> <span class="bp">⟨</span><span class="n">v</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">HVU</span> <span class="n">v</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">res_self</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">res_res</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="n">locality</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span> <span class="n">t</span> <span class="n">OC</span> <span class="n">H</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">let</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hui</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="n">u</span> <span class="n">hu</span> <span class="k">in</span>
    <span class="k">have</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hui</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">gluing</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">OC</span> <span class="n">S</span> <span class="n">H</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">u</span><span class="o">,</span> <span class="n">S</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="err">$</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="n">u</span><span class="bp">.</span><span class="mi">1</span> <span class="n">u</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span>
      <span class="bp">⟨</span><span class="n">u</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="err">$</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="n">u</span><span class="bp">.</span><span class="mi">1</span> <span class="n">u</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">have</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">congr_fun</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span> <span class="err">$</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="err">$</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="n">u</span> <span class="err">$</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span> <span class="n">hu</span><span class="o">)</span>
      <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="err">$</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="n">u</span> <span class="err">$</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span> <span class="n">hu</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">this</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span> <span class="o">}</span>
</pre></div>

<a name="171395304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171395304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171395304">Johan Commelin (Jul 22 2019 at 00:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> That looks great!!</p>

<a name="171395373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171395373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171395373">Johan Commelin (Jul 22 2019 at 01:01)</a>:</h4>
<p>Maybe we should forget about sites for the moment. I do want to use functors though. I don't see any reason why you would handroll your own presheaves if their definition is defeq to functors (up to iota/eta for records [I always forget which Greek letter I need to invoke]).</p>

<a name="171402068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171402068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171402068">Kenny Lau (Jul 22 2019 at 04:21)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">opens</span>
<span class="n">def</span> <span class="n">covering_res</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span> <span class="o">:</span> <span class="n">covering</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">covering</span> <span class="n">V</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">ι</span> <span class="o">:=</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span>
  <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">V</span> <span class="err">⊓</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">,</span>
  <span class="n">map_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">inf_le_left</span><span class="o">,</span>
  <span class="n">exists_of_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hxV</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="bp">_</span> <span class="o">(</span><span class="n">H</span> <span class="n">hxV</span><span class="o">)</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">}</span>
<span class="kn">end</span> <span class="n">opens</span>

<span class="kn">structure</span> <span class="n">subpresheaf</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_set</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="n">set</span> <span class="o">(</span><span class="n">F</span> <span class="n">U</span><span class="o">))</span>
<span class="o">(</span><span class="n">res_mem_to_set</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">},</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">to_set</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">to_set</span> <span class="n">V</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">subpresheaf</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨_</span><span class="o">,</span> <span class="n">to_set</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">partial_order</span><span class="bp">.</span><span class="n">lift</span> <span class="n">to_set</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">mk</span><span class="bp">.</span><span class="n">inj_eq</span><span class="bp">.</span><span class="n">mpr</span><span class="o">)</span> <span class="n">infer_instance</span>

<span class="n">def</span> <span class="n">to_subsheaf</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">subpresheaf</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="o">{</span> <span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">OC</span> <span class="o">:</span> <span class="n">covering</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span><span class="o">)</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">S</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
  <span class="n">res_mem_to_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">OC</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">opens</span><span class="bp">.</span><span class="n">covering_res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">OC</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">have</span> <span class="bp">_</span> <span class="err">∈</span> <span class="n">S</span> <span class="o">((</span><span class="n">opens</span><span class="bp">.</span><span class="n">covering_res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">OC</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="n">S</span><span class="bp">.</span><span class="n">res_mem_to_set</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">hx</span> <span class="n">i</span><span class="o">),</span>
    <span class="k">by</span> <span class="n">rwa</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_res</span> <span class="n">at</span> <span class="n">this</span> <span class="err">⊢</span><span class="bp">⟩</span> <span class="o">}</span>

<span class="kn">theorem</span> <span class="n">le_to_subsheaf</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">S</span><span class="bp">.</span><span class="n">to_subsheaf</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">U</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="bp">⟨</span><span class="o">{</span> <span class="n">ι</span> <span class="o">:=</span> <span class="n">punit</span><span class="o">,</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">map_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">le_refl</span> <span class="n">U</span><span class="o">,</span> <span class="n">exists_of_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">hxU</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">punit</span><span class="bp">.</span><span class="n">star</span><span class="o">,</span> <span class="n">hxU</span><span class="bp">⟩</span> <span class="o">},</span>
<span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">by</span> <span class="n">rwa</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_self</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">to_presheaf</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">S</span> <span class="n">U</span><span class="o">,</span>
  <span class="n">res</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">x</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">S</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">res_self</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">x</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="err">$</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_self</span> <span class="n">U</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
  <span class="n">res_res</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span> <span class="n">HVU</span> <span class="n">x</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="err">$</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span> <span class="n">HVU</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">subpresheaf</span>

<span class="kn">structure</span> <span class="n">subsheaf</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">subpresheaf</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mem_of_res_mem</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">},</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">},</span> <span class="bp">∀</span> <span class="n">OC</span> <span class="o">:</span> <span class="n">covering</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">U</span><span class="o">,</span>
  <span class="o">(</span><span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">OC</span><span class="bp">.</span><span class="n">ι</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map_le</span> <span class="n">i</span><span class="o">)</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">to_set</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">))</span> <span class="bp">→</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">to_set</span> <span class="n">U</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">subsheaf</span>

<span class="n">def</span> <span class="n">to_sheaf</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">subsheaf</span> <span class="n">F</span><span class="bp">.</span><span class="n">to_presheaf</span><span class="o">)</span> <span class="o">:</span> <span class="n">sheaf</span> <span class="n">X</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">locality</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="bp">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">hs</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">ht</span><span class="bp">⟩</span> <span class="n">OC</span> <span class="n">H</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="err">$</span> <span class="n">F</span><span class="bp">.</span><span class="n">locality</span> <span class="n">U</span> <span class="n">s</span> <span class="n">t</span> <span class="n">OC</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span>
    <span class="k">have</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">val</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span><span class="o">),</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">gluing</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">OC</span> <span class="n">ss</span> <span class="n">H</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">hs</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">F</span><span class="bp">.</span><span class="n">gluing</span> <span class="n">U</span> <span class="n">OC</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">ss</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">)</span>
      <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="k">have</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">val</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span> <span class="n">j</span><span class="o">),</span> <span class="n">this</span><span class="o">)</span> <span class="k">in</span>
    <span class="bp">⟨⟨</span><span class="n">s</span><span class="o">,</span> <span class="n">S</span><span class="bp">.</span><span class="n">mem_of_res_mem</span> <span class="n">OC</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">show</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="err">∈</span> <span class="bp">_</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">hs</span><span class="bp">;</span> <span class="n">exact</span> <span class="o">(</span><span class="n">ss</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">eq</span> <span class="err">$</span> <span class="o">(</span><span class="n">hs</span> <span class="n">i</span><span class="o">)</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">S</span><span class="bp">.</span><span class="n">to_subpresheaf</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">subsheaf</span>

<span class="n">def</span> <span class="n">continuous_subsheaf</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">:</span> <span class="n">subsheaf</span> <span class="o">(</span><span class="n">Func</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="o">{</span> <span class="n">f</span> <span class="bp">|</span> <span class="n">continuous</span> <span class="n">f</span> <span class="o">},</span>
  <span class="n">res_mem_to_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span> <span class="n">hs</span><span class="bp">.</span><span class="n">comp</span> <span class="err">$</span> <span class="n">continuous_induced_rng</span> <span class="n">continuous_induced_dom</span><span class="o">,</span>
  <span class="n">mem_of_res_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span> <span class="n">OC</span> <span class="n">H</span><span class="o">,</span> <span class="n">continuous_iff_continuous_at</span><span class="bp">.</span><span class="mi">2</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hxU</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">let</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="n">x</span> <span class="n">hxU</span> <span class="k">in</span> <span class="bp">λ</span> <span class="n">V</span> <span class="n">HV</span><span class="o">,</span>
    <span class="k">let</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">htV</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="o">,</span> <span class="n">hut</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">hxt</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">mem_nhds_sets_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">continuous_iff_continuous_at</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="n">HV</span><span class="o">)</span> <span class="k">in</span>
    <span class="n">mem_nhds_sets_iff</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">subtype</span><span class="bp">.</span><span class="n">val</span> <span class="bp">⁻¹</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">subtype</span><span class="bp">.</span><span class="n">val</span> <span class="err">&#39;&#39;</span> <span class="n">t</span><span class="o">),</span>
      <span class="k">by</span> <span class="n">rintros</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">z</span><span class="o">,</span> <span class="n">hzt</span><span class="o">,</span> <span class="n">hzy</span><span class="bp">⟩;</span> <span class="n">dsimp</span> <span class="n">only</span> <span class="n">at</span> <span class="n">hzy</span><span class="bp">;</span> <span class="n">subst</span> <span class="n">hzy</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">htV</span> <span class="n">hzt</span><span class="o">,</span>
      <span class="bp">⟨</span><span class="n">u</span> <span class="err">∩</span> <span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">,</span> <span class="n">is_open_inter</span> <span class="n">hu</span> <span class="o">(</span><span class="n">OC</span><span class="bp">.</span><span class="n">map</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">hut</span><span class="o">,</span> <span class="n">subtype</span><span class="bp">.</span><span class="n">image_preimage_val</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">hxt</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">}</span>
</pre></div>

<a name="171403565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171403565" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171403565">Kenny Lau (Jul 22 2019 at 05:04)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">subpresheaf</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_sup</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">S</span> <span class="n">T</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">S</span> <span class="n">U</span> <span class="err">∪</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">imp</span> <span class="o">(</span><span class="n">S</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span><span class="o">)</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_inf</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">S</span> <span class="n">T</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">S</span> <span class="n">U</span> <span class="err">∩</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">imp</span> <span class="o">(</span><span class="n">S</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span><span class="o">)</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_Sup</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">SS</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="err">⋃</span> <span class="n">S</span> <span class="err">∈</span> <span class="n">SS</span><span class="o">,</span> <span class="n">to_set</span> <span class="n">S</span> <span class="n">U</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
<span class="k">let</span> <span class="bp">⟨</span><span class="n">S</span><span class="o">,</span> <span class="n">HS</span><span class="o">,</span> <span class="n">hsS</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_bUnion_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hs</span> <span class="k">in</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_bUnion_iff</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">S</span><span class="o">,</span> <span class="n">HS</span><span class="o">,</span> <span class="n">S</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span> <span class="n">hsS</span><span class="bp">⟩⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_Inf</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">SS</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="err">⋂</span> <span class="n">S</span> <span class="err">∈</span> <span class="n">SS</span><span class="o">,</span> <span class="n">to_set</span> <span class="n">S</span> <span class="n">U</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
<span class="n">set</span><span class="bp">.</span><span class="n">mem_bInter</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">HS</span><span class="o">,</span> <span class="n">S</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span> <span class="err">$</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_bInter_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hs</span> <span class="n">S</span> <span class="n">HS</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_top</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="bp">_</span><span class="o">,</span> <span class="n">trivial</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_bot</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="err">∅</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">,</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">complete_lattice</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">complete_lattice</span> <span class="o">(</span><span class="n">subpresheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le_sup_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_union_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">le_sup_right</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_union_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">sup_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S1</span> <span class="n">S2</span> <span class="n">S3</span> <span class="n">H13</span> <span class="n">H23</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">union_subset</span> <span class="o">(</span><span class="n">H13</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">H23</span> <span class="n">U</span><span class="o">),</span>
  <span class="n">inf_le_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">inf_le_right</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">le_inf</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S1</span> <span class="n">S2</span> <span class="n">S3</span> <span class="n">H12</span> <span class="n">H13</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_inter</span> <span class="o">(</span><span class="n">H12</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">H13</span> <span class="n">U</span><span class="o">),</span>
  <span class="n">le_top</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_univ</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">bot_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">empty_subset</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">le_Sup</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">SS</span> <span class="n">S</span> <span class="n">HS</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_bUnion_of_mem</span> <span class="n">HS</span><span class="o">,</span>
  <span class="n">Sup_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">SS</span> <span class="n">S</span> <span class="n">HS</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">bUnion_subset</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">T</span> <span class="n">HT</span><span class="o">,</span> <span class="n">HS</span> <span class="n">T</span> <span class="n">HT</span> <span class="n">U</span><span class="o">,</span>
  <span class="n">Inf_le</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">SS</span> <span class="n">S</span> <span class="n">HS</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">bInter_subset_of_mem</span> <span class="n">HS</span><span class="o">,</span>
  <span class="n">le_Inf</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">SS</span> <span class="n">S</span> <span class="n">HS</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_bInter</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">T</span> <span class="n">HT</span><span class="o">,</span> <span class="n">HS</span> <span class="n">T</span> <span class="n">HT</span> <span class="n">U</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">partial_order</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_sup</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_inf</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_Sup</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_Inf</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_top</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subpresheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_bot</span> <span class="n">F</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">subpresheaf</span>
</pre></div>

<a name="171404225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171404225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171404225">Kenny Lau (Jul 22 2019 at 05:24)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">subsheaf</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨_</span><span class="o">,</span> <span class="n">to_set</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">partial_order</span><span class="bp">.</span><span class="n">lift</span> <span class="n">to_set</span> <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx1</span><span class="o">,</span> <span class="n">hx2</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy1</span><span class="o">,</span> <span class="n">hy2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">mk</span><span class="bp">.</span><span class="n">inj_eq</span><span class="bp">.</span><span class="n">mpr</span><span class="o">)</span> <span class="n">infer_instance</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_inf</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">S</span> <span class="n">T</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">S</span> <span class="n">U</span> <span class="err">∩</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">imp</span> <span class="o">(</span><span class="n">S</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span><span class="o">)</span> <span class="o">(</span><span class="n">T</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span><span class="o">),</span>
  <span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span> <span class="n">OC</span> <span class="n">H</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">S</span><span class="bp">.</span><span class="mi">3</span> <span class="n">OC</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">T</span><span class="bp">.</span><span class="mi">3</span> <span class="n">OC</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_Inf</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">SS</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="err">⋂</span> <span class="n">S</span> <span class="err">∈</span> <span class="n">SS</span><span class="o">,</span> <span class="n">to_set</span> <span class="n">S</span> <span class="n">U</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
<span class="n">set</span><span class="bp">.</span><span class="n">mem_bInter</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">HS</span><span class="o">,</span> <span class="n">S</span><span class="bp">.</span><span class="mi">2</span> <span class="n">HVU</span> <span class="err">$</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_bInter_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hs</span> <span class="n">S</span> <span class="n">HS</span><span class="o">,</span>
<span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span> <span class="n">OC</span> <span class="n">H</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_bInter</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">HS</span><span class="o">,</span> <span class="n">S</span><span class="bp">.</span><span class="mi">3</span> <span class="n">OC</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_bInter_iff</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">H</span> <span class="n">i</span><span class="o">)</span> <span class="n">S</span> <span class="n">HS</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_top</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨⟨λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">univ</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="bp">_</span><span class="o">,</span> <span class="n">trivial</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">trivial</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="n">subsheaf</span><span class="bp">.</span><span class="n">semilattice_inf_top</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">semilattice_inf_top</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">inf_le_left</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">inf_le_right</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">le_inf</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S1</span> <span class="n">S2</span> <span class="n">S3</span> <span class="n">H12</span> <span class="n">H13</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_inter</span> <span class="o">(</span><span class="n">H12</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">H13</span> <span class="n">U</span><span class="o">),</span>
  <span class="n">le_top</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_univ</span> <span class="bp">_</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subsheaf</span><span class="bp">.</span><span class="n">partial_order</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subsheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_inf</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subsheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_Inf</span> <span class="n">F</span><span class="o">,</span>
  <span class="bp">..</span> <span class="n">subsheaf</span><span class="bp">.</span><span class="n">lattice</span><span class="bp">.</span><span class="n">has_top</span> <span class="n">F</span> <span class="o">}</span>

<span class="kn">theorem</span> <span class="n">Inf_le</span> <span class="o">(</span><span class="n">SS</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">))</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">HS</span> <span class="o">:</span> <span class="n">S</span> <span class="err">∈</span> <span class="n">SS</span><span class="o">)</span> <span class="o">:</span> <span class="n">Inf</span> <span class="n">SS</span> <span class="bp">≤</span> <span class="n">S</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">bInter_subset_of_mem</span> <span class="n">HS</span>

<span class="kn">theorem</span> <span class="n">le_Inf</span> <span class="o">(</span><span class="n">SS</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">subsheaf</span> <span class="n">F</span><span class="o">))</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">subsheaf</span> <span class="n">F</span><span class="o">)</span> <span class="o">(</span><span class="n">HS</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">b</span> <span class="err">∈</span> <span class="n">SS</span><span class="o">,</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">≤</span> <span class="n">Inf</span> <span class="n">SS</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset_bInter</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">T</span> <span class="n">HT</span><span class="o">,</span> <span class="n">HS</span> <span class="n">T</span> <span class="n">HT</span> <span class="n">U</span>

<span class="kn">end</span> <span class="n">subsheaf</span>
</pre></div>

<a name="171404315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171404315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171404315">Kenny Lau (Jul 22 2019 at 05:27)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">section_subsheaf</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">subsheaf</span> <span class="o">(</span><span class="n">Func</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">to_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span><span class="o">,</span> <span class="o">{</span> <span class="n">s</span> <span class="bp">|</span> <span class="bp">∀</span> <span class="n">u</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span> <span class="n">π</span> <span class="o">(</span><span class="n">s</span> <span class="n">u</span><span class="o">)</span> <span class="bp">=</span> <span class="n">u</span><span class="bp">.</span><span class="mi">1</span> <span class="o">},</span>
  <span class="n">res_mem_to_set</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">⟨</span><span class="n">v</span><span class="o">,</span> <span class="n">hv</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">hs</span> <span class="bp">⟨</span><span class="n">v</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="n">mem_of_res_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span> <span class="n">OC</span> <span class="n">H</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hu</span><span class="bp">⟩</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">OC</span><span class="bp">.</span><span class="n">exists_of_mem</span> <span class="n">u</span> <span class="n">hu</span> <span class="k">in</span> <span class="n">H</span> <span class="n">i</span> <span class="bp">⟨</span><span class="n">u</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="o">}</span>
</pre></div>

<a name="171404373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171404373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171404373">Kenny Lau (Jul 22 2019 at 05:28)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">continuous_section_subsheaf</span> <span class="o">(</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">π</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">subsheaf</span> <span class="o">(</span><span class="n">Func</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span><span class="bp">.</span><span class="n">to_presheaf</span> <span class="o">:=</span>
<span class="n">continuous_subsheaf</span> <span class="n">Y</span> <span class="err">⊓</span> <span class="n">section_subsheaf</span> <span class="n">Y</span> <span class="n">π</span>
</pre></div>

<a name="171404842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171404842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171404842">Johan Commelin (Jul 22 2019 at 05:42)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> What is your objection against using functors on <code>(opens X)^op</code>?</p>

<a name="171404872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171404872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171404872">Kenny Lau (Jul 22 2019 at 05:43)</a>:</h4>
<p>the large amount of unop required</p>

<a name="171404935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171404935" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171404935">Johan Commelin (Jul 22 2019 at 05:45)</a>:</h4>
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> Should we make a <code>cv_functor</code>?</p>

<a name="171405068"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171405068" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171405068">Johan Commelin (Jul 22 2019 at 05:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> Given that you already have this <code>covering</code> class. How hard do you think it is to generalise to sites?</p>

<a name="171405071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171405071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171405071">Johan Commelin (Jul 22 2019 at 05:49)</a>:</h4>
<p>Do you see particular troubles on the road?</p>

<a name="171405075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171405075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171405075">Kenny Lau (Jul 22 2019 at 05:49)</a>:</h4>
<p>I dont know</p>

<a name="171405342"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171405342" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171405342">Scott Morrison (Jul 22 2019 at 05:55)</a>:</h4>
<p><code>cv_functor</code> feels like we’d be unnecessarily multiplying entities.</p>

<a name="171405432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171405432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171405432">Scott Morrison (Jul 22 2019 at 05:56)</a>:</h4>
<p>I’m not so sure there is so much <code>unopened required. This is certainly the way I felt at first when you guys insists I couldn’t just define </code>opens X<code> as what is now </code>(opens X)^op`, but it never got particularly bad.</p>

<a name="171405443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171405443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171405443">Scott Morrison (Jul 22 2019 at 05:56)</a>:</h4>
<p>I don’t like essentially redefining functors here. It’s a recipe for duplication and confusion.</p>

<a name="171406066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171406066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171406066">Johan Commelin (Jul 22 2019 at 06:11)</a>:</h4>
<p>Is there a coordinated approach to navigate ourselves out of this mess? We've been talking about sheafy things for more than a year, and mathlib still doesn't have them.<br>
I'm fine with ignoring sites for the moment. There is loads of interesting stuff to say about sheaves on topological spaces.</p>

<a name="171421457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171421457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171421457">Kenny Lau (Jul 22 2019 at 11:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">germ</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">hxU</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span><span class="o">)</span>
<span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">germ</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">setoid</span> <span class="o">(</span><span class="n">germ</span> <span class="n">F</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">r</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">g1</span> <span class="n">g2</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span> <span class="bp">∧</span> <span class="bp">∃</span> <span class="n">H1</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">≤</span> <span class="n">g1</span><span class="bp">.</span><span class="n">U</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">H2</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">≤</span> <span class="n">g2</span><span class="bp">.</span><span class="n">U</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g1</span><span class="bp">.</span><span class="n">U</span> <span class="n">U</span> <span class="n">H1</span> <span class="n">g1</span><span class="bp">.</span><span class="n">s</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g2</span><span class="bp">.</span><span class="n">U</span> <span class="n">U</span> <span class="n">H2</span> <span class="n">g2</span><span class="bp">.</span><span class="n">s</span><span class="o">,</span>
  <span class="n">iseqv</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">g1</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">g1</span><span class="bp">.</span><span class="n">U</span><span class="o">,</span> <span class="n">g1</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">le_refl</span> <span class="bp">_</span><span class="o">,</span> <span class="n">le_refl</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">g1</span> <span class="n">g2</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">H1</span><span class="o">,</span> <span class="n">H2</span><span class="o">,</span> <span class="n">H3</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">H2</span><span class="o">,</span> <span class="n">H1</span><span class="o">,</span> <span class="n">H3</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">g1</span> <span class="n">g2</span> <span class="n">g3</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">H1</span><span class="o">,</span> <span class="n">H2</span><span class="o">,</span> <span class="n">H3</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">H4</span><span class="o">,</span> <span class="n">H5</span><span class="o">,</span> <span class="n">H6</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="bp">⟨</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hxU</span><span class="o">,</span> <span class="n">hxV</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">le_trans</span> <span class="n">inf_le_left</span> <span class="n">H1</span><span class="o">,</span> <span class="n">le_trans</span> <span class="n">inf_le_right</span> <span class="n">H5</span><span class="o">,</span>
      <span class="k">calc</span>  <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g1</span><span class="bp">.</span><span class="n">U</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">inf_le_left</span> <span class="n">H1</span><span class="o">)</span> <span class="n">g1</span><span class="bp">.</span><span class="n">s</span>
          <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="n">inf_le_left</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g1</span><span class="bp">.</span><span class="n">U</span> <span class="n">U</span> <span class="n">H1</span> <span class="n">g1</span><span class="bp">.</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_res</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="n">inf_le_left</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g2</span><span class="bp">.</span><span class="n">U</span> <span class="n">U</span> <span class="n">H2</span> <span class="n">g2</span><span class="bp">.</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">H3</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">V</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="n">inf_le_right</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g2</span><span class="bp">.</span><span class="n">U</span> <span class="n">V</span> <span class="n">H4</span> <span class="n">g2</span><span class="bp">.</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">F</span><span class="bp">.</span><span class="n">res_res</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_res</span><span class="o">]</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">V</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="n">inf_le_right</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g3</span><span class="bp">.</span><span class="n">U</span> <span class="n">V</span> <span class="n">H5</span> <span class="n">g3</span><span class="bp">.</span><span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">H6</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">g3</span><span class="bp">.</span><span class="n">U</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">inf_le_right</span> <span class="n">H5</span><span class="o">)</span> <span class="n">g3</span><span class="bp">.</span><span class="n">s</span> <span class="o">:</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_res</span><span class="bp">⟩⟩</span> <span class="o">}</span>

<span class="kn">end</span> <span class="n">germ</span>

<span class="n">def</span> <span class="n">stalk</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">quotient</span> <span class="o">(</span><span class="n">germ</span><span class="bp">.</span><span class="n">setoid</span> <span class="n">F</span> <span class="n">x</span><span class="o">)</span>

<span class="n">def</span> <span class="n">to_stalk</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">hxU</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">stalk</span> <span class="n">F</span> <span class="n">x</span> <span class="o">:=</span>
<span class="err">⟦</span><span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">s</span><span class="bp">⟩</span><span class="err">⟧</span>

<span class="kn">theorem</span> <span class="n">to_stalk_res</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">hxV</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">≤</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">to_stalk</span> <span class="n">F</span> <span class="n">x</span> <span class="n">V</span> <span class="n">hxV</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">)</span> <span class="bp">=</span> <span class="n">to_stalk</span> <span class="n">F</span> <span class="n">x</span> <span class="n">U</span> <span class="o">(</span><span class="n">HVU</span> <span class="n">hxV</span><span class="o">)</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">le_refl</span> <span class="n">V</span><span class="o">,</span> <span class="n">HVU</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res_res</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_⟩</span>

<span class="n">def</span> <span class="n">espace_etale</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="err">Σ</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">stalk</span> <span class="n">F</span> <span class="n">x</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="o">(</span><span class="n">espace_etale</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_open</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">hxU</span> <span class="o">:</span> <span class="n">sigma</span><span class="bp">.</span><span class="n">fst</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">,</span> <span class="n">to_stalk</span> <span class="n">F</span> <span class="n">x</span><span class="bp">.</span><span class="mi">1</span> <span class="n">U</span> <span class="n">hxU</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="n">p</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">hpU</span> <span class="o">:</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">U</span><span class="o">,</span> <span class="o">(</span><span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">to_stalk</span> <span class="n">F</span> <span class="n">p</span> <span class="n">U</span> <span class="n">hpU</span> <span class="n">s</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">espace_etale</span> <span class="n">F</span><span class="o">)</span> <span class="err">∈</span> <span class="n">S</span><span class="o">,</span>
  <span class="n">is_open_univ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">g</span><span class="bp">⟩</span> <span class="bp">_</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">g</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hpU</span><span class="o">,</span> <span class="n">s</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hpU</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">trivial</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">is_open_inter</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">T</span> <span class="n">HS</span> <span class="n">HT</span> <span class="n">x</span> <span class="n">hxST</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">hsx</span><span class="o">,</span> <span class="n">hs</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">HS</span> <span class="n">x</span> <span class="n">hxST</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
    <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hxV</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">htx</span><span class="o">,</span> <span class="n">ht</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">HT</span> <span class="n">x</span> <span class="n">hxST</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">W</span><span class="o">,</span> <span class="n">hxW</span><span class="o">,</span> <span class="n">HWU</span><span class="o">,</span> <span class="n">HWV</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">exact</span> <span class="o">(</span><span class="n">hsx</span><span class="bp">.</span><span class="n">trans</span> <span class="n">htx</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="k">in</span>
    <span class="bp">⟨</span><span class="n">W</span><span class="o">,</span> <span class="n">hxW</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">W</span> <span class="n">HWU</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">to_stalk_res</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">hsx</span><span class="o">,</span>
    <span class="bp">λ</span> <span class="n">q</span> <span class="n">hqW</span><span class="o">,</span> <span class="bp">⟨</span><span class="k">by</span> <span class="n">rw</span> <span class="n">to_stalk_res</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">hs</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">to_stalk_res</span><span class="o">]</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">ht</span><span class="bp">⟩⟩</span><span class="o">,</span>
  <span class="n">is_open_sUnion</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">SS</span> <span class="n">H</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">t</span><span class="o">,</span> <span class="n">htSS</span><span class="o">,</span> <span class="n">hxt</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_sUnion</span><span class="bp">.</span><span class="mi">1</span> <span class="n">hx</span><span class="o">,</span>
    <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">hsx</span><span class="o">,</span> <span class="n">hs</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">H</span> <span class="n">t</span> <span class="n">htSS</span> <span class="n">x</span> <span class="n">hxt</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">hxU</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">hsx</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">p</span> <span class="n">hpU</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_sUnion_of_mem</span> <span class="o">(</span><span class="n">hs</span> <span class="n">p</span> <span class="n">hpU</span><span class="o">)</span> <span class="n">htSS</span><span class="bp">⟩</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">of_espace_etale</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">espace_etale</span> <span class="n">F</span><span class="o">)</span> <span class="o">:</span> <span class="n">X</span> <span class="o">:=</span>
<span class="n">x</span><span class="bp">.</span><span class="mi">1</span>

<span class="kn">theorem</span> <span class="n">continuous_of_espace_etale</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="n">of_espace_etale</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">U</span> <span class="n">HU</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">g</span><span class="bp">⟩</span> <span class="n">hpU</span><span class="o">,</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">induction_on</span> <span class="n">g</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">V</span><span class="o">,</span> <span class="n">hpV</span><span class="o">,</span> <span class="n">s</span><span class="bp">⟩</span><span class="o">,</span>
<span class="bp">⟨⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">HU</span><span class="bp">⟩</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hpU</span><span class="o">,</span> <span class="n">hpV</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">V</span> <span class="bp">_</span> <span class="n">inf_le_right</span> <span class="n">s</span><span class="o">,</span> <span class="n">to_stalk_res</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">q</span> <span class="n">hqUV</span><span class="o">,</span> <span class="n">hqUV</span><span class="bp">.</span><span class="mi">1</span><span class="bp">⟩</span>
</pre></div>

<a name="171421618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171421618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171421618">Johan Commelin (Jul 22 2019 at 11:13)</a>:</h4>
<p>Kenny, you realise that presheaves and stalks are already in mathlib?</p>

<a name="171426874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171426874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171426874">Kevin Buzzard (Jul 22 2019 at 12:46)</a>:</h4>
<p>But are those presheaves usable? Kenny has <a href="https://github.com/ramonfmir/lean-scheme/blob/master/src/Kenny/sheaf_of_rings_on_opens.lean" target="_blank" title="https://github.com/ramonfmir/lean-scheme/blob/master/src/Kenny/sheaf_of_rings_on_opens.lean">glued sheaves of rings</a> and proved the universal property. Last time I talked to Scott he was still trying to work out the best way to define a sheaf. The schemes project has a definition of presheaf which is not the same as the one in mathlib but we are miles ahead of mathlib and it is my firm belief that because the mathlib definition is not the best way of doing sheaves in dependent type theory, that gap is only set to grow.</p>

<a name="171426994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171426994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171426994">Kevin Buzzard (Jul 22 2019 at 12:48)</a>:</h4>
<p>To define products of schemes we do it in the affine case and then glue the top space and glue the sheaves of rings. We need products and pullbacks etc to define cohomology. We have a system that works and is moving fast. You have a definition of a presheaf. Some serious decisions need to be made.</p>

<a name="171427038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427038">Kevin Buzzard (Jul 22 2019 at 12:49)</a>:</h4>
<p>I tried to <em>state</em> the construction of glueing presheaves of types using the mathlib language and it was a nightmare.</p>

<a name="171427279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427279">Johan Commelin (Jul 22 2019 at 12:53)</a>:</h4>
<p>I really don't understand this. Your definition of a presheaf is a special case of a contravariant functor. The mathlib definition is the same. I cannot see where the trouble lies.</p>

<a name="171427298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427298">Johan Commelin (Jul 22 2019 at 12:53)</a>:</h4>
<p>Sure, with the sheaf condition there might be trouble.</p>

<a name="171427322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427322">Johan Commelin (Jul 22 2019 at 12:53)</a>:</h4>
<p>I would very much like to see PR's going from the schemes project to mathlib. But I haven't seen any PR's apart from a 20 line thingy on kernels of ring morphisms.</p>

<a name="171427461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427461">Johan Commelin (Jul 22 2019 at 12:55)</a>:</h4>
<p>And I'm not saying that we have to use the category lib per se. But (i) avoiding duplication seems a good thing, and (ii) we'll need categorical machinery to build machines for cohomology theories. Unless we don't want those machines.</p>

<a name="171427520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427520">Kevin Buzzard (Jul 22 2019 at 12:56)</a>:</h4>
<p>I agree that we'll have to the the categorical language in the end.</p>

<a name="171427532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427532">Kevin Buzzard (Jul 22 2019 at 12:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> are you going to PR glueing sheaves of rings?</p>

<a name="171427656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427656">Kevin Buzzard (Jul 22 2019 at 12:58)</a>:</h4>
<blockquote>
<p>Sure, with the sheaf condition there might be trouble.</p>
</blockquote>
<p>We had no trouble at all with the sheaf condition. What is the trouble you are having? You say your presheaves are "the same" as ours but then sheaves might be trouble for you, and not for us?</p>

<a name="171427917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171427917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171427917">Johan Commelin (Jul 22 2019 at 13:00)</a>:</h4>
<p>I mean that if you want to state the sheaf condition using categorical language, saying that some diagram is an equalizer.</p>

<a name="171428060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171428060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171428060">Johan Commelin (Jul 22 2019 at 13:02)</a>:</h4>
<p>Kenny said he didn't like the <code>unop</code>s that our definition gave. Ok, I understand that. But that's life.</p>

<a name="171428087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171428087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171428087">Johan Commelin (Jul 22 2019 at 13:02)</a>:</h4>
<p>We have lot's of annoying little things popping up in our goals that you can't see in maths.</p>

<a name="171428119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171428119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171428119">Johan Commelin (Jul 22 2019 at 13:03)</a>:</h4>
<p>I don't like all the <code>to_additive</code> statements in mathlib. They are complete stupid. But it is the best solution we have.</p>

<a name="171428255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171428255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171428255">Johan Commelin (Jul 22 2019 at 13:04)</a>:</h4>
<p>Kenny and Mario did a wonderful job with the gluing of sheaves thing. Now it should go to mathlib, instead of rot away on a Zulip thread.</p>

<a name="171433738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171433738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171433738">Kevin Buzzard (Jul 22 2019 at 14:10)</a>:</h4>
<p>But they use a different definition of presheaf to the one in mathlib. I am not clear about how you want to take this forward.</p>

<a name="171436657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171436657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171436657">Johan Commelin (Jul 22 2019 at 14:45)</a>:</h4>
<p>Is it different from the one Kenny is using in this thread? Because the one in this thread is only syntactically different from the one in mathlib.</p>

<a name="171436748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171436748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171436748">Kevin Buzzard (Jul 22 2019 at 14:46)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">presheaf</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">F</span>     <span class="o">:</span> <span class="n">opens</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">res</span>   <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">),</span> <span class="n">F</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hid</span>   <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span><span class="o">),</span> <span class="n">res</span> <span class="n">U</span> <span class="n">U</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">refl</span> <span class="n">U</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hcomp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">HWV</span> <span class="o">:</span> <span class="n">W</span> <span class="err">⊆</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">),</span>
  <span class="n">res</span> <span class="n">U</span> <span class="n">W</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="n">HWV</span> <span class="n">HVU</span><span class="o">)</span> <span class="bp">=</span> <span class="n">res</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span> <span class="err">∘</span> <span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span><span class="o">)</span>
</pre></div>

<a name="171437001"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437001" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437001">Kevin Buzzard (Jul 22 2019 at 14:49)</a>:</h4>
<p>Mathlib:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">presheaf</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Top</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">})</span> <span class="o">:=</span> <span class="o">(</span><span class="n">opens</span> <span class="n">X</span><span class="o">)</span><span class="err">ᵒᵖ</span> <span class="err">⥤</span> <span class="n">C</span>
</pre></div>

<a name="171437085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437085" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437085">Johan Commelin (Jul 22 2019 at 14:50)</a>:</h4>
<p>But <code>⥤</code> expands to your <code>structure</code> (up to contravariance).</p>

<a name="171437242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437242">Kevin Buzzard (Jul 22 2019 at 14:52)</a>:</h4>
<p>so ours is slightly better for this use case because we don't have the <code>op</code> issues.</p>

<a name="171437292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437292">Kevin Buzzard (Jul 22 2019 at 14:53)</a>:</h4>
<p>I don't know how serious they are to deal with though, I have never used categories seriously.</p>

<a name="171437418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437418">Kevin Buzzard (Jul 22 2019 at 14:54)</a>:</h4>
<p>I can see Kenny's point of view though, he made what he needed in the simplest way and he knows how to work with it.</p>

<a name="171437454"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437454" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437454">Kevin Buzzard (Jul 22 2019 at 14:55)</a>:</h4>
<p>The issue that was holding me back was another one, namely the question on how to define a sheaf on an open subset of X.</p>

<a name="171437476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437476">Kevin Buzzard (Jul 22 2019 at 14:55)</a>:</h4>
<p>Kenny just defined it to be a sheaf on X.</p>

<a name="171437494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437494">Kevin Buzzard (Jul 22 2019 at 14:55)</a>:</h4>
<p>and then never used <code>=</code></p>

<a name="171437673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437673">Johan Commelin (Jul 22 2019 at 14:57)</a>:</h4>
<p>Sure, but that is orthogonal to whether you use the category library.</p>

<a name="171437748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437748">Kevin Buzzard (Jul 22 2019 at 14:58)</a>:</h4>
<p>Kenny is just using the definition which is most convenient for doing what it is he wants to do</p>

<a name="171437770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437770">Kevin Buzzard (Jul 22 2019 at 14:58)</a>:</h4>
<p>The category theory library offers this slightly more bundled experience and the added inconvenience of the ops.</p>

<a name="171437791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/gluing%20functions/near/171437791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/66720gluingfunctions.html#171437791">Kevin Buzzard (Jul 22 2019 at 14:59)</a>:</h4>
<p>I can see why he's chosen to do it this way.</p>


{% endraw %}

{% include archive_update.html %}