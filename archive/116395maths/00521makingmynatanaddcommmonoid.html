---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/00521makingmynatanaddcommmonoid.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html">making mynat an add_comm_monoid</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="169527348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169527348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169527348">Kevin Buzzard (Jul 02 2019 at 23:21)</a>:</h4>
<p>I was trying to prove that a home-rolled <code>nat</code> was an <code>add_comm_monoid</code>  in a way which was maximally mathematician-friendly, e.g. no leakage of <code>le</code> or <code>zero</code>: <a href="https://gist.github.com/kbuzzard/bec5f90d5e0a012696420f0f2430bedb" target="_blank" title="https://gist.github.com/kbuzzard/bec5f90d5e0a012696420f0f2430bedb">see gist</a>.</p>
<p>My understanding of how Lean works is that I am supposed to come up with a canonical representative for things like mynat.zero -- I choose <code>0</code>, and similarly I choose <code>1</code> for <code>one</code>. That's right, right?</p>
<p>On line 56 I have a <code>zero</code> which is something I never really wanted to see again. Is there a more high-powered tactic which will preserve my choice for <code>0</code> as the "canonical representative" of <code>mynat.zero</code>? </p>
<p>Is there a tactic that makes that instance on line 77 by just matching on names?</p>
<p>Finally lines 142 and 146 -- what is the incantation which makes these? I am so bad at making structures. Let's say that you must make an instance of <code>add_semigroup mynat</code> before you make the instance of <code>add_comm_semigroup mynat</code>.</p>

<a name="169539180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169539180" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169539180">Keeley Hoek (Jul 03 2019 at 04:49)</a>:</h4>
<p>Kevin I think your <code>by common_sense</code> actually is a pretty easily makable tactic</p>

<a name="169539182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169539182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169539182">Keeley Hoek (Jul 03 2019 at 04:49)</a>:</h4>
<p>I'll give it a go</p>

<a name="169539788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169539788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169539788">Keeley Hoek (Jul 03 2019 at 05:07)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">...</span>

<span class="kn">end</span> <span class="n">mynat</span>

<span class="kn">namespace</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>
<span class="kn">open</span> <span class="n">tactic</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">replace_special_names</span> <span class="o">:</span> <span class="n">name</span> <span class="bp">→</span> <span class="n">name</span>
<span class="bp">|</span> <span class="bp">`</span><span class="n">add</span> <span class="o">:=</span> <span class="bp">`</span><span class="n">has_add</span><span class="bp">.</span><span class="n">add</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">n</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">common_sense</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">t</span> <span class="err">←</span> <span class="n">target</span><span class="o">,</span>
   <span class="n">env</span> <span class="err">←</span> <span class="n">get_env</span><span class="o">,</span>
   <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
   <span class="bp">|</span> <span class="n">expr</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">expr</span><span class="bp">.</span><span class="n">const</span> <span class="n">sn</span> <span class="bp">_</span><span class="o">)</span> <span class="n">e</span> <span class="o">:=</span>
    <span class="k">match</span> <span class="n">env</span><span class="bp">.</span><span class="n">structure_fields</span> <span class="n">sn</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">some</span> <span class="n">l</span> <span class="o">:=</span>
    <span class="n">do</span> <span class="n">n</span> <span class="bp">::</span> <span class="bp">_</span> <span class="err">←</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">open_namespaces</span><span class="o">,</span>
       <span class="k">let</span> <span class="n">lf</span> <span class="o">:=</span> <span class="n">l</span><span class="bp">.</span><span class="n">map</span> <span class="n">replace_special_names</span><span class="o">,</span>
       <span class="n">v</span> <span class="err">←</span> <span class="n">lf</span><span class="bp">.</span><span class="n">mmap</span> <span class="n">resolve_name</span><span class="o">,</span>
       <span class="k">let</span> <span class="n">s</span> <span class="o">:</span> <span class="n">structure_instance_info</span> <span class="o">:=</span> <span class="o">{</span>
           <span class="n">struct</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">sn</span><span class="o">,</span>
           <span class="n">field_names</span> <span class="o">:=</span> <span class="n">l</span><span class="o">,</span>
           <span class="n">field_values</span> <span class="o">:=</span> <span class="n">v</span><span class="o">,</span>
       <span class="o">},</span>
       <span class="n">e</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="err">$</span> <span class="n">pexpr</span><span class="bp">.</span><span class="n">mk_structure_instance</span> <span class="n">s</span><span class="o">,</span>
       <span class="n">tactic</span><span class="bp">.</span><span class="n">exact</span> <span class="n">e</span>
    <span class="bp">|</span> <span class="n">none</span> <span class="o">:=</span> <span class="n">fail</span> <span class="s2">&quot;goal not a structure&quot;</span>
    <span class="kn">end</span>
   <span class="bp">|</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">fail</span> <span class="s2">&quot;unsupported goal&quot;</span>
   <span class="kn">end</span>

<span class="kn">end</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">namespace</span> <span class="n">mynat</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">add_monoid</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">common_sense</span>

<span class="bp">...</span>
</pre></div>

<a name="169544326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169544326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169544326">Kevin Buzzard (Jul 03 2019 at 07:00)</a>:</h4>
<p>It works! Thanks! I hate making structures. I will use it forever.</p>

<a name="169544666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169544666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169544666">Kevin Buzzard (Jul 03 2019 at 07:08)</a>:</h4>
<p>Oh this is great. I have no clue how you're supposed to prove that <code>mynat</code> is a <code>comm_semiring</code>. You seem to have to perform the incantations all in exactly the right order in the official way to do it. This way I can just not even care. I went to the end of my multiplication file and typed <code>instance : comm_semiring mynat := by common_sense</code> and it just gave me a list of the fields for which it has failed and what the error messages were for each. I can then just make them at the end of my multiplication file as part of an api. This is <em>brilliant</em>. </p>
<p>It's sort-of an idiot-proof structure maker.</p>

<a name="169554653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169554653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169554653">Scott Morrison (Jul 03 2019 at 10:21)</a>:</h4>
<p>Can we have this in mathlib? Maybe called <code>structure_helper</code>?</p>

<a name="169558300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169558300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169558300">Patrick Massot (Jul 03 2019 at 11:34)</a>:</h4>
<p>Kevin, could you post an updated gist using this tactic? It would make this conversation easier to understand</p>

<a name="169565725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169565725" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169565725">Kevin Buzzard (Jul 03 2019 at 13:25)</a>:</h4>
<p><a href="https://gist.github.com/kbuzzard/73237dbb64e70c482404d3780a4483c1" target="_blank" title="https://gist.github.com/kbuzzard/73237dbb64e70c482404d3780a4483c1">Structure tactic</a></p>
<p><a href="https://gist.github.com/kbuzzard/bec5f90d5e0a012696420f0f2430bedb" target="_blank" title="https://gist.github.com/kbuzzard/bec5f90d5e0a012696420f0f2430bedb">add_comm_monoid nat</a></p>

<a name="169567680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169567680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169567680">Patrick Massot (Jul 03 2019 at 13:49)</a>:</h4>
<p>Nice! I hope mathlib's naming convention won't interfere with merging this useful tactic</p>

<a name="169570909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169570909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169570909">Kevin Buzzard (Jul 03 2019 at 14:26)</a>:</h4>
<p><span class="user-mention" data-user-id="110111">@Keeley Hoek</span> </p>
<p>I can't make preorders because they have this weird <code>lt_iff_not_le</code> field.</p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">auto_param</span><span class="bp">.</span><span class="n">check_exists</span> <span class="n">false</span>
<span class="n">class</span> <span class="n">preorder</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">has_le</span> <span class="n">α</span><span class="o">,</span> <span class="n">has_lt</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">le_refl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">le_trans</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">)</span>
<span class="o">(</span><span class="n">lt</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">lt_iff_le_not_le</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span><span class="o">)</span> <span class="bp">.</span> <span class="n">order_laws_tac</span><span class="o">)</span>
</pre></div>


<p>I just want to not define <code>lt</code> or <code>lt_iff_le_not_le</code></p>
<div class="codehilite"><pre><span></span><span class="c1">-- import the tactic</span>
<span class="kn">inductive</span> <span class="n">mynat</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kn">namespace</span> <span class="n">mynat</span>

<span class="n">def</span> <span class="n">le</span> <span class="o">:</span> <span class="n">mynat</span> <span class="bp">→</span> <span class="n">mynat</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_le</span> <span class="n">mynat</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">le</span><span class="bp">⟩</span>
<span class="n">def</span> <span class="n">le_refl</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">mynat</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="c1">-- I think a,b,c should be implicit but Lean doesn&#39;t</span>
<span class="n">def</span> <span class="n">le_trans</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">mynat</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span> <span class="bp">→</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="c1">--instance : preorder mynat := by i_checked_all_teh_axioms -- fails</span>
<span class="c1">-- unknown identifier &#39;lt&#39;</span>

<span class="n">def</span> <span class="n">lt</span> <span class="o">:</span> <span class="n">mynat</span> <span class="bp">→</span> <span class="n">mynat</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:=</span>  <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">a</span>

<span class="c1">-- instance : preorder mynat := by i_checked_all_teh_axioms -- fails</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">type mismatch at field &#39;lt_iff_le_not_le&#39;</span>
<span class="cm">  lt_iff_le_not_le</span>
<span class="cm">has type</span>
<span class="cm">  ?m_3 &lt; ?m_4 ↔ ?m_3 ≤ ?m_4 ∧ ¬?m_4 ≤ ?m_3</span>
<span class="cm">but is expected to have type</span>
<span class="cm">  auto_param (∀ (a b : mynat), a &lt; b ↔ a ≤ b ∧ ¬b ≤ a) (name.mk_string &quot;order_laws_tac&quot; name.anonymous)</span>
<span class="cm">-/</span>

<span class="kn">end</span> <span class="n">mynat</span>
<span class="c">/-</span><span class="cm"></span>
<span class="cm">class preorder (α : Type u) extends has_le α, has_lt α :=</span>
<span class="cm">(le_refl : ∀ a : α, a ≤ a)</span>
<span class="cm">(le_trans : ∀ a b c : α, a ≤ b → b ≤ c → a ≤ c)</span>
<span class="cm">(lt := λ a b, a ≤ b ∧ ¬ b ≤ a)</span>
<span class="cm">(lt_iff_le_not_le : ∀ a b : α, a &lt; b ↔ (a ≤ b ∧ ¬ b ≤ a) . order_laws_tac)</span>
<span class="cm">-/</span>
</pre></div>

<a name="169571250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169571250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169571250">Scott Morrison (Jul 03 2019 at 14:30)</a>:</h4>
<p>Ah, we'll have to add something that checks if a field is wrapped with <code>auto_param</code>, and then tries running the embedded tactic.</p>

<a name="169571347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169571347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169571347">Mario Carneiro (Jul 03 2019 at 14:31)</a>:</h4>
<p>or <code>opt_param</code> in the case of <code>lt</code></p>

<a name="169572735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169572735" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169572735">Andrew Ashworth (Jul 03 2019 at 14:47)</a>:</h4>
<p>hmm, wasn't there a hole tactic that did this as well that I saw posted awhile back? I may be misremembering</p>

<a name="169572917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169572917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169572917">Patrick Massot (Jul 03 2019 at 14:48)</a>:</h4>
<p>Do you mean <a href="https://github.com/leanprover-community/mathlib/blob/d001abfd48d64ac27310590458132009f47c852d/src/tactic/core.lean#L718" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/d001abfd48d64ac27310590458132009f47c852d/src/tactic/core.lean#L718">https://github.com/leanprover-community/mathlib/blob/d001abfd48d64ac27310590458132009f47c852d/src/tactic/core.lean#L718</a>? It's slightly different</p>

<a name="169573027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169573027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169573027">Andrew Ashworth (Jul 03 2019 at 14:50)</a>:</h4>
<p>ah, I think that is what I was thinking of</p>

<a name="169573853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169573853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169573853">Kevin Buzzard (Jul 03 2019 at 14:59)</a>:</h4>
<p>I just want to not even bother defining <code>lt</code> and <code>lt_iff_le_not_le</code> here</p>

<a name="169574950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/making%20mynat%20an%20add_comm_monoid/near/169574950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/00521makingmynatanaddcommmonoid.html#169574950">Scott Morrison (Jul 03 2019 at 15:11)</a>:</h4>
<p>Yes, that's what we're proposing. Keeley's tactic should be able to identify <code>opt_param</code> or <code>auto_param</code> fields, and handle them automatically.</p>


{% endraw %}

{% include archive_update.html %}