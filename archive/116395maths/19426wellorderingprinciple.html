---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/19426wellorderingprinciple.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html">well-ordering principle</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="188423358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188423358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188423358">Nicholas McConnell (Feb 18 2020 at 04:41)</a>:</h4>
<p>Does mathlib have a builtin well-ordering principle?  If not, here is my attempt to create one: how should I start?</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">WOP</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="bp">→</span> <span class="n">k</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="188423515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188423515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188423515">Chris Hughes (Feb 18 2020 at 04:46)</a>:</h4>
<p><code>nat.find </code> will compute this <code>n</code> for you.</p>

<a name="188423521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188423521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188423521">Nicholas McConnell (Feb 18 2020 at 04:47)</a>:</h4>
<p>Ah okay thanks</p>

<a name="188423644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188423644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188423644">Nicholas McConnell (Feb 18 2020 at 04:51)</a>:</h4>
<p>I'm not sure how to use it?</p>

<a name="188427457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188427457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188427457">Johan Commelin (Feb 18 2020 at 06:51)</a>:</h4>
<p>If you hit <code>Ctrl</code>-<code>Shift</code>-<code>p</code> in VScode, and then type <code>#nat.find</code> you'll find all the lemmas about it.</p>

<a name="188431362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188431362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188431362">Kevin Buzzard (Feb 18 2020 at 08:20)</a>:</h4>
<p>(and yes, mathlib has a bunch of stuff about general well-orderings as well, although in the case of nat there is more)</p>

<a name="188432471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188432471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188432471">Kevin Buzzard (Feb 18 2020 at 08:43)</a>:</h4>
<p>PS <code>k ≥ n</code> is the same as <code>n ≤ k</code> and as a general convention we stick to <code>≤</code> because e.g. then you don't have to state every lemma involving <code>≤</code> twice.</p>

<a name="188432727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188432727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188432727">Kevin Buzzard (Feb 18 2020 at 08:49)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">def</span> <span class="n">yadayadayada</span> <span class="o">:=</span> <span class="mi">37</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">lemma</span> <span class="n">WOP</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="bp">→</span> <span class="n">k</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">use</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find_spec</span> <span class="n">h</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">k</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find_min&#39;</span> <span class="n">h</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="188514768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514768">Nicholas McConnell (Feb 19 2020 at 04:19)</a>:</h4>
<p>My point is that I'm confused about this:</p>
<div class="codehilite"><pre><span></span><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">find</span> <span class="n">prime</span>
<span class="n">term</span>
  <span class="n">prime</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="err">?</span><span class="n">m_1</span> <span class="n">n</span> <span class="o">:</span> <span class="kt">Prop</span>
</pre></div>


<p>What on earth is the type named via an existential quantifier?</p>

<a name="188514828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514828">Mario Carneiro (Feb 19 2020 at 04:21)</a>:</h4>
<p>You have to provide a proof that some prime exists, and it returns the least prime</p>

<a name="188514834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514834">Nicholas McConnell (Feb 19 2020 at 04:21)</a>:</h4>
<p>Oh okay...</p>

<a name="188514948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514948">Nicholas McConnell (Feb 19 2020 at 04:24)</a>:</h4>
<p>I tried this with a proof that some k exists with k % 4 = 2, but I doubt this is the way to find the smallest such k</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">someK</span> <span class="o">:</span> <span class="bp">∃</span><span class="o">(</span><span class="n">k</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">),</span> <span class="n">k</span> <span class="err">%</span> <span class="mi">4</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">use</span> <span class="mi">10</span><span class="o">,</span>
<span class="n">ring</span><span class="o">,</span>
<span class="kn">end</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find</span><span class="o">(</span><span class="n">someK</span><span class="o">)</span>
</pre></div>

<a name="188514972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514972">Alex J. Best (Feb 19 2020 at 04:25)</a>:</h4>
<p>Try <code>#eval nat.find someK</code> it will return 2 so looks like it does the right thing to me.</p>

<a name="188514975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514975">Nicholas McConnell (Feb 19 2020 at 04:25)</a>:</h4>
<p>Ah thanks</p>

<a name="188515611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188515611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188515611">Nicholas McConnell (Feb 19 2020 at 04:46)</a>:</h4>
<p>In here, I feel like I'm supposed to change "0 &lt; a * a" in the goal to "a * 0 &lt; a * a" and then use mul_lt_mul_of_pos_left, but I'm not sure how to...</p>
<div class="codehilite"><pre><span></span><span class="mi">2</span> <span class="n">goals</span>
<span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span>
<span class="err">⊢</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span>
</pre></div>


{% endraw %}

{% include archive_update.html %}