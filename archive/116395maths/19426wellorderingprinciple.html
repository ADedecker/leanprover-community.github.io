---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/19426wellorderingprinciple.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html">well-ordering principle</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="188423358"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188423358" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188423358">Nicholas McConnell (Feb 18 2020 at 04:41)</a>:</h4>
<p>Does mathlib have a builtin well-ordering principle?  If not, here is my attempt to create one: how should I start?</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">WOP</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="bp">→</span> <span class="n">k</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="188423515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188423515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188423515">Chris Hughes (Feb 18 2020 at 04:46)</a>:</h4>
<p><code>nat.find </code> will compute this <code>n</code> for you.</p>

<a name="188423521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188423521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188423521">Nicholas McConnell (Feb 18 2020 at 04:47)</a>:</h4>
<p>Ah okay thanks</p>

<a name="188423644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188423644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188423644">Nicholas McConnell (Feb 18 2020 at 04:51)</a>:</h4>
<p>I'm not sure how to use it?</p>

<a name="188427457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188427457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188427457">Johan Commelin (Feb 18 2020 at 06:51)</a>:</h4>
<p>If you hit <code>Ctrl</code>-<code>Shift</code>-<code>p</code> in VScode, and then type <code>#nat.find</code> you'll find all the lemmas about it.</p>

<a name="188431362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188431362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188431362">Kevin Buzzard (Feb 18 2020 at 08:20)</a>:</h4>
<p>(and yes, mathlib has a bunch of stuff about general well-orderings as well, although in the case of nat there is more)</p>

<a name="188432471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188432471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188432471">Kevin Buzzard (Feb 18 2020 at 08:43)</a>:</h4>
<p>PS <code>k ≥ n</code> is the same as <code>n ≤ k</code> and as a general convention we stick to <code>≤</code> because e.g. then you don't have to state every lemma involving <code>≤</code> twice.</p>

<a name="188432727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188432727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188432727">Kevin Buzzard (Feb 18 2020 at 08:49)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">def</span> <span class="n">yadayadayada</span> <span class="o">:=</span> <span class="mi">37</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">lemma</span> <span class="n">WOP</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">k</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="bp">→</span> <span class="n">k</span> <span class="bp">≥</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">use</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find_spec</span> <span class="n">h</span><span class="o">},</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">k</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find_min&#39;</span> <span class="n">h</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="188514768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514768">Nicholas McConnell (Feb 19 2020 at 04:19)</a>:</h4>
<p>My point is that I'm confused about this:</p>
<div class="codehilite"><pre><span></span><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">find</span> <span class="n">prime</span>
<span class="n">term</span>
  <span class="n">prime</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">∃</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="err">?</span><span class="n">m_1</span> <span class="n">n</span> <span class="o">:</span> <span class="kt">Prop</span>
</pre></div>


<p>What on earth is the type named via an existential quantifier?</p>

<a name="188514828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514828">Mario Carneiro (Feb 19 2020 at 04:21)</a>:</h4>
<p>You have to provide a proof that some prime exists, and it returns the least prime</p>

<a name="188514834"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514834" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514834">Nicholas McConnell (Feb 19 2020 at 04:21)</a>:</h4>
<p>Oh okay...</p>

<a name="188514948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514948">Nicholas McConnell (Feb 19 2020 at 04:24)</a>:</h4>
<p>I tried this with a proof that some k exists with k % 4 = 2, but I doubt this is the way to find the smallest such k</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">someK</span> <span class="o">:</span> <span class="bp">∃</span><span class="o">(</span><span class="n">k</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">),</span> <span class="n">k</span> <span class="err">%</span> <span class="mi">4</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">use</span> <span class="mi">10</span><span class="o">,</span>
<span class="n">ring</span><span class="o">,</span>
<span class="kn">end</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">nat</span><span class="bp">.</span><span class="n">find</span><span class="o">(</span><span class="n">someK</span><span class="o">)</span>
</pre></div>

<a name="188514972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514972">Alex J. Best (Feb 19 2020 at 04:25)</a>:</h4>
<p>Try <code>#eval nat.find someK</code> it will return 2 so looks like it does the right thing to me.</p>

<a name="188514975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188514975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188514975">Nicholas McConnell (Feb 19 2020 at 04:25)</a>:</h4>
<p>Ah thanks</p>

<a name="188515611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188515611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188515611">Nicholas McConnell (Feb 19 2020 at 04:46)</a>:</h4>
<p>In here, I feel like I'm supposed to change "0 &lt; a * a" in the goal to "a * 0 &lt; a * a" and then use mul_lt_mul_of_pos_left, but I'm not sure how to...</p>
<div class="codehilite"><pre><span></span><span class="mi">2</span> <span class="n">goals</span>
<span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span>
<span class="err">⊢</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span>
</pre></div>

<a name="188516111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188516111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188516111">Alex J. Best (Feb 19 2020 at 05:00)</a>:</h4>
<p>Using the library <code>library_search</code> tactic I found <code>exact mul_pos' p p</code></p>

<a name="188516128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188516128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188516128">Scott Morrison (Feb 19 2020 at 05:01)</a>:</h4>
<p>haha, I was seconds behind:</p>
<div class="codehilite"><pre><span></span>example (n : ℤ) (a : 0 &lt; n) : 0 &lt; n * n := by library_search
</pre></div>

<a name="188516142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188516142" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188516142">Alex J. Best (Feb 19 2020 at 05:01)</a>:</h4>
<p>the strategy you wanted you can achieve via</p>
<div class="codehilite"><pre><span></span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="o">(</span> <span class="n">int</span><span class="bp">.</span><span class="n">mul_zero</span> <span class="n">a</span><span class="o">)],</span>
 <span class="n">exact</span> <span class="n">mul_lt_mul_of_pos_left</span> <span class="n">p</span> <span class="n">p</span><span class="o">,</span>
</pre></div>

<a name="188597781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188597781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188597781">Nicholas McConnell (Feb 19 2020 at 23:45)</a>:</h4>
<p>Thanks</p>

<a name="188598891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188598891" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188598891">Nicholas McConnell (Feb 20 2020 at 00:01)</a>:</h4>
<p>Another general question, is there any way to use a lemma statement?</p>
<p>For example, is there a command which can use lt_trichotomy to turn this</p>
<div class="codehilite"><pre><span></span><span class="mi">1</span> <span class="n">goal</span>
<span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="bp">¬</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span>
<span class="err">⊢</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="err">^</span> <span class="mi">2</span>
</pre></div>


<p>into this?</p>
<div class="codehilite"><pre><span></span><span class="mi">1</span> <span class="n">goal</span>
<span class="n">a</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">p</span> <span class="o">:</span> <span class="bp">¬</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span>
<span class="n">q</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">∨</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="mi">0</span>
<span class="err">⊢</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="err">^</span> <span class="mi">2</span>
</pre></div>

<a name="188599461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188599461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188599461">Mario Carneiro (Feb 20 2020 at 00:12)</a>:</h4>
<p><code>have q := lt_trichotomy 0 a</code> will do that</p>

<a name="188606372"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188606372" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188606372">Nicholas McConnell (Feb 20 2020 at 02:54)</a>:</h4>
<p>Thanks.  Sorry if I'm overwhelming you guys with questions, I am totally new to Lean</p>

<a name="188607397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188607397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188607397">Nicholas McConnell (Feb 20 2020 at 03:25)</a>:</h4>
<p>(deleted)</p>

<a name="188608048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188608048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188608048">Nicholas McConnell (Feb 20 2020 at 03:45)</a>:</h4>
<p>In proving this, I just need to be able to use p &gt; 0 to get 0 ≠ ↑p (something I can apply s to).  What's the <em>best</em> way you know to do this?  [I feel like I could come up with one myself but it would be unnecessarily overwhelming]</p>
<div class="codehilite"><pre><span></span><span class="mi">1</span> <span class="n">goal</span>
<span class="n">a</span> <span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span>
<span class="n">q</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span><span class="o">,</span>
<span class="n">r</span> <span class="o">:</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">≤</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span><span class="o">,</span>
<span class="n">s</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≠</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="err">↑</span><span class="n">p</span> <span class="err">^</span> <span class="mi">2</span>
<span class="err">⊢</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span>
</pre></div>

<a name="188609703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188609703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188609703">Alex J. Best (Feb 20 2020 at 04:34)</a>:</h4>
<p>Not that it matters too much to the answer but : What is the cast <code>↑</code> to? Integers, reals? I.e. what is the actual lemma statement you are proving ?</p>

<a name="188609775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188609775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188609775">Mario Carneiro (Feb 20 2020 at 04:36)</a>:</h4>
<p>Seems like <code>norm_cast</code> will help a lot to clean that up</p>

<a name="188610115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188610115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188610115">Nicholas McConnell (Feb 20 2020 at 04:45)</a>:</h4>
<p><span class="user-mention silent" data-user-id="127136">Alex J. Best</span> <a href="#narrow/stream/116395-maths/topic/well-ordering.20principle/near/188609703" title="#narrow/stream/116395-maths/topic/well-ordering.20principle/near/188609703">said</a>:</p>
<blockquote>
<p>Not that it matters too much to the answer but : What is the cast <code>↑</code> to? Integers, reals? I.e. what is the actual lemma statement you are proving ?</p>
</blockquote>
<p>Integers.  I confess that I didn't know ↑ had multiple meanings</p>

<a name="188610176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188610176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188610176">Alex J. Best (Feb 20 2020 at 04:47)</a>:</h4>
<p>It means cast in general, so it could be casting nats to reals or rationals or whatever and it will just be printed in the same way. As mario says, whenever you have such a cast the tactic norm_cast can often reduce you back to the case where there are none.</p>

<a name="188610295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188610295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188610295">Alex J. Best (Feb 20 2020 at 04:50)</a>:</h4>
<p>Don't know if you wanted a full answer or not, but here is one way of concluding:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">q</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="o">(</span><span class="err">↑</span><span class="n">a</span> <span class="o">:</span><span class="bp">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="o">(</span><span class="err">↑</span><span class="n">p</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">)</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">≤</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≠</span> <span class="o">(</span><span class="err">↑</span><span class="n">p</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">)</span> <span class="bp">→</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="err">↑</span><span class="n">p</span> <span class="err">^</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">a</span> <span class="bp">+</span> <span class="err">↑</span><span class="n">p</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">p</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">norm_cast</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">specialize</span> <span class="n">s</span> <span class="o">(</span><span class="n">ne_of_lt</span> <span class="n">hp</span><span class="o">),</span>
<span class="n">rw</span> <span class="o">[</span><span class="n">nat</span><span class="bp">.</span><span class="n">pow_two</span><span class="o">]</span> <span class="n">at</span> <span class="n">s</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_of_lt_of_le</span> <span class="n">s</span> <span class="n">r</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="188610363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188610363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188610363">Alex J. Best (Feb 20 2020 at 04:52)</a>:</h4>
<p>And the exact same proof still applies even if we started with reals or whatever as after norm_cast we end up in the same state.</p>

<a name="188611419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188611419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188611419">Nicholas McConnell (Feb 20 2020 at 05:27)</a>:</h4>
<p>Thank you greatly.  I am learning Lean slowly but surely</p>

<a name="188617880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188617880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188617880">Patrick Massot (Feb 20 2020 at 08:18)</a>:</h4>
<blockquote>
<p><code>have q := lt_trichotomy 0 a</code> will do that</p>
</blockquote>
<p>This works but doesn't teach Nicholas what he should have done. <span class="user-mention" data-user-id="263857">@Nicholas McConnell</span> what you wanted here was to type:</p>
<div class="codehilite"><pre><span></span><span class="k">have</span> <span class="n">q</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">∨</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">library_search</span><span class="o">,</span>
</pre></div>


<p>and look at the messages view.</p>

<a name="188618183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188618183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188618183">Kevin Buzzard (Feb 20 2020 at 08:25)</a>:</h4>
<p>I know from experience of watching students that this one is hard to find because you have to get the three terms in the right order and I think &lt; vs &gt; might also matter</p>

<a name="188619030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188619030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188619030">Patrick Massot (Feb 20 2020 at 08:43)</a>:</h4>
<p>Nicholas had the right statement!</p>

<a name="188619069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188619069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188619069">Patrick Massot (Feb 20 2020 at 08:43)</a>:</h4>
<p>But it's true that library_search would find the variations. That would be a job for Gabriel.</p>

<a name="188656833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188656833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188656833">Nicholas McConnell (Feb 20 2020 at 17:09)</a>:</h4>
<p><a href="/user_uploads/3121/KNUIIBNpeX8YqZtMhhe9pVR4/bandicam-2020-02-20-12-06-47-319.mp4" target="_blank" title="bandicam-2020-02-20-12-06-47-319.mp4">bandicam-2020-02-20-12-06-47-319.mp4</a> </p>
<p>So I tried using nat.find.  You say I'm supposed to pass in a proposition that a natural number satisfying a certain property exists, and then it'll return the smallest one.  I thought in the general case, it would return a new variable and adjoin conditions "it satisfies it" and "nothing smaller satisfies it."  But this is happening instead.  What should I really do?</p>

<a name="188657112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188657112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188657112">Kevin Buzzard (Feb 20 2020 at 17:12)</a>:</h4>
<p>I can't watch the video on my phone because of download issues but iirc nat.find just produces a natural, and then lean also supplies the theorems saying that nat.find h satisfies all the things you want it to satisfy</p>

<a name="188657147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188657147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188657147">Kevin Buzzard (Feb 20 2020 at 17:12)</a>:</h4>
<p>But the theorems are a different part of the api</p>

<a name="188658806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188658806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188658806">Floris van Doorn (Feb 20 2020 at 17:31)</a>:</h4>
<p>You want to write <code>open_locale classical</code> near the top of your file (but not directly after the <code>import</code> statements). Then Lean will stop complaining about predicates being decidable.</p>

<a name="188658898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188658898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188658898">Floris van Doorn (Feb 20 2020 at 17:32)</a>:</h4>
<p>Also, you want to use <code>let ds := nat.find d</code>, not <code>have</code>. <code>have</code> is for proofs of propositions, and Lean will forget how you proved them. <code>let</code> is for data, and Lean will remember how you defined them.</p>

<a name="188658969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/well-ordering%20principle/near/188658969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/19426wellorderingprinciple.html#188658969">Floris van Doorn (Feb 20 2020 at 17:33)</a>:</h4>
<p><code>nat.find</code> itself will only give you the natural number. You can then use <code>nat.find_spec</code> and <code>nat.find_min</code> (or <code>nat.find_min'</code>) to know the properties about this natural number.</p>


{% endraw %}

{% include archive_update.html %}