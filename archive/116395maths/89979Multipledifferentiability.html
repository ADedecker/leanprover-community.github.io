---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/89979Multipledifferentiability.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html">Multiple differentiability</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="164404643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164404643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164404643">Sebastien Gouezel (Apr 28 2019 at 20:09)</a>:</h4>
<p>I have a universe polymorphism question in the definition of multiple differentiability. The definition I have currently is</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">times_cont_diff_on</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">n</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="bp">∀</span><span class="o">{</span><span class="n">E</span><span class="o">:</span><span class="kt">Type</span> <span class="n">v</span><span class="o">},</span> <span class="bp">∀</span><span class="o">{</span><span class="n">F</span><span class="o">:</span><span class="kt">Type</span> <span class="n">v</span><span class="o">},</span>
  <span class="bp">∀</span><span class="o">[</span><span class="n">hE</span><span class="o">:</span><span class="n">normed_space</span> <span class="n">k</span> <span class="n">E</span><span class="o">],</span> <span class="bp">∀</span><span class="o">[</span><span class="n">hF</span><span class="o">:</span><span class="n">normed_space</span> <span class="n">k</span> <span class="n">F</span><span class="o">],</span> <span class="bp">∀</span><span class="n">f</span> <span class="o">:</span> <span class="n">E</span><span class="bp">→</span><span class="n">F</span><span class="o">,</span> <span class="bp">∀</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">E</span><span class="o">,</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="mi">0</span><span class="o">)</span>     <span class="o">:=</span> <span class="bp">λ</span><span class="n">E</span> <span class="n">F</span> <span class="n">hE</span> <span class="n">hF</span> <span class="n">f</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">resetI</span><span class="o">,</span> <span class="n">exact</span> <span class="n">continuous_on</span> <span class="n">f</span> <span class="n">s</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span> <span class="bp">λ</span><span class="n">E</span> <span class="n">F</span> <span class="n">hE</span> <span class="n">hF</span> <span class="n">f</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">resetI</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">fdifferentiable_on</span> <span class="n">k</span> <span class="n">f</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">times_cont_diff_on</span> <span class="n">n</span> <span class="o">(</span><span class="bp">λ</span><span class="n">x</span><span class="o">,</span> <span class="n">fderiv_at_within</span> <span class="n">k</span> <span class="n">f</span> <span class="n">x</span> <span class="n">s</span><span class="o">)</span> <span class="n">s</span> <span class="o">}</span>
<span class="bp">|</span> <span class="n">none</span>         <span class="o">:=</span> <span class="bp">λ</span><span class="n">E</span> <span class="n">F</span> <span class="n">hE</span> <span class="n">hF</span> <span class="n">f</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">resetI</span><span class="o">,</span>
    <span class="n">exact</span> <span class="o">(</span><span class="bp">∀</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">times_cont_diff_on</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">with_top</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">}</span>
<span class="n">using_well_founded</span> <span class="o">{</span>
  <span class="n">rel_tac</span> <span class="o">:=</span> <span class="bp">λ_</span> <span class="bp">_</span><span class="o">,</span> <span class="bp">`</span><span class="o">[</span><span class="n">exact</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">well_founded_lt</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_wf</span><span class="bp">⟩</span><span class="o">],</span>
  <span class="n">dec_tac</span> <span class="o">:=</span> <span class="bp">`</span><span class="o">[</span><span class="n">apply</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">coe_lt_top</span> <span class="bp">&lt;|&gt;</span> <span class="n">apply</span> <span class="n">with_top</span><span class="bp">.</span><span class="n">some_lt_some</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">lt_add_one</span> <span class="bp">_</span><span class="o">)]</span> <span class="o">}</span>
</pre></div>


<p>In this definition, I define inductively what it means for a function <code>f : E -&gt; F</code> to be <code>n</code> times continuously differentiable on a set <code>s</code>. For <code>n=0</code>, it is just continuous. For <code>n+1</code>, it means that <code>f</code> is differentiable, and its derivative is <code>n</code> times continuously differentiable (but now from the space <code>E</code> to the space <code>E -&gt;L[k] F</code> of bounded linear maps from <code>E</code> to <code>F</code>). If <code>E</code> and <code>F</code> live in the same universe <code>v</code>, everything is fine. But if <code>E</code> lives in <code>v</code> and <code>F</code> in <code>w</code>, then <code>E -&gt;L[k] F</code> lives in <code>max v w</code> and my induction is not correct any more. The options I see:<br>
* keep <code>E</code> and <code>F</code> in the same universe and be content with it.<br>
* have an auxiliary definition where <code>E</code> is in <code>v</code> and <code>F</code> in <code>max v w</code>. And use it for the inductive step of the general case. Inductions become much more cumbersome (statements should first be proved for the auxiliary definition, and then the main one).<br>
* Or some better trick I don't know.</p>
<p>Comments welcome!</p>

<a name="164404797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164404797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164404797">Kevin Buzzard (Apr 28 2019 at 20:13)</a>:</h4>
<p>My comment is that I spent 25 years of my life doing mathematics in one universe and I never had any problems whatsover. I know they tell us to be universe polymorphic here but I would like to interpret that as "just use one universe u". I was encouraged by the CS people to have objects in one universe and morphisms in a different universe in category theory -- because why not? -- and I think it just makes a terrible mess of things. I hereby propose that if you're actually doing sensible mathematics then you just stick to one universe until someone gives you a really good reason not to. I am yet to see a convincing argument for using more than one universe in mathematics.</p>

<a name="164404922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164404922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164404922">Sebastien Gouezel (Apr 28 2019 at 20:15)</a>:</h4>
<p>My main problem with this is that, if someone starts a file with <code>variables {E : Type*} {F : Type*}</code> and tries to define a <code>C^2</code> map from <code>E</code> to <code>F</code>, then Lean complains with a hard to understand error message. But from the mathematical point of view, I am also completely happy to do everything in one universe (or even in Type).</p>

<a name="164404984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164404984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164404984">Kevin Buzzard (Apr 28 2019 at 20:16)</a>:</h4>
<p>So they should be doing maths in one universe too!</p>

<a name="164405004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164405004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164405004">Kevin Buzzard (Apr 28 2019 at 20:17)</a>:</h4>
<p>When I made schemes I made them all in <code>Type</code>. But when Ramon made them, he switched to a universe polymorphic set-up.</p>

<a name="164405072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164405072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164405072">Kevin Buzzard (Apr 28 2019 at 20:18)</a>:</h4>
<p>I tried using the category theory library and I had universe identification nightmares. Every category I had was either a large category (like rings) or a small category (like some graph of a directed system coming from <code>nhds x</code>). I never needed more than one universe. I don't get why they always want us to use lots of universes. This is maths!</p>

<a name="164405207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164405207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164405207">Sebastien Gouezel (Apr 28 2019 at 20:21)</a>:</h4>
<p>OK, let's go for <code>E</code> and <code>F</code> in the same universe, unless someone complains.</p>

<a name="164405260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164405260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164405260">Kevin Buzzard (Apr 28 2019 at 20:22)</a>:</h4>
<p>It would be interesting to hear what the CS people have to say. For me, the fact that it causes you trouble being multiply universe polymorphic in a situation where there is mathematically no foundational issue at all, means that being multiply universe polymorphic is the wrong idea in mathematics. Sure use one universe. But the set theorists always ask me why I need more than one (this happened in Freiburg this week and it's not the first time).</p>

<a name="164405338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164405338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164405338">Kevin Buzzard (Apr 28 2019 at 20:24)</a>:</h4>
<p>One of my plans for later on is to refactor the schemes project using <span class="user-mention" data-user-id="110087">@Scott Morrison</span> 's category theory library, and I would like to start with using only small and large categories, and one universe only. For me it will then be easy to do universe unification by hand because I know exactly which categories are small and which ones are large.</p>

<a name="164405491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164405491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164405491">Kevin Buzzard (Apr 28 2019 at 20:28)</a>:</h4>
<p>I had exactly universe unification issues with perfectoid spaces when we tried using categories and it put me off to an extent that I decided not to use them, and instead try to import them into Ramon's scheme project later. I really want to see category theory being used more and next time I am absolutely sticking with one universe.</p>

<a name="164420619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164420619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164420619">Johan Commelin (Apr 29 2019 at 03:08)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> Thanks for working on this. The last time there was discussion about this, I think you said you were using <code>enat</code>. Now I see that you are using <code>with_top nat</code>. Can you comment on the change? I was thinking <code>enat</code> might be easier for applications (because you avoid the <code>infty</code>-case).</p>

<a name="164427698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164427698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164427698">Sebastien Gouezel (Apr 29 2019 at 06:09)</a>:</h4>
<p>I tried first with <code>enat</code>, but since the definition and the proofs are really inductive, it turned out to be much more convenient in <code>with_top nat</code>. I wouldn't know how to write the definition in <code>enat</code>, in fact!</p>

<a name="164429347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164429347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164429347">Johan Commelin (Apr 29 2019 at 06:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> You said that a coinductive approach might be a good idea. Could you help us out?</p>

<a name="164429440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple%20differentiability/near/164429440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/89979Multipledifferentiability.html#164429440">Mario Carneiro (Apr 29 2019 at 06:51)</a>:</h4>
<p>I think this definition should be done in two parts rather than using a messy recursion. Define what C^k means first for k : nat, and then define it for <code>k : enat</code> by extension</p>


{% endraw %}
