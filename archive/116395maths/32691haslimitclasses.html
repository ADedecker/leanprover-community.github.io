---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/116395maths/32691haslimitclasses.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/32691haslimitclasses.html">has_* limit classes</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="175075706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_%2A%20limit%20classes/near/175075706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/32691haslimitclasses.html#175075706">Reid Barton (Sep 06 2019 at 15:32)</a>:</h4>
<p>We now have a whole slew of limit-related classes beyond <code>has_limit</code>, <code>has_limits_of_shape</code> and <code>has_limits</code>, namely<br>
<code>has_terminal</code>, <code>has_binary_products</code>, <code>has_finite_products</code>, <code>has_products</code>, <code>has_equalizers</code>, <code>has_pullbacks</code>, <code>has_finite_limits</code>.<br>
What is the plan for making instances of all these classes?</p>

<a name="175075767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_%2A%20limit%20classes/near/175075767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/32691haslimitclasses.html#175075767">Reid Barton (Sep 06 2019 at 15:33)</a>:</h4>
<p>For example, here is a concrete question. In Top the binary product is given by the usual product of spaces, whose underlying type is the product of the underlying types. Should that be how <code>has_binary_products Top</code> is defined?</p>

<a name="175075948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_%2A%20limit%20classes/near/175075948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/32691haslimitclasses.html#175075948">Reid Barton (Sep 06 2019 at 15:35)</a>:</h4>
<p>Or should it agree with the product which comes from <code>has_limits</code>, which will be of the form a subtype of a Pi type, and will definitely not be equal (at least not provably equal) to <code>X Ã— Y</code>?</p>

<a name="175084096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_%2A%20limit%20classes/near/175084096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/32691haslimitclasses.html#175084096">Reid Barton (Sep 06 2019 at 17:13)</a>:</h4>
<p>I tried looking at other category theory libraries, namely the Lean 2 HoTT library and UniMath, although they may have different concerns than we do.<br>
In the Lean 2 HoTT library, <code>has_binary_products</code> is simply defined to be (reducibly) <code>has_limits_of_shape</code> for a particular shape category (just two objects and no nonidentity morphisms). That is one extreme option. However, using a class that is reducible doesn't seem to work very well in Lean 3 (based on comments in that file, it might not have worked very well in Lean 2 either).<br>
UniMath has two (or sometimes even more) definitions of each of these special types of limits, one defined generically as a limit and one which is direct, and prove their equivalence. They're not afraid to write a lot of stuff! On the other hand they don't use type classes at all, so they don't have the question of which of these relationships to make into instances.</p>

<a name="175084175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_%2A%20limit%20classes/near/175084175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/32691haslimitclasses.html#175084175">Reid Barton (Sep 06 2019 at 17:14)</a>:</h4>
<p>Trying to define an instance <code>has_binary_products Top</code> by hand, I'm quickly led to the conclusion that one ought to define a specialized <code>is_binary_product</code> (like UniMath does) and then prove its equivalence to the general limit concept.</p>

<a name="175092632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_%2A%20limit%20classes/near/175092632" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/32691haslimitclasses.html#175092632">Reid Barton (Sep 06 2019 at 18:48)</a>:</h4>
<p>Actually it's surprisingly awkward even to prove that anything has binary products</p>

<a name="175092680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/has_%2A%20limit%20classes/near/175092680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/32691haslimitclasses.html#175092680">Reid Barton (Sep 06 2019 at 18:49)</a>:</h4>
<p>That is, other than by some general limit construction. If you really want to make use of the fact that you're defining a binary product.</p>


{% endraw %}

{% include archive_update.html %}