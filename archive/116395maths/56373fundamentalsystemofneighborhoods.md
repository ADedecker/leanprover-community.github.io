---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/56373fundamentalsystemofneighborhoods.html
---

## Stream: [maths](index.html)
### Topic: [fundamental system of neighborhoods](56373fundamentalsystemofneighborhoods.html)

---


{% raw %}
#### [ Johan Commelin (Oct 04 2018 at 13:24)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135166983):
<p>Do we have the notion of a <em>fundamental system of neighborhoods of 0</em> for topological groups?</p>

#### [ Kevin Buzzard (Oct 04 2018 at 14:30)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135171190):
<p>This would be a basis for the filter <code>nhds 0</code>, right? Or are you asking for more?</p>

#### [ Johan Commelin (Oct 04 2018 at 14:35)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135171928):
<p>It probably is. I just don't know enough about filters to be sure...</p>

#### [ Kevin Buzzard (Oct 04 2018 at 14:42)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135173055):
<p>I read some blog post about filters recently. Here are two examples of filters on a topological space X. Choose x in X. Then (1) the set of all subsets of X containing x is a filter (the principal filter). But much more interesting (2) the set of all subsets V of X such that x is in the interior of V -- this is also a filter. This is the filter of neighbourhoods of x and it comes up a lot. For example one can formalise the notion that a map of topological spaces f:X -&gt; Y is continuous at a point x using this neighbourhood filter (more naive attempts at a definition, such as "pre-image of an open set containing f(x) is open" are hopelessly poorly behaved and wrong; the filter language is perfect for this). If F is a filter and V is in F then any set containing V is also in F, so you could imagine a filter being generated by a subset and the construction basically being that you throw in any set that contains one of your basis sets; if your basis is well-behaved then this will be a filter. I think this is the notion you want. Any V whose interior contains 0 will contain as a subset some element of your fundamental system.</p>

#### [ Johan Commelin (Oct 04 2018 at 14:46)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135173763):
<p>Ok, so I want to write <code>(nhds 0) = "the smallest filter containing {myset}"</code>. Is that right?</p>

#### [ Johan Commelin (Oct 04 2018 at 14:46)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135173818):
<p>That would mean that <code>{myset}</code> is a fundamental system of neighbourhoods around 0.</p>

#### [ Kevin Buzzard (Oct 04 2018 at 14:49)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135174187):
<p>I think that's right. It probably goes something like this (and you could easily check in Lean!) If B is a bunch of subsets of X (maybe B has to be non-empty), and if the intersection of any two elements of B contains an element of B, then I think that the set F of all subsets of X with the property that they contain an element of B, should be a filter. I'm thinking of B as a fund system of nhds of x and <code>F = nhds x</code>. Hopefully someone will correct me if I've missed something.</p>

#### [ Kevin Buzzard (Oct 04 2018 at 14:51)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135174575):
<p>I'm pretty sure that arbitrary intersection of filters is a filter, so one can always look at the filter generated by a random collection of subsets of X, but in the basis case it's simpler because you only have to look at sets containing a basis element, rather than sets containing a finite intersection of basis elements. These were just my thoughts after reading the definition, I don't know some reference where this is all treated succinctly and clearly, although I would imagine that there will be one somewhere.</p>

#### [ Johannes Hölzl (Oct 04 2018 at 14:51)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135174585):
<p>The smallest filter containing <code>s</code> is <code>filter.generate s</code> (<a href="https://github.com/leanprover/mathlib/blob/master/order/filter.lean#L241" target="_blank" title="https://github.com/leanprover/mathlib/blob/master/order/filter.lean#L241">https://github.com/leanprover/mathlib/blob/master/order/filter.lean#L241</a>)</p>

#### [ Kevin Buzzard (Oct 04 2018 at 14:52)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135174787):
<p>But it would be easier to prove stuff about the smallest filter containing s if s had some nice properties to start with, because then you wouldn't need all the cases in the inductive definition.</p>

#### [ Johannes Hölzl (Oct 04 2018 at 14:52)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135174846):
<p>Note that the order on filter is flipped, i.e. the arbitrary set-intersection of the sets of filters is the supremum on filters.</p>

#### [ Kevin Buzzard (Oct 04 2018 at 14:54)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135175198):
<p>Thanks Johannes for that important reminder! I'm sure there's some logic to it but it always makes me very nervous about filters. There is I think both top and bottom filters, but I am always a bit confused about whether the empty set is allowed to be an element of a filter, and whether the empty collection is a filter. Conventions maybe differ in different places?</p>

#### [ Kevin Buzzard (Oct 04 2018 at 14:54)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135175242):
<p>In particular I never seem to know what is top and bot :-)</p>

#### [ Patrick Massot (Oct 04 2018 at 14:56)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135175587):
<p><a href="https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/topological_groups.lean#L102" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/topological_groups.lean#L102">https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/topological_groups.lean#L102</a></p>

#### [ Johannes Hölzl (Oct 04 2018 at 14:57)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135175922):
<p>the empty set is not a filter, the filter containing the empty set is the bottom filter</p>

#### [ Johan Commelin (Oct 04 2018 at 15:00)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135176397):
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> Why do you ask <code>pure 0 ≤ Z</code>? Why not equality?</p>

#### [ Johan Commelin (Oct 04 2018 at 15:00)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135176446):
<p>I've got the very ugly</p>
<div class="codehilite"><pre><span></span><span class="o">(</span><span class="n">filter</span><span class="bp">.</span><span class="n">generate</span> <span class="o">{</span><span class="n">U&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">,</span> <span class="n">U&#39;</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">y</span><span class="err">^</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span><span class="o">}}</span> <span class="bp">=</span> <span class="o">(</span><span class="n">nhds</span> <span class="mi">0</span><span class="o">))</span>
</pre></div>

#### [ Kevin Buzzard (Oct 04 2018 at 15:00)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135176459):
<p>Note that if a filter contains the empty set then it contains all sets, and because of this backwards convention this is the one at the bottom</p>

#### [ Johan Commelin (Oct 04 2018 at 15:00)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135176522):
<p>I hope that is the same thing as: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><msup><mi>U</mi><mi>n</mi></msup><mi mathvariant="normal">∣</mi><mi>n</mi><mo>≥</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\{ U^n | n \ge 1 \}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">{</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span><span class="mord mathrm">∣</span><span class="mord mathit">n</span><span class="mrel">≥</span><span class="mord mathrm">1</span><span class="mclose">}</span></span></span></span> forms a neighbourhood basis of <code>0</code>.</p>

#### [ Johannes Hölzl (Oct 04 2018 at 15:06)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135177578):
<p><code>Z</code> is supposed to be the neighborhood filter around <code>0</code>. <code>Z = pure 0</code> would be wrong, it would result in the discrete topology.</p>

#### [ Johannes Hölzl (Oct 04 2018 at 15:11)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135178743):
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> there are some rules to work with <code>generate</code>. The best is to use <code>le_antisymm</code>, one side is reduced with <code>sets_iff_generate </code> to the inclusion that all generated elements are neighborhoods. For the other direction it depends on your topology which base element you can select</p>

#### [ Johan Commelin (Oct 04 2018 at 15:14)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135179271):
<p>Hmm, I'll have to try and figure out if I can make sense of that.</p>

#### [ Johan Commelin (Oct 04 2018 at 15:14)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135179296):
<p>I need to prove</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">tfae_i_to_ii</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">U</span> <span class="n">T</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">,</span> <span class="n">T</span> <span class="err">⊆</span> <span class="n">U</span> <span class="bp">∧</span> <span class="n">set</span><span class="bp">.</span><span class="n">finite</span> <span class="n">T</span> <span class="bp">∧</span>
<span class="o">(</span><span class="n">filter</span><span class="bp">.</span><span class="n">generate</span> <span class="o">{</span><span class="n">U&#39;</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">n</span> <span class="o">:</span> <span class="n">pnat</span><span class="o">,</span> <span class="n">U&#39;</span> <span class="bp">=</span> <span class="o">{</span><span class="n">x</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">y</span> <span class="o">:</span> <span class="n">A</span><span class="o">,</span> <span class="n">y</span><span class="err">^</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span><span class="o">}}</span> <span class="bp">=</span> <span class="o">(</span><span class="n">nhds</span> <span class="mi">0</span><span class="o">))</span> <span class="bp">∧</span>
<span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">t</span> <span class="err">∈</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="err">∈</span> <span class="n">U</span><span class="o">),</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">t</span> <span class="bp">*</span> <span class="n">u</span><span class="o">}</span> <span class="bp">=</span> <span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">t</span> <span class="err">∈</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="err">∈</span> <span class="n">U</span><span class="o">),</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">t</span> <span class="bp">*</span> <span class="n">u</span><span class="o">}</span> <span class="bp">∧</span>
<span class="o">{</span><span class="n">y</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">t</span> <span class="err">∈</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="err">∈</span> <span class="n">U</span><span class="o">),</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">t</span> <span class="bp">*</span> <span class="n">u</span><span class="o">}</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="bp">→</span>
<span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">A₀</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="o">[</span><span class="n">h</span> <span class="o">:</span> <span class="n">is_subring</span> <span class="n">A₀</span><span class="o">],</span> <span class="k">by</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">is_ring_of_definition</span> <span class="n">A₀</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
 <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">Tsub</span><span class="o">,</span> <span class="n">Tfin</span><span class="o">,</span> <span class="n">hnhds</span><span class="o">,</span> <span class="n">hTU</span><span class="o">,</span> <span class="n">hU2</span><span class="bp">⟩</span><span class="o">,</span>
 <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

#### [ Johan Commelin (Oct 04 2018 at 15:14)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135179311):
<p>It looks really scary</p>

#### [ Johannes Hölzl (Oct 04 2018 at 15:18)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135180278):
<p>Uh, the <code>haveI</code> is super ugly. One more reason to not use type classes too often...<br>
I think I would prefer if you use <code>@is_ring_of_definition ...</code></p>

#### [ Johan Commelin (Oct 04 2018 at 15:20)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135180692):
<p>Hmm... we should just have bundled subrings (-;</p>

#### [ Johannes Hölzl (Oct 04 2018 at 15:20)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135180717):
<p>also an option</p>

#### [ Johannes Hölzl (Oct 04 2018 at 15:21)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135180743):
<p>what is <code>is_ring_of_definition</code>?</p>

#### [ Johan Commelin (Oct 04 2018 at 15:21)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135180784):
<p>Also nasty (-;</p>

#### [ Johan Commelin (Oct 04 2018 at 15:22)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135180942):
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_ring_of_definition</span> <span class="o">(</span><span class="n">A₀</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subring</span> <span class="n">A₀</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="n">is_open</span> <span class="n">A₀</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A₀</span><span class="o">)</span> <span class="o">[</span><span class="n">hJ</span> <span class="o">:</span> <span class="n">is_ideal</span> <span class="n">J</span><span class="o">]</span> <span class="o">(</span><span class="n">gen</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A₀</span><span class="o">),</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">finite</span> <span class="n">gen</span> <span class="bp">∧</span> <span class="n">span</span> <span class="n">gen</span> <span class="bp">=</span> <span class="n">J</span><span class="o">)</span> <span class="bp">∧</span>
<span class="o">(</span><span class="k">by</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">topological_subring</span> <span class="n">A₀</span><span class="bp">;</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">hJ</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">is_ideal_adic</span> <span class="n">J</span><span class="o">))</span>
</pre></div>

#### [ Johan Commelin (Oct 04 2018 at 15:22)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135181044):
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_ideal_adic</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="o">[</span><span class="n">is_ideal</span> <span class="n">J</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">n</span><span class="o">,</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">pow_ideal</span> <span class="n">J</span> <span class="n">n</span><span class="o">))</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="err">∈</span> <span class="n">S</span> <span class="bp">→</span> <span class="n">is_open</span> <span class="n">S</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">pow_ideal</span> <span class="n">J</span> <span class="n">n</span> <span class="err">⊆</span> <span class="n">S</span><span class="o">)</span>

<span class="n">def</span> <span class="n">is_adic</span> <span class="o">(</span><span class="n">A₀</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A</span><span class="o">)</span> <span class="o">[</span><span class="n">is_subring</span> <span class="n">A₀</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="o">(</span><span class="n">J</span> <span class="o">:</span> <span class="n">set</span> <span class="n">A₀</span><span class="o">)</span> <span class="o">[</span><span class="n">hJ</span> <span class="o">:</span> <span class="n">is_ideal</span> <span class="n">J</span><span class="o">],</span>
<span class="o">(</span><span class="k">by</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">topological_subring</span> <span class="n">A₀</span><span class="bp">;</span> <span class="n">haveI</span> <span class="o">:=</span> <span class="n">hJ</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">is_ideal_adic</span> <span class="n">J</span><span class="o">)</span>
</pre></div>

#### [ Johan Commelin (Oct 04 2018 at 15:25)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135181605):
<p>But, I'm not looking for help with the maths. I'm just wondering how the assumptions could be formulated in a nicer way.</p>

#### [ Johan Commelin (Oct 04 2018 at 15:25)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135181690):
<p>Should we put a <code>has_mul</code> on <code>set A</code> if <code>A</code> has <code>has_mul</code>?</p>

#### [ Johan Commelin (Oct 04 2018 at 15:26)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135181830):
<p>if <code>set A</code> is a monoid, then I could just write <code>U^n</code> and <code>T * U</code>.</p>

#### [ Johannes Hölzl (Oct 04 2018 at 15:27)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135182127):
<p>First thing: I wouldn't use the existential quantifier in the assumption, have all the things in there directly as assumption</p>

#### [ Johannes Hölzl (Oct 04 2018 at 15:28)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135182221):
<p><code>{y : A | ∃ (t ∈ U) (u ∈ U), y = t * u} = (*) &lt;$&gt; U &lt;*&gt; T</code></p>

#### [ Johan Commelin (Oct 04 2018 at 15:28)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135182274):
<p>Hmm, in fact it is an iff, but I only stated one implication.</p>

#### [ Johannes Hölzl (Oct 04 2018 at 15:28)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135182389):
<p><code>(*) &lt;$&gt; T &lt;*&gt; U = (*) &lt;$&gt; U &lt;*&gt; U ∧ (*) &lt;$&gt; U &lt;*&gt; U ⊆ U</code></p>

#### [ Johan Commelin (Oct 04 2018 at 15:29)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135182531):
<p>Not sure if that improves readability.... what do you think of my <code>monoid (set A)</code> suggestion?</p>

#### [ Johannes Hölzl (Oct 04 2018 at 15:29)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135182577):
<p>The <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> are from the applicative functor structor on <code>set</code>. Their function is to lift arbitrary functions to sets.</p>

#### [ Johan Commelin (Oct 04 2018 at 15:30)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135182755):
<p>I don't think a random mathematician will care about that. When they read Kevin's perfectoid paper, they will want to see code that they roughly understand</p>

#### [ Johannes Hölzl (Oct 04 2018 at 15:31)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135182974):
<p>you can certainly add the <code>monoid (set A)</code> locally. I'm not sure if we want to have this setup generally</p>

#### [ Mario Carneiro (Oct 04 2018 at 16:40)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135193215):
<p>Ooh, this is nice. I know the mathematicians here are going to freak, but I really like that the CS version of abstract nonsense has given us a way to easily talk about lifting functions to sets like <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>+</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">S + T</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">T</span></span></span></span></p>

#### [ Johan Commelin (Oct 04 2018 at 16:50)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135193942):
<p>What does "Ooh, this is nice" mean? As in: just use it, even if it is completely unreadable?</p>

#### [ Mario Carneiro (Oct 04 2018 at 16:55)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135194347):
<p>Basically yes. Treat it like an idiom or set phrase to say this</p>

#### [ Mario Carneiro (Oct 04 2018 at 16:57)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135194459):
<p>When Simon first showed me the <code>f &lt;$&gt; x &lt;*&gt; y</code> idiom for applying functions to monadic values I was mystified, but now I quite like it since it looks so much like regular function application</p>

#### [ Mario Carneiro (Oct 04 2018 at 16:58)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135194503):
<p>(It is equivalent to the monadic block <code>do a &lt;- x, b &lt;- y, return (f a b)</code>)</p>

#### [ Mario Carneiro (Oct 04 2018 at 16:59)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135194647):
<p>Until I saw this thread I thought that we would basically have to define a function <code>lift2 f A B</code> for doing this, and it would be even less nice to read</p>

#### [ Johan Commelin (Oct 04 2018 at 17:01)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135194792):
<p>What is wrong with the <code>monoid</code> instance?</p>

#### [ Mario Carneiro (Oct 04 2018 at 17:01)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135194816):
<p>That said, there are also other semi-slick ways of talking about this, like <code>uncurry (+) '' (A × B)</code></p>

#### [ Mario Carneiro (Oct 04 2018 at 17:02)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135194901):
<p>Well, it doesn't generalize as much as this</p>

#### [ Mario Carneiro (Oct 04 2018 at 17:03)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135194967):
<p>It may also cause a problem when we have a conflicting meaning for multiplication of sets</p>

#### [ Mario Carneiro (Oct 04 2018 at 17:04)](https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/fundamental%20system%20of%20neighborhoods/near/135195018):
<p>I think <code>has_sub</code> has a conflict</p>


{% endraw %}
