---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/52075noobquestions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html">noob question(s)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="148007940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148007940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148007940">Wojciech Nawrocki (Nov 20 2018 at 00:46)</a>:</h4>
<p>What's the command to make Lean automatically derive <code>decidable_eq</code> for some custom inductive type?</p>

<a name="148007958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148007958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148007958">Chris Hughes (Nov 20 2018 at 00:47)</a>:</h4>
<p>@[derive decidable_eq]</p>

<a name="148007972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148007972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148007972">Wojciech Nawrocki (Nov 20 2018 at 00:47)</a>:</h4>
<p>ah I should've thought of that, thanks! :)</p>

<a name="148013728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148013728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148013728">Wojciech Nawrocki (Nov 20 2018 at 03:18)</a>:</h4>
<p>Hm, when I add</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">classical</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">prop_decidable</span>
</pre></div>


<p>to a file, definitions below it which used to pass now fail with:</p>
<div class="codehilite"><pre><span></span><span class="n">equation</span> <span class="n">compiler</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">generate</span> <span class="n">bytecode</span> <span class="n">for</span> <span class="err">&#39;</span><span class="n">subst</span><span class="bp">._</span><span class="n">main&#39;</span>
<span class="n">nested</span> <span class="n">exception</span> <span class="n">message</span><span class="o">:</span>
<span class="n">code</span> <span class="n">generation</span> <span class="n">failed</span><span class="o">,</span> <span class="n">VM</span> <span class="n">does</span> <span class="n">not</span> <span class="k">have</span> <span class="n">code</span> <span class="n">for</span> <span class="err">&#39;</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice&#39;</span>
</pre></div>


<p>Why might this be?</p>
<p>Is it basically because <code>classical</code> makes things uncomputable? If so, maybe Lean should detect that <code>classical</code> is not used in a particular case and still compile the definition?</p>

<a name="148013848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148013848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148013848">Chris Hughes (Nov 20 2018 at 03:21)</a>:</h4>
<p>Try <code>[instance, priority 0]</code>. Otherwise it uses classical decidability even when there's proper decidability.</p>

<a name="148013915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148013915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148013915">Wojciech Nawrocki (Nov 20 2018 at 03:23)</a>:</h4>
<p>Ah indeed, thanks Chris!</p>

<a name="148024166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148024166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148024166">Kevin Buzzard (Nov 20 2018 at 08:22)</a>:</h4>
<p>This trips lots of people up! I wonder where people are learning this trick? Not putting priority 0 can trip you up later in quite a confusing way</p>

<a name="148024213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148024213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148024213">Patrick Massot (Nov 20 2018 at 08:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110865">@Jeremy Avigad</span>  needs to fix the very bottom of <a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html</a></p>

<a name="148024215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148024215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148024215">Johan Commelin (Nov 20 2018 at 08:23)</a>:</h4>
<p>I think Lean shows an error message when it can't find an instance for <code>decidable</code>, and that error message does not include setting the priority. It would be very helpful if it did.</p>

<a name="148024219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148024219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148024219">Patrick Massot (Nov 20 2018 at 08:23)</a>:</h4>
<p>and <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html</a></p>

<a name="148044684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148044684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148044684">Jeremy Avigad (Nov 20 2018 at 15:03)</a>:</h4>
<p>I'm on it -- I'll do it tomorrow.</p>

<a name="148049459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049459">Patrick Massot (Nov 20 2018 at 16:08)</a>:</h4>
<p>Thanks!</p>

<a name="148049511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049511">Kenny Lau (Nov 20 2018 at 16:09)</a>:</h4>
<p>how about <em>not</em> using <code>classical.dec</code></p>

<a name="148049651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049651">Reid Barton (Nov 20 2018 at 16:10)</a>:</h4>
<p>Let's just agree to not not use it</p>

<a name="148049677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049677">Kenny Lau (Nov 20 2018 at 16:11)</a>:</h4>
<p>that doesn't mean we <em>use</em> it :P</p>

<a name="148049697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049697">Patrick Massot (Nov 20 2018 at 16:11)</a>:</h4>
<p>You may have missed Reid's point</p>

<a name="148049698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049698">Reid Barton (Nov 20 2018 at 16:11)</a>:</h4>
<p>It doesn't mean <em>you</em> use it</p>

<a name="148074938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148074938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148074938">Wojciech Nawrocki (Nov 20 2018 at 22:59)</a>:</h4>
<p>Is it possible to make Lean display the values of constant variables in the tactic state? E.g. if i have <code>lst: list nat</code> which is also empty, it would be nice to see that it's empty.</p>

<a name="148075021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075021">Kenny Lau (Nov 20 2018 at 23:01)</a>:</h4>
<p>either this doesn't make sense, or <code>subst lst</code></p>

<a name="148075182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075182">Wojciech Nawrocki (Nov 20 2018 at 23:04)</a>:</h4>
<p>Hm I should elaborate, maybe I'm misunderstanding how <code>induction</code> works. Say I have a hypothesis <code>h: InductiveFoo list.nil</code>, where <code>InductiveFoo: list nat -&gt; Prop</code>. So then running <code>induction h</code> creates cases for all the constructors of <code>InductiveFoo</code>, which take the list as an input, say <code>lst</code>. But the <code>lst</code> is empty, so it'd be nice to see that in the state.</p>

<a name="148075295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075295">Kenny Lau (Nov 20 2018 at 23:06)</a>:</h4>
<p>you can't because it's forgotten</p>

<a name="148075309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075309">Kenny Lau (Nov 20 2018 at 23:06)</a>:</h4>
<p>you might want to <code>generalize_hyp</code></p>

<a name="148075886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075886">Wojciech Nawrocki (Nov 20 2018 at 23:16)</a>:</h4>
<p>Thanks!</p>

<a name="148115433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115433">Wojciech Nawrocki (Nov 21 2018 at 15:03)</a>:</h4>
<p>Perhaps it would be useful to have a reference sheet for translating from Coq to Lean tactics?</p>

<a name="148115539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115539">Mario Carneiro (Nov 21 2018 at 15:05)</a>:</h4>
<p>I recall such a thing being made at one point. Maybe it's in mathlib docs?</p>

<a name="148115560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115560">Rob Lewis (Nov 21 2018 at 15:05)</a>:</h4>
<p><a href="https://github.com/jldodds/coq-lean-cheatsheet" target="_blank" title="https://github.com/jldodds/coq-lean-cheatsheet">https://github.com/jldodds/coq-lean-cheatsheet</a></p>

<a name="148115566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115566">Rob Lewis (Nov 21 2018 at 15:05)</a>:</h4>
<p>Note the date though, it'll need updating.</p>

<a name="148115644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115644">Wojciech Nawrocki (Nov 21 2018 at 15:06)</a>:</h4>
<p>Oh, nice!</p>

<a name="148119720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148119720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148119720">Wojciech Nawrocki (Nov 21 2018 at 16:06)</a>:</h4>
<p>Is there a general tactic for showing <code>false</code> by "this term could not have been constructed"? E.g.</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">Foo</span><span class="o">:</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">FooT</span><span class="o">:</span> <span class="n">Foo</span> <span class="n">true</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">FooF</span><span class="o">:</span> <span class="n">Foo</span> <span class="n">false</span> <span class="n">false</span>

<span class="c1">-- This term could not have been constructed</span>
<span class="kn">lemma</span> <span class="n">impossible</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">Foo</span> <span class="n">true</span> <span class="n">false</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span>
</pre></div>

<a name="148120085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120085" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120085">Mario Carneiro (Nov 21 2018 at 16:11)</a>:</h4>
<p><code>cases</code></p>

<a name="148120091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120091">Mario Carneiro (Nov 21 2018 at 16:11)</a>:</h4>
<p>also empty match</p>

<a name="148120098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120098">Mario Carneiro (Nov 21 2018 at 16:11)</a>:</h4>
<div class="codehilite"><pre><span></span>lemma impossible : Foo true false → false.
</pre></div>

<a name="148120175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120175">Rob Lewis (Nov 21 2018 at 16:12)</a>:</h4>
<p>You have to make <code>Foo : bool -&gt; bool -&gt; Prop</code> for that.</p>

<a name="148120216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120216">Wojciech Nawrocki (Nov 21 2018 at 16:13)</a>:</h4>
<p>Yeah, for <code>Prop -&gt; Prop -&gt; Prop</code> both of these fail, but that wasn't actually my problem, so thanks!</p>

<a name="148120406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120406">Patrick Massot (Nov 21 2018 at 16:16)</a>:</h4>
<p>It seems that variations on this topic comes up again and again. We should really find a way to document that</p>

<a name="148134832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148134832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148134832">Wojciech Nawrocki (Nov 21 2018 at 20:17)</a>:</h4>
<p>That would be nice :) I was also surprised to see that more often than not <code>contradiction</code> fails when <code>cases h</code> works. Description: <code>The contradiction tactic attempts to find in the current local context an hypothesis that is equivalent to an empty inductive type (e.g. false)</code>. I thought a hypothesis that cannot be constructed is exactly that, but maybe I'm misunderstanding it?</p>

<a name="148147233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148147233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148147233">Wojciech Nawrocki (Nov 22 2018 at 01:12)</a>:</h4>
<p>Is it possible to reserve some notation for an inductive type and then use it while defining the type, like in Coq? I tried this,  but the parser seems to fail:</p>
<div class="codehilite"><pre><span></span><span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span><span class="err">∋</span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span>

<span class="kn">inductive</span> <span class="n">Typeof</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Z</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span><span class="o">,</span> <span class="n">Typeof</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">A</span><span class="o">])</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">S_</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">Typeof</span> <span class="err">Γ</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Typeof</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">B</span><span class="o">])</span> <span class="n">A</span>

<span class="kn">inductive</span> <span class="n">Typeof</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Z</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">A</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span> <span class="c1">-- fails</span>
<span class="bp">|</span> <span class="n">S_</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">A</span> <span class="bp">→</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">B</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>

<span class="kn">infix</span> <span class="err">∋</span> <span class="o">:=</span> <span class="n">Typeof</span>
</pre></div>

<a name="148150619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148150619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148150619">Mario Carneiro (Nov 22 2018 at 03:00)</a>:</h4>
<p>Yes! You can just put a notation line between the inductive header and the first constructor</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">Typeof</span><span class="o">{</span><span class="n">Tp</span><span class="o">}:</span> <span class="n">list</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kn">infix</span> <span class="bp">`</span><span class="err">∋</span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">Typeof</span>
<span class="bp">|</span> <span class="n">Z</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">A</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">S_</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">A</span> <span class="bp">→</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">B</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>
</pre></div>

<a name="148238627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148238627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148238627">Jeremy Avigad (Nov 23 2018 at 16:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I added a discussion of the <code>priority 0</code> trick to Section 10.4 of TPIL (search on "priority 0"):<br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions</a><br>
I also added a back reference in Section 11:<br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle</a></p>
<p>Finally, I fixed an old issue raised by <span class="user-mention" data-user-id="122022">@Joseph Corneli</span> by changing all the examples in 6.4:<br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#attributes" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#attributes">https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#attributes</a><br>
<a href="https://github.com/leanprover/theorem_proving_in_lean/issues/62" target="_blank" title="https://github.com/leanprover/theorem_proving_in_lean/issues/62">https://github.com/leanprover/theorem_proving_in_lean/issues/62</a></p>
<p>Teaching my class next semester will give me a chance to review and expand TPIL. I am planning to add one more chapter on some of the fine points of dependent type theory, e.g. explaining how to work with equality and dependent types (the dark side of type theory), and explaining how Lean manages recursion on arbitrary well-founded relations. I'll also try to write a less ambitious but up-to-date version of Programming in Lean. But I am counting on the mathlib crew to continue documenting mathlib and all the new tactics, and to provide useful guidance on using the library and proving theorems.</p>

<a name="148238846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148238846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148238846">Kevin Buzzard (Nov 23 2018 at 16:33)</a>:</h4>
<p>I have not been using Lean seriously since term started; there are three weeks to go before it finishes. After that I fully intend to go back to the perfectoid project. But when I don't understand something, my instinct is to write docs about it, because if I work something out and don't write down what I learnt then I realise a month later that I've forgotten it all again!</p>

<a name="148247373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148247373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148247373">Patrick Massot (Nov 23 2018 at 20:02)</a>:</h4>
<p>Thank you very much Jeremy! Your documentation work is really crucial.</p>

<a name="148249579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148249579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148249579">Patrick Massot (Nov 23 2018 at 21:06)</a>:</h4>
<p>I'm now reading random pieces of TPIL, and I have a couple more suggestions about chapter 10:</p>
<ul>
<li>at several places, emacs is mentioned but not VScode. I guess this goes back to before the VScode extension was available, but it could be misleading</li>
<li>in 10.5. Managing Type Class Inference, I think it would be nice to add the standard tricks to see what's the name of an instance Lean is finding, and sometimes what's the actual definition, as in</li>
</ul>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="bp">ℕ</span><span class="o">)</span>
</pre></div>


<p>maybe find a better example for the second one since the answer is not super easy to read (every nice example coming to my mind are in mathlib...)</p>

<a name="148249664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148249664" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148249664">Patrick Massot (Nov 23 2018 at 21:09)</a>:</h4>
<p>Oh, it seems <code>apply_instance</code> is never mentioned in TPIL <span class="emoji emoji-2639" title="sad">:sad:</span></p>

<a name="148249726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148249726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148249726">Patrick Massot (Nov 23 2018 at 21:10)</a>:</h4>
<p>Another thing that would be very helpful, both because it can be puzzling and because it can be very helpful would be to discuss</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="bp">ℕ</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">has_add</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>  <span class="c1">-- ok</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>  <span class="c1">-- fails</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">n</span> <span class="bp">;</span> <span class="n">apply_instance</span>  <span class="c1">-- ok</span>
</pre></div>

<a name="148277429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148277429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148277429">Jeremy Avigad (Nov 24 2018 at 13:23)</a>:</h4>
<p>Thanks for the input. Yes, TPIL evolved over time, and the last major rewrite was early in the days of Lean 3, before there was a VSCode extension. I'll do a global search and try to make the text less emacs-centric.</p>
<p>I'll discuss <code>apply_instance</code> and <code>infer_instance</code>. I am thinking of using these examples:</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm"> example 1: using apply_instance -/</span>

<span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">nat</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
<span class="n">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>

<span class="c">/-</span><span class="cm"> example 2: using infer_instance -/</span>

<span class="n">def</span> <span class="n">baz</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">infer_instance</span>
<span class="n">def</span> <span class="n">bla</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span>

<span class="c">/-</span><span class="cm"> example 3: seeing them -/</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">foo</span>    <span class="c1">-- nat.has_add</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">foo</span>   <span class="c1">-- (unreadable)</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">bar</span>    <span class="c1">-- pi.inhabited ℕ</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">bar</span>   <span class="c1">-- {default := λ (a : ℕ), 0}</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">baz</span>    <span class="c1">-- infer_instance</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">baz</span>   <span class="c1">-- (same as for #reduce foo)</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">bla</span>    <span class="c1">-- infer_instance</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">bla</span>   <span class="c1">-- {default := λ (a : ℕ), 0}</span>

<span class="c">/-</span><span class="cm"> example 4: tricks to be more concise -/</span>

<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">nat</span><span class="bp">.</span><span class="n">inhabited</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="bp">ℕ</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"> examples 5: core Lean can&#39;t find an instance for inhabited set -/</span>

<span class="c1">-- fails</span>
<span class="c1">-- example {α : Type*} : inhabited (set α) := by apply_instance</span>

<span class="c">/-</span><span class="cm"> example 6: supplying one manually -/</span>

<span class="n">def</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="err">∅</span><span class="bp">⟩</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span>     <span class="c1">-- λ {α : Type u}, {default := ∅}</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="bp">ℕ</span>  <span class="c1">-- {default := λ (a : ℕ), false}</span>

<span class="c">/-</span><span class="cm"> example 7: unfolding a definition so Lean can find it -/</span>

<span class="n">def</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">unfold</span> <span class="n">set</span><span class="bp">;</span> <span class="n">apply_instance</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span>     <span class="c1">-- λ (α : Type u), eq.mpr _ (pi.inhabited α)</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="bp">ℕ</span>  <span class="c1">-- {default := λ (a : ℕ), true}</span>

<span class="c">/-</span><span class="cm"> example 8: using dunfold instead -/</span>

<span class="n">def</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">dunfold</span> <span class="n">set</span><span class="bp">;</span> <span class="n">apply_instance</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span>     <span class="c1">-- λ (α : Type u), id (pi.inhabited α)</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="bp">ℕ</span>  <span class="c1">-- {default := λ (a : ℕ), true}</span>
</pre></div>

<a name="151432316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432316">Patrick Massot (Dec 11 2018 at 09:17)</a>:</h4>
<blockquote>
<p>Yes! You can just put a notation line between the inductive header and the first constructor</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">Typeof</span><span class="o">{</span><span class="n">Tp</span><span class="o">}:</span> <span class="n">list</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kn">infix</span> <span class="bp">`</span><span class="err">∋</span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">Typeof</span>
<span class="bp">|</span> <span class="n">Z</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">A</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">S_</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">A</span> <span class="bp">→</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">B</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>
</pre></div>


</blockquote>
<p>Is there something similar for dependant <code>structure</code>? If one field of my structure is a binary operator, can I define an infix notation usable in the remaining fields declaration?</p>

<a name="151432380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432380">Kevin Buzzard (Dec 11 2018 at 09:18)</a>:</h4>
<p>I usually make the <code>structure</code> extend the notation typeclass in this situation.</p>

<a name="151432403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432403">Kevin Buzzard (Dec 11 2018 at 09:19)</a>:</h4>
<p>In fact I have been known to make new notation typeclasses called things like <code>group_notation</code> extending <code>has_mul</code>, <code>has_one</code> and <code>has_inv</code>, and then extending these too so I get a bunch of notation at once.</p>

<a name="151432470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432470">Patrick Massot (Dec 11 2018 at 09:21)</a>:</h4>
<p>Thanks Kevin. I know all this, but I'm still interested in an answer to my question.</p>

<a name="151432479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432479">Kevin Buzzard (Dec 11 2018 at 09:21)</a>:</h4>
<p>Yes I understand. For example if the notation is not in the standard notation list then it would be nicer to add it directly in the definition of the structure.</p>

<a name="151440921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151440921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151440921">Rob Lewis (Dec 11 2018 at 12:05)</a>:</h4>
<p>You can define notation in structures that's used in the remaining fields. But I think it's just local to the structure declaration.</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">patrick</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span> <span class="bp">`</span><span class="err">^^^</span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">f</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="err">^^^</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">patrick</span><span class="bp">.</span><span class="n">h</span>
</pre></div>

<a name="151445285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151445285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151445285">Patrick Massot (Dec 11 2018 at 13:29)</a>:</h4>
<p>Thanks!</p>

<a name="154258172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154258172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154258172">Jeremy Avigad (Jan 03 2019 at 18:49)</a>:</h4>
<p>I just crossed this item off my to do list. <code>apply_inference</code> and such are now discussed here: <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference</a>. And VS Code is now mentioned whenever Emacs is, with VS Code first.</p>

<a name="154258563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154258563" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154258563">Patrick Massot (Jan 03 2019 at 18:54)</a>:</h4>
<blockquote>
<p>If you add this to your file in Emacs mode and use C-c C-x to run an independent Lean process on your file, the output buffer will show a trace every time the type class resolution procedure is subsequently triggered.</p>
</blockquote>
<p>This paragraph (in the section your referred to) is still Emacs centric</p>

<a name="154260198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260198">Jeremy Avigad (Jan 03 2019 at 19:20)</a>:</h4>
<p>Yes, that is the only one, because I don't know how to start an independent Lean process from within VS Code. I guess I'll remind people that they can run Lean from the VS Code terminal.</p>

<a name="154260213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260213">Patrick Massot (Jan 03 2019 at 19:20)</a>:</h4>
<p>Why would you do that?</p>

<a name="154260222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260222">Patrick Massot (Jan 03 2019 at 19:20)</a>:</h4>
<p>The trace is printed in the info view</p>

<a name="154260439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260439">Jeremy Avigad (Jan 03 2019 at 19:23)</a>:</h4>
<p>Oh! I forgot. Good point. I'll fix that.</p>

<a name="154260510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260510">Patrick Massot (Jan 03 2019 at 19:24)</a>:</h4>
<p>Great!</p>

<a name="154261167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154261167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154261167">Jeremy Avigad (Jan 03 2019 at 19:34)</a>:</h4>
<p>Fixed. Thanks for catching it.<br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference</a></p>

<a name="155250652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155250652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155250652">Wojciech Nawrocki (Jan 16 2019 at 12:50)</a>:</h4>
<p>Hello! Is there anything special I need to do to make Lean recognise my <code>instance : has_zero Foo</code> as being equivalent to <code>0</code>? I got this state while trying to use <code>rw [this]</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kn">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="mi">0</span> <span class="bp">+</span> <span class="n">π₂</span>
<span class="n">state</span><span class="o">:</span>
<span class="mi">3</span> <span class="n">goals</span>
<span class="n">π₂</span> <span class="o">:</span> <span class="n">mult</span><span class="o">,</span>
<span class="n">this</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">π₂</span> <span class="bp">=</span> <span class="n">π₂</span>
<span class="err">⊢</span> <span class="n">mult</span><span class="bp">.</span><span class="n">Zero</span> <span class="bp">+</span> <span class="n">π₂</span> <span class="bp">=</span> <span class="n">π₂</span> <span class="bp">+</span> <span class="n">mult</span><span class="bp">.</span><span class="n">Zero</span>
</pre></div>


<p>even though I have</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">mult</span> <span class="o">:=</span>
  <span class="bp">⟨</span><span class="n">mult</span><span class="bp">.</span><span class="n">Zero</span><span class="bp">⟩</span>
</pre></div>


<p>above</p>

<a name="155250968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155250968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155250968">Kevin Buzzard (Jan 16 2019 at 12:55)</a>:</h4>
<p>rewrites don't recognise definitional equality, only syntactic equality.</p>

<a name="155250980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155250980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155250980">Kevin Buzzard (Jan 16 2019 at 12:55)</a>:</h4>
<p>So you could try "show 0 + pi2 = _" before the rewrite</p>

<a name="155251052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251052">Kevin Buzzard (Jan 16 2019 at 12:56)</a>:</h4>
<p>or "change mult.Zero + _ = _ at this". Maybe it will work after one of these changes. But not after both ;-)</p>

<a name="155251072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251072">Reid Barton (Jan 16 2019 at 12:56)</a>:</h4>
<p><code>convert this</code> should also work</p>

<a name="155251096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251096">Kevin Buzzard (Jan 16 2019 at 12:57)</a>:</h4>
<p>but <code>this</code> isn't the goal</p>

<a name="155251103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251103">Kevin Buzzard (Jan 16 2019 at 12:57)</a>:</h4>
<p>Oh!</p>

<a name="155251182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251182">Kevin Buzzard (Jan 16 2019 at 12:58)</a>:</h4>
<p>This <code>convert</code> trick works when the thing you're rewriting is precisely one side of the equality I guess.</p>

<a name="155251188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251188">Reid Barton (Jan 16 2019 at 12:58)</a>:</h4>
<p>or <code>erw this</code> would also work but it's not as nice</p>

<a name="155251370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251370">Reid Barton (Jan 16 2019 at 13:01)</a>:</h4>
<p>In fact you can use <code>a' = b'</code> to prove <code>a = b</code> with neither side matching definitionally (you'll get two new goals <code>a = a'</code> and <code>b = b'</code>), but then you run the risk that the new goals are not actually true <span class="emoji emoji-263a" title="smile">:smile:</span></p>

<a name="155252212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252212">Wojciech Nawrocki (Jan 16 2019 at 13:13)</a>:</h4>
<p>Ah, I see, thanks! And related, I'm proving that an object with three elements and custom add/mult tables is a semiring, how ugly is it to do all my proofs like this?</p>
<div class="codehilite"><pre><span></span>  <span class="kn">lemma</span> <span class="n">add_assoc</span> <span class="o">(</span><span class="n">π₁</span> <span class="n">π₂</span> <span class="n">π₃</span><span class="o">:</span> <span class="n">mult</span><span class="o">)</span>
    <span class="o">:</span> <span class="n">π₁</span> <span class="bp">+</span> <span class="n">π₂</span> <span class="bp">+</span> <span class="n">π₃</span> <span class="bp">=</span> <span class="n">π₁</span> <span class="bp">+</span> <span class="o">(</span><span class="n">π₂</span> <span class="bp">+</span> <span class="n">π₃</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">π₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">π₂</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">π₃</span><span class="bp">;</span> <span class="n">refl</span> <span class="o">}</span>
</pre></div>

<a name="155252434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252434">Mario Carneiro (Jan 16 2019 at 13:17)</a>:</h4>
<p>it will work, although there are simpler proofs where you ony case on one of them, I think</p>

<a name="155252646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252646">Wojciech Nawrocki (Jan 16 2019 at 13:20)</a>:</h4>
<p>Hm, I found that without expanding every case, I had to do a bit more work by using other lemmas and so on. The definition of <code>add</code> is:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">mult</span><span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Zero</span><span class="o">:</span> <span class="n">mult</span>
<span class="bp">|</span> <span class="n">One</span><span class="o">:</span> <span class="n">mult</span>
<span class="bp">|</span> <span class="n">Omega</span><span class="o">:</span> <span class="n">mult</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">mult</span> <span class="o">:=</span>
  <span class="bp">⟨</span><span class="n">mult</span><span class="bp">.</span><span class="n">Zero</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">mult</span> <span class="o">:=</span>
  <span class="bp">⟨</span><span class="n">mult</span><span class="bp">.</span><span class="n">One</span><span class="bp">⟩</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="n">ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">mult</span><span class="bp">.</span><span class="n">Omega</span>

<span class="n">def</span> <span class="n">add</span><span class="o">:</span> <span class="n">mult</span> <span class="bp">→</span> <span class="n">mult</span> <span class="bp">→</span> <span class="n">mult</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">π</span> <span class="o">:=</span> <span class="n">π</span>
<span class="bp">|</span> <span class="n">π</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">π</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">ω</span>
<span class="bp">|</span> <span class="n">ω</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">ω</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">ω</span> <span class="o">:=</span> <span class="n">ω</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">mult</span> <span class="o">:=</span>
  <span class="bp">⟨</span><span class="n">add</span><span class="bp">⟩</span>
</pre></div>

<a name="155252763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252763">Mario Carneiro (Jan 16 2019 at 13:22)</a>:</h4>
<p>right</p>

<a name="155252890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252890">Mario Carneiro (Jan 16 2019 at 13:24)</a>:</h4>
<p>you should have lemmas like <code>x + ω = ω</code> as simp lemmas which should simplify most of the cases</p>

<a name="155252915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252915">Mario Carneiro (Jan 16 2019 at 13:25)</a>:</h4>
<p>or you could just split into 27 cases if you want</p>

<a name="155253007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155253007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155253007">Wojciech Nawrocki (Jan 16 2019 at 13:26)</a>:</h4>
<p>Ah ok, i'll try it with simp as well, thanks!</p>

<a name="155254705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155254705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155254705">Johan Commelin (Jan 16 2019 at 13:55)</a>:</h4>
<p>Scott Morrison's case-bashing tactic would probably be useful here. But I don't know where that tactic lives at the moment...</p>

<a name="155255138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155255138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155255138">Mario Carneiro (Jan 16 2019 at 14:01)</a>:</h4>
<p>if you want to do a case bashing proof, another approach is to prove <code>fintype mult</code> and <code>decidable_eq mult</code> (you can <code>derive</code> this), and then you can just revert everything and use <code>dec_trivial</code></p>

<a name="155255210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155255210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155255210">Johan Commelin (Jan 16 2019 at 14:02)</a>:</h4>
<p>Should even be reasonably fast, I guess.</p>

<a name="155255232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155255232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155255232">Mario Carneiro (Jan 16 2019 at 14:02)</a>:</h4>
<p>as long as you don't have too many variables; it is still 27 cases</p>

<a name="155256347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155256347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155256347">Kevin Buzzard (Jan 16 2019 at 14:18)</a>:</h4>
<p>Kind of a stupid question, but when I'm using other computer algebra systems I would expect checking a million cases to be very quick. Mario's comments suggest that 27 is rather large for Lean. What is happening here?</p>

<a name="155257947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155257947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155257947">Mario Carneiro (Jan 16 2019 at 14:37)</a>:</h4>
<p>There is a large overhead of the expression that is generated, elaboration for it, and typechecking</p>

<a name="155258030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258030">Mario Carneiro (Jan 16 2019 at 14:38)</a>:</h4>
<p>I don't think 27 is that large in this context, I guess it's probably less than a second to check</p>

<a name="155258059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258059">Mario Carneiro (Jan 16 2019 at 14:38)</a>:</h4>
<p>I just think it's better to have more "human" proofs with fewer cases</p>

<a name="155258070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258070">Kevin Buzzard (Jan 16 2019 at 14:38)</a>:</h4>
<p>This is what I don't understand. We have to check that 27 things of the form add a (add b c) = add (add a b) c hold and in each case this is by refl.</p>

<a name="155258119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258119">Kevin Buzzard (Jan 16 2019 at 14:39)</a>:</h4>
<p>How long does it take Lean to prove (0 + 1) + 1 = 0 + (1 + 1) in this type?</p>

<a name="155258201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258201">Mario Carneiro (Jan 16 2019 at 14:40)</a>:</h4>
<p>there is also all the intermediate steps, the generation of motives, lots of abstraction and substitution going on, and large terms being built up behind the scenes before you even attack those 27 cases</p>

<a name="155258224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258224">Kevin Buzzard (Jan 16 2019 at 14:40)</a>:</h4>
<p>So the bottleneck is elsewhere?</p>

<a name="155258252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258252">Mario Carneiro (Jan 16 2019 at 14:41)</a>:</h4>
<p>I have heard it repeatedly asserted that the kernel is not a bottleneck</p>

<a name="155258265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258265">Kevin Buzzard (Jan 16 2019 at 14:41)</a>:</h4>
<p>Again the idea of a "large" term is confusing to me. In python I could happily manipulate a list with 1000 elements.</p>

<a name="155258275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258275">Mario Carneiro (Jan 16 2019 at 14:41)</a>:</h4>
<p>this term has way more than 1000 subterms</p>

<a name="155258304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258304">Kevin Buzzard (Jan 16 2019 at 14:41)</a>:</h4>
<p>One of my kids has been learning about algorithms over the last few months and I realise now that I am far more aware of these things than I used to be.</p>

<a name="155258379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258379">Mario Carneiro (Jan 16 2019 at 14:42)</a>:</h4>
<p>all in all it makes lean just look a lot slower to do "simple" things</p>

<a name="155258393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258393">Mario Carneiro (Jan 16 2019 at 14:42)</a>:</h4>
<p>because there is a lot of bookkeeping in the background</p>

<a name="155258552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258552">Mario Carneiro (Jan 16 2019 at 14:44)</a>:</h4>
<p>I would like to figure out ways to minimize the overhead, but that runs close to work on the lean compiler</p>

<a name="155261902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155261902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155261902">Kevin Buzzard (Jan 16 2019 at 15:28)</a>:</h4>
<blockquote>
<p>this term has way more than 1000 subterms</p>
</blockquote>
<p>In the same way that a set with 10 elements has more than 1000 subsets, or in a more serious "we really need to work with way more than 1000 things" way?</p>

<a name="155263745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155263745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155263745">Mario Carneiro (Jan 16 2019 at 15:50)</a>:</h4>
<p>in the more serious way. (It's tricky to count the "size" of an expression but number of subterms is a good proxy)</p>

<a name="155263817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155263817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155263817">Mario Carneiro (Jan 16 2019 at 15:51)</a>:</h4>
<p>there is no exponential growth because subterms can't overlap, they are either disjoint or in a containment relationship</p>

<a name="156331129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156331129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156331129">Wojciech Nawrocki (Jan 18 2019 at 00:04)</a>:</h4>
<p>Is it possible to define a custom synthesis strategy for an implicit argument? I would like to define a function which extracts concrete values from concrete lists, like so:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">get&#39;</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">h</span><span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">l</span><span class="bp">.</span><span class="n">length</span><span class="o">},</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="bp">::</span><span class="n">xs</span><span class="o">)</span> <span class="mi">0</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="bp">::</span><span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">get&#39;</span> <span class="n">xs</span> <span class="n">n</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">lt_of_succ_lt_succ</span> <span class="n">h</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">n</span> <span class="n">h</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">not_lt_zero</span> <span class="n">n</span><span class="o">)</span>
</pre></div>


<p>and for concrete args, <code>h</code> is always derivable with a custom tactic. I'd like Lean to use that tactic to synthesise it.<br>
OR am I doing this completely wrong and there is a much simpler way?</p>

<a name="156331279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156331279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156331279">Chris Hughes (Jan 18 2019 at 00:07)</a>:</h4>
<p>unification hints! I don't know much about them though.</p>

<a name="156334847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156334847" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156334847">Mario Carneiro (Jan 18 2019 at 00:51)</a>:</h4>
<p>This function is <code>list.nth_le</code> btw</p>

<a name="156334971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156334971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156334971">Mario Carneiro (Jan 18 2019 at 00:53)</a>:</h4>
<p>you can synthesize the argument using typeclasses, but <code>exact_dec_trivial</code> is another easy way to do it</p>

<a name="156335048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156335048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156335048">Mario Carneiro (Jan 18 2019 at 00:54)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">get&#39;</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">l</span><span class="bp">.</span><span class="n">length</span> <span class="bp">.</span> <span class="n">exact_dec_trivial</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">l</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">n</span> <span class="n">h</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">get&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>

<a name="156335623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156335623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156335623">Wojciech Nawrocki (Jan 18 2019 at 01:07)</a>:</h4>
<p>Ah indeed, thanks Mario! Can I use something like this in a Pi-type (to make the equation compiler work)? The <code>foo . tactic</code> syntax doesn't seem to work:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">debrujin_of_nat</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span><span class="o">:</span> <span class="n">Env</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">length</span> <span class="bp">.</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">exact_dec_trivial</span><span class="o">),</span> <span class="o">(</span><span class="err">Γ</span> <span class="err">∋</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">n</span> <span class="n">h</span><span class="o">)</span> <span class="c1">-- ill-formed declaration</span>
</pre></div>

<a name="156335911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156335911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156335911">Mario Carneiro (Jan 18 2019 at 01:14)</a>:</h4>
<p>If you can put it left of the colon, the dot notation should work. But if you can't write it that way, it's sugar for <code>auto_param</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">get&#39;</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">auto_param</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;</span> <span class="n">l</span><span class="bp">.</span><span class="n">length</span><span class="o">)</span> <span class="bp">``</span><span class="n">exact_dec_trivial</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth_le</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">get&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>

<a name="156336087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336087">Wojciech Nawrocki (Jan 18 2019 at 01:19)</a>:</h4>
<p>Can I have a _named_ <code>auto_param</code> <span class="emoji emoji-1f605" title="sweat smile">:sweat_smile:</span>? I need to use the hypothesis in the type signature itself, more specifically in the return type.</p>

<a name="156336185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336185">Mario Carneiro (Jan 18 2019 at 01:21)</a>:</h4>
<p>sure, just use a pi instead of an arrow</p>

<a name="156336193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336193">Mario Carneiro (Jan 18 2019 at 01:21)</a>:</h4>
<p><code>auto_param T n</code> is defeq to <code>T</code> so it doesn't cause any problems</p>

<a name="156336460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336460" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336460">Wojciech Nawrocki (Jan 18 2019 at 01:27)</a>:</h4>
<p>Oh, I was sure I'd tried that but apparently not, thanks! Doesn't seem to work under <code>#eval</code> unfortunately:</p>
<div class="codehilite"><pre><span></span><span class="n">don&#39;t</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="kn">context</span><span class="o">:</span>
<span class="err">⊢</span> <span class="n">auto_param</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="o">[</span><span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span><span class="o">])</span> <span class="o">(</span><span class="n">name</span><span class="bp">.</span><span class="n">mk_string</span> <span class="s2">&quot;exact_dec_trivial&quot;</span> <span class="o">(</span><span class="n">name</span><span class="bp">.</span><span class="n">mk_string</span> <span class="s2">&quot;tactic&quot;</span> <span class="n">name</span><span class="bp">.</span><span class="n">anonymous</span><span class="o">))</span>
</pre></div>

<a name="156336541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336541">Mario Carneiro (Jan 18 2019 at 01:29)</a>:</h4>
<p>what did you write?</p>

<a name="156336637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336637">Mario Carneiro (Jan 18 2019 at 01:30)</a>:</h4>
<p>it's not really related to the context you write it in, but rather the expected type during elaboration</p>

<a name="156336845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336845">Wojciech Nawrocki (Jan 18 2019 at 01:35)</a>:</h4>
<p>Apologies for the length, but this is the full context:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">find</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">auto_cases</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">tidy</span>

<span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">decidable_eq</span><span class="o">]</span>
<span class="kn">inductive</span> <span class="n">Tp</span>
<span class="bp">|</span> <span class="n">Nat</span><span class="o">:</span> <span class="n">Tp</span>
<span class="bp">|</span> <span class="n">Bool</span><span class="o">:</span> <span class="n">Tp</span>
<span class="bp">|</span> <span class="n">Fn</span><span class="o">:</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span>

<span class="n">local</span> <span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⇒</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Fn</span>

<span class="n">def</span> <span class="n">Env</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">Tp</span>

<span class="kn">inductive</span> <span class="n">TypeIn</span><span class="o">:</span> <span class="n">Env</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∋</span> <span class="bp">`</span><span class="o">:</span><span class="mi">40</span> <span class="o">:=</span> <span class="n">TypeIn</span>
<span class="bp">|</span> <span class="n">ZVar</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span><span class="o">},</span> <span class="n">T</span><span class="bp">::</span><span class="err">Γ</span> <span class="err">∋</span> <span class="n">T</span>
<span class="bp">|</span> <span class="n">SVar</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span> <span class="n">U</span><span class="o">},</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">U</span><span class="bp">::</span><span class="err">Γ</span> <span class="err">∋</span> <span class="n">T</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∋</span> <span class="bp">`</span><span class="o">:</span><span class="mi">40</span> <span class="o">:=</span> <span class="n">TypeIn</span>

<span class="kn">open</span> <span class="n">TypeIn</span>

<span class="kn">inductive</span> <span class="n">Term</span><span class="o">:</span> <span class="n">Env</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Nat</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span><span class="o">},</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="c1">-- in all environments, nat literals have type Nat</span>
<span class="bp">|</span> <span class="n">Bool</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">bool</span><span class="o">):</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span><span class="o">},</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Bool</span> <span class="c1">-- and booleans have type Bool</span>
<span class="bp">|</span> <span class="n">Var</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span><span class="o">},</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">T</span> <span class="c1">-- A variable has type T given its de Brujin index</span>
                                 <span class="c1">-- is in the environment.</span>
<span class="bp">|</span> <span class="n">Abs</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span> <span class="n">U</span><span class="o">},</span> <span class="n">Term</span> <span class="o">(</span><span class="n">T</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">T</span> <span class="err">⇒</span> <span class="n">U</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">App</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span> <span class="n">U</span><span class="o">},</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">T</span> <span class="err">⇒</span> <span class="n">U</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">U</span>

<span class="kn">open</span> <span class="n">Term</span>

<span class="n">def</span> <span class="n">debrujin_of_nat</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span><span class="o">:</span> <span class="n">Env</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">h</span><span class="o">:</span> <span class="n">auto_param</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">length</span><span class="o">)</span> <span class="bp">``</span><span class="n">tactic</span><span class="bp">.</span><span class="n">exact_dec_trivial</span><span class="o">},</span> <span class="o">(</span><span class="err">Γ</span> <span class="err">∋</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">n</span> <span class="n">h</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">T</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="mi">0</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">ZVar</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">T</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">SVar</span> <span class="o">(</span><span class="bp">@</span><span class="n">debrujin_of_nat</span> <span class="err">Γ</span> <span class="n">n</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">lt_of_succ_lt_succ</span> <span class="n">h</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">n</span> <span class="n">h</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">not_lt_zero</span> <span class="n">n</span><span class="o">)</span> <span class="n">h</span> <span class="o">}</span>

<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`#`</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">Var</span> <span class="o">(</span><span class="n">debrujin_of_nat</span> <span class="n">n</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">App</span> <span class="o">[]</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">Abs</span> <span class="o">[]</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">Var</span> <span class="o">[</span><span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span><span class="o">]</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="o">(</span><span class="n">debrujin_of_nat</span> <span class="mi">0</span><span class="o">)))</span> <span class="o">(</span><span class="bp">@</span><span class="n">Nat</span> <span class="mi">3</span> <span class="o">[]))</span>
</pre></div>

<a name="156336955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336955">Wojciech Nawrocki (Jan 18 2019 at 01:37)</a>:</h4>
<p>Basically given a concrete <code>list Tp</code> and a concrete <code>n</code>, I'd like it to figure out that <code>n</code> is within bounds and include the result of <code>lst.nth_le n _</code> in the return type.</p>

<a name="156337127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156337127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156337127">Wojciech Nawrocki (Jan 18 2019 at 01:41)</a>:</h4>
<p>This does work: <code>#eval (@App [] Tp.Nat Tp.Nat (@Abs [] Tp.Nat Tp.Nat (@Var [Tp.Nat] Tp.Nat (@debrujin_of_nat [Tp.Nat] 0 (by tactic.exact_dec_trivial)))) (@Nat 3 []))</code> (notice the explicit proof I put in)</p>

<a name="156338055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338055" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338055">Mario Carneiro (Jan 18 2019 at 02:06)</a>:</h4>
<p>so what did you write?</p>

<a name="156338116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338116">Wojciech Nawrocki (Jan 18 2019 at 02:07)</a>:</h4>
<p>Well, the <code>#eval</code> at the bottom of that long snippet is what fails synthesis. The <code>#eval</code> with an explicit proof works</p>

<a name="156338117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338117">Mario Carneiro (Jan 18 2019 at 02:07)</a>:</h4>
<p>aha, you made the arg implicit</p>

<a name="156338118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338118">Mario Carneiro (Jan 18 2019 at 02:07)</a>:</h4>
<p>auto params should be explicit</p>

<a name="156338120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338120">Mario Carneiro (Jan 18 2019 at 02:07)</a>:</h4>
<div class="codehilite"><pre><span></span>def debrujin_of_nat: Π {Γ: Env} (n: ℕ) (h: auto_param (n &lt; Γ.length) ``tactic.exact_dec_trivial), (Γ ∋ Γ.nth_le n h)
</pre></div>

<a name="156338198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338198">Wojciech Nawrocki (Jan 18 2019 at 02:09)</a>:</h4>
<p>Oh thanks, now it does work, but still behaves as if it were implicit <span class="emoji emoji-1f914" title="thinking">:thinking:</span> is this currying at work, meaning I have to place <code>auto_param</code> last, s.t. given <code>foo: nat -&gt; auto_param blah -&gt; nat</code>, <code>(foo n): nat</code> (and <code>foo n _</code> still fails)?</p>

<a name="156408748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156408748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156408748">Wojciech Nawrocki (Jan 18 2019 at 23:39)</a>:</h4>
<p>(unrelated to above)<br>
I'm seeing a wierd error in an inductive type: <code>invalid occurrence of recursive arg#3 of 'context.cons', the body of the functional type depends on it.</code>. The type definition is below, and as far as I know it's a perfectly legit defn, so what's wrong?</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="kn">context</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">:</span> <span class="kn">context</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">ns</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="bp">_</span><span class="o">:</span> <span class="kn">context</span> <span class="n">ns</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="kn">context</span> <span class="o">(</span><span class="n">n</span><span class="bp">::</span><span class="n">ns</span><span class="o">)</span>
</pre></div>


<p>EDIT: swapping two arguments makes it compile, but why?</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="kn">context</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">:</span> <span class="kn">context</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">cons</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">ns</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="o">:</span> <span class="kn">context</span> <span class="n">ns</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="kn">context</span> <span class="o">(</span><span class="n">n</span><span class="bp">::</span><span class="n">ns</span><span class="o">)</span>
</pre></div>

<a name="156409198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156409198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156409198">Mario Carneiro (Jan 18 2019 at 23:48)</a>:</h4>
<p>I think Gabriel recently pointed out an example similar to this. You have a dependent pi (<code>n</code>) after a recursive arg (<code>_ : context ns</code>) and lean doesn't like this</p>

<a name="156411833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156411833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156411833">Wojciech Nawrocki (Jan 19 2019 at 00:37)</a>:</h4>
<p>Ah ok, maybe this could be fixed in Lean 4? :)</p>

<a name="156414862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156414862" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156414862">Wojciech Nawrocki (Jan 19 2019 at 01:51)</a>:</h4>
<p>Do I need to do something special to make the semiring-ness of my custom type available to the <code>ring</code> tactic? I have a state like this:</p>
<div class="codehilite"><pre><span></span><span class="n">π</span> <span class="n">π&#39;</span> <span class="o">:</span> <span class="n">mult</span><span class="o">,</span>
<span class="n">π_1</span> <span class="o">:</span> <span class="n">mult</span><span class="o">,</span>
<span class="err">⊢</span> <span class="n">π</span> <span class="bp">*</span> <span class="n">π&#39;</span> <span class="bp">*</span> <span class="n">π_1</span> <span class="bp">=</span> <span class="n">π</span> <span class="bp">*</span> <span class="o">(</span><span class="n">π&#39;</span> <span class="bp">*</span> <span class="n">π_1</span><span class="o">)</span>
</pre></div>


<p>which is provable by <code>exact mult.monoid.mul_assoc π π' π_1</code>, but <code>ring</code> fails. I have <code>instance : semiring mult</code> shown a few lines above.</p>

<a name="156415302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156415302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156415302">Mario Carneiro (Jan 19 2019 at 02:01)</a>:</h4>
<p>you need to prove <code>comm_semiring mult</code></p>

<a name="156554174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554174">Wojciech Nawrocki (Jan 21 2019 at 18:36)</a>:</h4>
<p>Given <code>def add (a b: foo): foo := blah</code>, what's the difference between <code>infix </code> ++ <code> := add</code> and <code>instance : has_add foo := ⟨add⟩</code>? If i switch from the former to the latter and replace <code>++</code> with <code>+</code>, my proofs break at the simplification stage, namely addition seems to not be <code>unfold</code>able anymore</p>

<a name="156554210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554210">Kevin Buzzard (Jan 21 2019 at 18:37)</a>:</h4>
<p>They're very different in the sense that they're using different machinery to figure out what's going on.</p>

<a name="156554280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554280">Kevin Buzzard (Jan 21 2019 at 18:38)</a>:</h4>
<p>I guess the <code>infix</code> trick is just syntax sugar, whereas the <code>instance</code> approach is using type class inference. Can you give an example of something which breaks?</p>

<a name="156554315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554315">Kevin Buzzard (Jan 21 2019 at 18:39)</a>:</h4>
<p>I guess if you go via the instance approach then you have an extra layer of unfolding to do. <code>+</code> is <code>has_add.add</code>, which unfolds to your add.</p>

<a name="156554337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554337">Kevin Buzzard (Jan 21 2019 at 18:39)</a>:</h4>
<p>Maybe that's the answer to your question. If you're trying to unfold things explicitly in the middle of a proof, maybe you have to insert some <code>unfold has_add.add</code>'s</p>

<a name="156554416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554416">Kevin Buzzard (Jan 21 2019 at 18:40)</a>:</h4>
<p><code>++</code> unfolds directly to your <code>add</code>, whereas <code>+</code> unfolds to <code>has_add.add</code> which unfolds to your add.</p>

<a name="156554455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554455" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554455">Kevin Buzzard (Jan 21 2019 at 18:42)</a>:</h4>
<p>[NB I'm a bit of a CS noob, I don't know if "unfolds" is the right terminology for notation turning into its underlying definition]</p>

<a name="156554512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554512">Kevin Buzzard (Jan 21 2019 at 18:42)</a>:</h4>
<p>[they might well be syntactically equal rather than just definitionally equal]</p>

<a name="156556743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156556743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156556743">Wojciech Nawrocki (Jan 21 2019 at 19:29)</a>:</h4>
<p>Ah indeed, <code>unfold</code>ing twice does make it work - thanks!</p>

<a name="156571293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156571293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156571293">Wojciech Nawrocki (Jan 22 2019 at 01:12)</a>:</h4>
<p>Does there exist a general tactic for proving <code>f a0 .. an = f b0 .. bn</code> from <code>a0 = b0 .. an = bn</code>?</p>

<a name="156571984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156571984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156571984">Mario Carneiro (Jan 22 2019 at 01:33)</a>:</h4>
<p><code>congr</code></p>

<a name="156572109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156572109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156572109">Wojciech Nawrocki (Jan 22 2019 at 01:36)</a>:</h4>
<p>Hm, I tried <code>congr</code> but it seems to iterate the congruence, which gives me unprovable goals. Namely, I have a goal <code>f (g x) = f (g y)</code> and <code>congr</code> gives me <code>x = y</code> but I just want <code>g x = g y</code>. EDIT: <code>congr' 1</code> works, thx!</p>

<a name="156574364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156574364" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156574364">Mario Carneiro (Jan 22 2019 at 02:37)</a>:</h4>
<p>use <code>congr' 1</code> and increase the number until you get a good result</p>

<a name="156647038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647038">Wojciech Nawrocki (Jan 22 2019 at 22:43)</a>:</h4>
<p>The issue of <code>has_add.add</code> and its actual value not being definitionally equal makes a lot of my proofs quite ugly - I have to expand definitions first so that the expressions can simplify and then fold them back into the <code>has_add.add</code> version (or <code>has_mul.mul</code>, etc), because all the ring/module/whatever laws only work on those. For example:</p>
<div class="codehilite"><pre><span></span>  <span class="o">{</span> <span class="c">/-</span><span class="cm"></span>
<span class="cm">    case context.cons</span>
<span class="cm">    δ γ γ₁ : precontext,</span>
<span class="cm">    π₁ : mult,</span>
<span class="cm">    T₁ : tp,</span>
<span class="cm">    Γ₁ : context γ₁,</span>
<span class="cm">    ih₁ : ∀ {Γ₂ : context γ₁} {Ξ : matrix γ₁ δ}, vmul (Γ₁ + Γ₂) Ξ = vmul Γ₁ Ξ + vmul Γ₂ Ξ,</span>
<span class="cm">    Γ₂ : context (T₁ :: γ₁),</span>
<span class="cm">    Ξ : matrix (T₁ :: γ₁) δ</span>
<span class="cm">    ⊢ vmul (cons π₁ T₁ Γ₁ + Γ₂) Ξ = vmul (cons π₁ T₁ Γ₁) Ξ + vmul Γ₂ Ξ</span>
<span class="cm">    -/</span>
    <span class="n">cases</span> <span class="err">Γ₂</span> <span class="k">with</span> <span class="bp">_</span> <span class="n">π₂</span> <span class="bp">_</span> <span class="err">Γ₂</span><span class="o">,</span>
    <span class="c1">-- unfold</span>
    <span class="n">unfold</span> <span class="n">vmul</span> <span class="n">has_add</span><span class="bp">.</span><span class="n">add</span> <span class="kn">context</span><span class="bp">.</span><span class="n">add</span> <span class="n">has_scalar</span><span class="bp">.</span><span class="n">smul</span> <span class="kn">context</span><span class="bp">.</span><span class="n">smul</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="n">simp</span> <span class="bp">*</span><span class="o">,</span>
    <span class="c1">-- fold back</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">vmul</span> <span class="err">Γ₁</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">tp</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">γ₁</span> <span class="err">∋</span> <span class="n">U</span><span class="o">),</span> <span class="err">Ξ</span> <span class="n">U</span> <span class="o">(</span><span class="n">SVar</span> <span class="n">x</span><span class="o">)),</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">vmul</span> <span class="err">Γ₂</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">tp</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">γ₁</span> <span class="err">∋</span> <span class="n">U</span><span class="o">),</span> <span class="err">Ξ</span> <span class="n">U</span> <span class="o">(</span><span class="n">SVar</span> <span class="n">x</span><span class="o">)),</span>
    <span class="n">change</span>
      <span class="o">(</span><span class="n">π₁</span> <span class="bp">+</span> <span class="n">π₂</span><span class="o">)</span> <span class="err">•</span> <span class="o">(</span><span class="err">Ξ</span> <span class="n">T₁</span> <span class="n">ZVar</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>
      <span class="bp">=</span>
      <span class="o">(</span><span class="n">π₁</span><span class="err">•</span><span class="o">(</span><span class="err">Ξ</span> <span class="n">T₁</span> <span class="n">ZVar</span><span class="o">)</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">π₂</span><span class="err">•</span><span class="o">(</span><span class="err">Ξ</span> <span class="n">T₁</span> <span class="n">ZVar</span><span class="o">)</span> <span class="bp">+</span> <span class="n">b</span><span class="o">),</span>
    <span class="c1">-- simplify using monoid laws</span>
    <span class="n">simp</span> <span class="o">[</span><span class="kn">context</span><span class="bp">.</span><span class="n">add_smul</span><span class="o">,</span> <span class="kn">context</span><span class="bp">.</span><span class="n">add_assoc</span><span class="o">]</span> <span class="o">},</span>
</pre></div>


<p>is there some tactic or such that I could apply to do this automatically?</p>

<a name="156647545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647545">Mario Carneiro (Jan 22 2019 at 22:51)</a>:</h4>
<p>This is what simp lemmas are for</p>

<a name="156647677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647677">Mario Carneiro (Jan 22 2019 at 22:53)</a>:</h4>
<p>If you define <code>add x (y :: z) := y :: add x z</code>, for example, and then install <code>add</code> as a <code>has_add</code> instance, then you can prove <code>x + (y :: z) = y :: (x + z)</code> by rfl, and you should state this as a simp lemma</p>

<a name="156647754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647754">Mario Carneiro (Jan 22 2019 at 22:54)</a>:</h4>
<p>You should not ever have to unfold <code>has_add.add</code></p>

<a name="156647865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647865">Wojciech Nawrocki (Jan 22 2019 at 22:56)</a>:</h4>
<p>Hm okay, so basically I need to "lift" the behaviour of my functions from the custom definition to one using <code>has_op.op</code>? I'll try</p>

<a name="156648686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156648686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156648686">Wojciech Nawrocki (Jan 22 2019 at 23:09)</a>:</h4>
<p>Is it fine to unfold <code>has_zero.zero</code> though? My definition of <code>0</code> for this type is</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">zeros</span><span class="o">:</span> <span class="bp">Π</span> <span class="n">γ</span><span class="o">,</span> <span class="kn">context</span> <span class="n">γ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">T</span><span class="bp">::</span><span class="n">δ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cons</span> <span class="mi">0</span> <span class="n">T</span> <span class="o">(</span><span class="n">zeros</span> <span class="n">δ</span><span class="o">)</span>
</pre></div>


<p>and I need the <code>cons</code> to prove <code>0+Γ=Γ</code></p>

<a name="156649254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156649254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156649254">Wojciech Nawrocki (Jan 22 2019 at 23:21)</a>:</h4>
<p>In any case this is pretty awesome, all my proofs have shortened by half now without the unfolding, thanks a lot!</p>

<a name="156653719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156653719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156653719">Mario Carneiro (Jan 23 2019 at 00:37)</a>:</h4>
<p>For this, you should decide whether you prefer to write the empty context as <code>0</code> or <code>[]</code>, and write a simp lemma like <code>0 = []</code> if you want to get rid of the 0 everywhere. In this case you should also make sure that all your other simp lemmas use the "preferred form" of this element on the LHS</p>

<a name="159247553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159247553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159247553">Wojciech Nawrocki (Feb 23 2019 at 22:04)</a>:</h4>
<p>What's the closest thing to the <code>ring</code> tactic when what I have is not a commutative semiring, e.g. just a monoid? Say my theorems are provable simply by repeated application of monoid or group laws, what tactic could I use?</p>

<a name="159247675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159247675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159247675">Kevin Buzzard (Feb 23 2019 at 22:08)</a>:</h4>
<p>If it's abelian then <code>abel</code> might work, and if it's not then you're best going with <code>simp</code> I think</p>

<a name="159247686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159247686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159247686">Kevin Buzzard (Feb 23 2019 at 22:09)</a>:</h4>
<p>You might have to write <code>simp [mul_assoc]</code> maybe, I can't remember if mul_assoc is a simp lemma</p>

<a name="159247850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159247850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159247850">Wojciech Nawrocki (Feb 23 2019 at 22:15)</a>:</h4>
<p><code>abel</code> worked :) thanks. And no, <code>mul_assoc</code> doesn't seem to be a simp lemma.</p>

<a name="159250591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159250591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159250591">Wojciech Nawrocki (Feb 23 2019 at 23:41)</a>:</h4>
<p>Say I would like to work with a particular module which uses a variable <code>v</code> instantiated over a concrete <code>v</code>. For example, a file <code>foo.lean</code> could first declare <code>variable {v: Type}</code> and then use <code>v</code> in all definitions/lemmas in the file. I would like to import everything in <code>foo</code> instantiated with e.g. <code>nat</code> for <code>v</code>. This would be equivalent to partially applying everything in the file to <code>nat</code>. Is such a thing possible without manually redefining everything?</p>

<a name="159250640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159250640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159250640">Andrew Ashworth (Feb 23 2019 at 23:42)</a>:</h4>
<p>You could write a tactic to do it</p>

<a name="159250642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159250642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159250642">Andrew Ashworth (Feb 23 2019 at 23:43)</a>:</h4>
<p>But, why?</p>

<a name="159250779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159250779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159250779">Wojciech Nawrocki (Feb 23 2019 at 23:47)</a>:</h4>
<p>I would like to do this in order to:<br>
a) Avoid type class search by giving it the right instance from the start.<br>
b) Make inference work. I found that making one of my modules more generic (I changed it from using a particular semiring to being generic over arbitrary semirings) broke inference in a lot of places where I use this module because it no longer knows which semiring to pick and I don't want to specify it everywhere manually.<br>
For a more concrete example which is close to what I'm doing, say I define a list <code>inductive slist {α: Type} [semiring α]: Type</code> which is a list the elements of which are also elements of a semiring and then derive a bunch of theorems about the behaviour of such a list under some transformations. I would then like to use all of these theorems only with a particular choice of <code>α</code>, even though the <code>slist</code> file/module is generic.</p>

<a name="159251390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159251390" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159251390">Kevin Buzzard (Feb 24 2019 at 00:06)</a>:</h4>
<p>But if you're using <code>{alpha  : Type}</code> correctly, then Lean should be able to infer what alpha is from subsequent terms, so you don't need to change it to nat, Lean will just guess it for you and do it itself. Have I missed the point?</p>

<a name="159251642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159251642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159251642">Andrew Ashworth (Feb 24 2019 at 00:15)</a>:</h4>
<p>"no longer knows which semiring to pick" this sounds fishy</p>

<a name="159251765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159251765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159251765">Kevin Buzzard (Feb 24 2019 at 00:18)</a>:</h4>
<p>The <code>{}</code> brackets aren't type class search, they are dealt with using unification.</p>

<a name="159251957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159251957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159251957">Wojciech Nawrocki (Feb 24 2019 at 00:23)</a>:</h4>
<p>You're right, Lean can still unify it and find the class instance - I was perhaps a bit rash there when figuring out what's going on. However, tactic state updates that used to take about 300ms when I was working over a concrete object now take several seconds, making it somewhat painful to work interactively. I was hoping that reinstantiating all the lemmas over the concrete objects again would alleviate this.</p>

<a name="159252010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252010">Kevin Buzzard (Feb 24 2019 at 00:24)</a>:</h4>
<p>Again, if you're talking about <code>{}</code>s then this isn't to do with classes, it's something else.</p>

<a name="159252015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252015">Kevin Buzzard (Feb 24 2019 at 00:24)</a>:</h4>
<p>But I agree that sometimes things get slow, and it can sometimes be quite difficult to find out why.</p>

<a name="159252030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252030">Wojciech Nawrocki (Feb 24 2019 at 00:25)</a>:</h4>
<p>I'm talking about both - the <code>{alpha}</code> variable being unified and <code>[semiring alpha]</code> which needs a class instance.</p>

<a name="159252032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252032" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252032">Kevin Buzzard (Feb 24 2019 at 00:25)</a>:</h4>
<p>Aah yes, that is a class instance. Sorry.</p>

<a name="159252038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252038">Kevin Buzzard (Feb 24 2019 at 00:25)</a>:</h4>
<p>Does it help to actually put the type class instances explicitly into Lean at the top of the file?</p>

<a name="159252086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252086">Kevin Buzzard (Feb 24 2019 at 00:26)</a>:</h4>
<p>e.g. you were working with a random alpha assumed to be a semiring, and now you're working with nat, so you could put <code>instance : semiring nat := by apply_instance</code> at the top of the file. However that instance should already be there so I can't imagine it will help :-/</p>

<a name="159252098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252098">Kevin Buzzard (Feb 24 2019 at 00:27)</a>:</h4>
<p>oh this can't be the problem. Unless your actual instances are hard to find.</p>

<a name="159252205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252205">Wojciech Nawrocki (Feb 24 2019 at 00:30)</a>:</h4>
<p>I couldn't say for sure without benchmarking, but I would guess that the two implicit arguments I added to <em>everything</em> makes it appreciably more difficult to carry out elaboration.</p>

<a name="159252209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252209">Kevin Buzzard (Feb 24 2019 at 00:30)</a>:</h4>
<p>I'm afraid you'll have to speak to a computer scientist about this one :-)</p>

<a name="159252211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252211">Kevin Buzzard (Feb 24 2019 at 00:31)</a>:</h4>
<p>In maths, everything runs instantly.</p>

<a name="159252220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252220" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252220">Kevin Buzzard (Feb 24 2019 at 00:31)</a>:</h4>
<p>You should consider moving to the Platonic universe.</p>

<a name="159252221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252221">Kevin Buzzard (Feb 24 2019 at 00:31)</a>:</h4>
<p>We don't have engineering troubles there.</p>

<a name="159252992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252992">Wojciech Nawrocki (Feb 24 2019 at 00:55)</a>:</h4>
<p>Oh okay, I ran into the problem that made me think unification fails again. In fact, I believe it could eventually succeed, but currently <code>simp *</code> takes so long it times out, while it would work fine before I added the implicit parameters to one of my modules.</p>

<a name="159253178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159253178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159253178">Kevin Buzzard (Feb 24 2019 at 01:00)</a>:</h4>
<p>If you want to try to speed things up yourself, you could take a look at what simp was doing before and after by putting logging on.</p>

<a name="159253197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159253197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159253197">Kevin Buzzard (Feb 24 2019 at 01:01)</a>:</h4>
<p><code>set_option trace.simplify.rewrite true</code> is what you need to see what simp is doing.</p>

<a name="159302724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159302724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159302724">Wojciech Nawrocki (Feb 24 2019 at 23:55)</a>:</h4>
<p>Does Lean have an equivalent of Haskell's/Agda's <code>where</code>? E.g. <code>def abc := two where two := 2</code></p>

<a name="159303137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159303137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159303137">Mario Carneiro (Feb 25 2019 at 00:06)</a>:</h4>
<p>no</p>

<a name="159303140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159303140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159303140">Mario Carneiro (Feb 25 2019 at 00:06)</a>:</h4>
<p>it messes with elaboration order</p>

<a name="159303855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159303855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159303855">Wojciech Nawrocki (Feb 25 2019 at 00:27)</a>:</h4>
<p>Could you <em>elaborate</em> on what the issue is?</p>

<a name="159304378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159304378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159304378">Mario Carneiro (Feb 25 2019 at 00:43)</a>:</h4>
<p>Lean does pretty much all elaboration from left to right. If you use a postfix <code>let</code>, then the type and value of the defined variable will not be known when it is needed</p>

<a name="159304384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159304384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159304384">Mario Carneiro (Feb 25 2019 at 00:43)</a>:</h4>
<p>Is this stupid? Yes. I think lean 4 will relax the elaboration order a bit to allow stuff like this to work</p>

<a name="159645662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159645662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159645662">Wojciech Nawrocki (Feb 28 2019 at 19:47)</a>:</h4>
<p>Does anyone know where the extra argument comes from (I do know <code>(n = 0)</code> is probably not valid syntax for a hypothesis)?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo_fn</span> <span class="o">:=</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span> <span class="n">string</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">foo_fn</span>
<span class="c">/-</span><span class="cm"> def foo_fn : Type :=</span>
<span class="cm">   ℕ → Π (n : ℕ), n = 0 → string -/</span>
<span class="c1">-- ^ what is this?</span>
</pre></div>

<a name="159645923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159645923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159645923">Chris Hughes (Feb 28 2019 at 19:51)</a>:</h4>
<p>Do you have a <code>variable</code> somewhere in your file?</p>

<a name="159646059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159646059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159646059">Chris Hughes (Feb 28 2019 at 19:52)</a>:</h4>
<p>Oh no actually. <code>Π (n = 0), _</code> is shorthand for <code>Π n, n = 0 -&gt; _</code></p>

<a name="159646200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159646200" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159646200">Wojciech Nawrocki (Feb 28 2019 at 19:54)</a>:</h4>
<p>Ah so it <em>is</em> valid syntax. Thanks!</p>

<a name="159657235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159657235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159657235">Wojciech Nawrocki (Feb 28 2019 at 22:08)</a>:</h4>
<p>I would like to define a subtype of Lean functions like so:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span>
<span class="n">def</span> <span class="n">foo_fn</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>

<span class="kn">inductive</span> <span class="n">is_foo</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Id</span><span class="o">:</span> <span class="n">is_foo</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">Rec</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">},</span> <span class="n">is_foo</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">is_foo</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">)</span>
<span class="o">(</span><span class="n">hf</span><span class="o">:</span> <span class="n">is_foo</span> <span class="n">f</span><span class="o">)</span>
</pre></div>


<p>Where a <code>foo</code> is a <code>ℕ → ℕ</code> together with a proof that it's a valid kind of <code>foo_fn</code>, i.e. either the identity or some other <code>foo</code> plus 1. Then, I would also like to carry out transformations on the <code>foo</code> structure by modifying the <code>foo_fn</code> and adjusting its proof. Unfortunately the <code>foo_fn</code> is opaque as just a Lean function, so to actually do this it seems I need the following:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">foo&#39;</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Id</span><span class="o">:</span> <span class="n">foo&#39;</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">Rec</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">},</span> <span class="n">foo&#39;</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">foo&#39;</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>


<p>My question is, can <code>foo'</code> be considered equivalent to <code>foo</code> in the sense that I can extract <code>f: foo_fn</code> out of <code>foo' f</code> and use it as I would use the <code>f</code> member of the structure <code>foo</code>?</p>

<a name="159663701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159663701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159663701">Kevin Buzzard (Feb 28 2019 at 23:42)</a>:</h4>
<p>I don't understand the question. Are you not happy with this sort of thing:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo_fn</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>

<span class="kn">inductive</span> <span class="n">is_foo</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Id</span><span class="o">:</span> <span class="n">is_foo</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">Rec</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">},</span> <span class="n">is_foo</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">is_foo</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">)</span>
<span class="o">(</span><span class="n">hf</span><span class="o">:</span> <span class="n">is_foo</span> <span class="n">f</span><span class="o">)</span>

<span class="n">def</span> <span class="n">add_one</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf</span><span class="bp">⟩</span>
</pre></div>


<p>?</p>

<a name="159798929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159798929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159798929">Wojciech Nawrocki (Mar 02 2019 at 14:09)</a>:</h4>
<p>The problem is that I couldn't redefine <code>add_one</code> like this:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">add_one&#39;</span><span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">foo</span>
<span class="c">/-</span><span class="cm"> induction tactic failed, recursor &#39;is_foo.dcases_on&#39; can only eliminate into Prop -/</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Id</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Id</span><span class="bp">⟩</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf&#39;</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf&#39;</span><span class="o">)</span><span class="bp">⟩</span>
</pre></div>


<p>And in general any definition which tries to extract an inner <code>foo_fn</code> out of an <code>is_foo</code> constructor will fail, but I need to do that sometimes in order to transform the <code>foo_fn</code>. So far the <code>inductive foo': foo_fn -&gt; Type</code> definition seems to work well though.</p>

<a name="159799119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159799119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159799119">Kevin Buzzard (Mar 02 2019 at 14:15)</a>:</h4>
<p>Aah I see; the recursor for <code>is_foo</code> only eliminates into <code>Prop</code>. Yeah you need an expert, not a mathematician :-)</p>

<a name="159799673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159799673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159799673">Chris Hughes (Mar 02 2019 at 14:26)</a>:</h4>
<p>The reason this isn't possible in general, is that by proof irrelevance <code>is_foo.Id = is_foo.rec _</code> if the proofs have the same type, so I cannot define functions that treat these two cases differently.</p>
<p>Since both cases are equal in your function, you can write</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">add_one&#39;</span><span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Id</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hf&#39;</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf&#39;</span><span class="o">))</span><span class="bp">⟩</span>
</pre></div>

<a name="159799742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159799742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159799742">Chris Hughes (Mar 02 2019 at 14:28)</a>:</h4>
<p>Usually this form is preferred however</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">add_one&#39;</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">:=</span>
 <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="mi">1</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">f</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Id</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hf&#39;</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf&#39;</span><span class="o">))</span><span class="bp">⟩</span>
</pre></div>

<a name="159799766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159799766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159799766">Chris Hughes (Mar 02 2019 at 14:30)</a>:</h4>
<p>The second <code>add_one'</code> will definitionally reduce in a nice way when applied to an argument <code>f : foo</code>, wherease the first definition will only reduce when applied to an argument of the form <code>⟨f, h⟩ : foo</code>. This makes the first definition harder to work with in proofs.</p>

<a name="159801343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159801343" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159801343">Wojciech Nawrocki (Mar 02 2019 at 15:12)</a>:</h4>
<p>Thanks!</p>

<a name="159866654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159866654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159866654">drocta (Mar 03 2019 at 21:57)</a>:</h4>
<p>I am trying to say something about free objects, using an existing definition of concrete categories in mathlib.<br>
I couldn't find an existing definition in mathlib for free objects, so I was going to define them myself.<br>
I have mathlib installed using leanpkg, and it looks like because I have lean version 3.4.1 installed, leanpkg used the branch with that name from the mathlib repository.<br>
However, I notice that the master branch and the 3.4.1 branch have the definition of concrete categories in different places.<br>
Should I go ahead and use the version which is defined in the 3.4.1 branch, and is in the category.lean file, or ought I somehow use the version in the concrete_category.lean version currently in the master branch?</p>

<a name="159868739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159868739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159868739">Kevin Buzzard (Mar 03 2019 at 22:56)</a>:</h4>
<p>The master branch of mathlib doesn't work with Lean 3.4.1.</p>

<a name="159868775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159868775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159868775">Kevin Buzzard (Mar 03 2019 at 22:58)</a>:</h4>
<p>If I were you I'd use 3.4.2 (probably the last release of Lean 3) and mathlib master. If you install elan then it will all work by magic and you won't have to worry.</p>

<a name="159870797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159870797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159870797">drocta (Mar 03 2019 at 23:56)</a>:</h4>
<p>thank you</p>

<a name="159876903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159876903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159876903">drocta (Mar 04 2019 at 02:48)</a>:</h4>
<p>I'm not sure where to find the documentation on out_param . Could you point me towards it?<br>
the definition in core.lean looks like it is just an identity function, but I assume I'm missing something, seeing as I think the lack of it just caused me to get a type error.</p>

<a name="159884489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159884489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159884489">drocta (Mar 04 2019 at 03:50)</a>:</h4>
<p>found a way to do what I was trying to do which didn't require that, so nvm I guess?</p>

<a name="159891658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159891658" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159891658">Kevin Buzzard (Mar 04 2019 at 07:03)</a>:</h4>
<p><code>out_param</code> is something to do with telling Lean's elaborator what order to do type inference, or something like that. I'm afraid the only documentation that I know of is when I asked for details about it on either this chat or at the old chat, and Mario Carneiro explained it.</p>

<a name="159893666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159893666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159893666">Kevin Buzzard (Mar 04 2019 at 07:52)</a>:</h4>
<p><a href="https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351" target="_blank" title="https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351">https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351</a></p>

<a name="159971264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159971264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159971264">drocta (Mar 05 2019 at 02:35)</a>:</h4>
<blockquote>
<p><code>out_param</code> is something to do with telling Lean's elaborator what order to do type inference, or something like that. I'm afraid the only documentation that I know of is when I asked for details about it on either this chat or at the old chat, and Mario Carneiro explained it.<br>
<a href="https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351" target="_blank" title="https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351">https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351</a></p>
</blockquote>
<p>Ah! Thank you!</p>

<a name="160008880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160008880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160008880">Wojciech Nawrocki (Mar 05 2019 at 14:51)</a>:</h4>
<p>What is the meaning of this error: <code>rewrite tactic failed, motive is not type correct</code>?<br>
I get it when trying to apply <code>rw [sesh_tp.dual_end_recv]</code> where <code>sesh_tp.dual_end_recv : sesh_tp.dual End? = End!</code> to the following state:</p>
<div class="codehilite"><pre><span></span><span class="err">⊢</span> <span class="err">⟦</span><span class="mi">1</span><span class="bp">⬝</span><span class="err">↑</span><span class="o">(</span><span class="n">sesh_tp</span><span class="bp">.</span><span class="n">dual</span> <span class="n">End</span><span class="err">?</span><span class="o">)</span><span class="err">⟧</span><span class="bp">::</span><span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span> <span class="n">matrix</span><span class="bp">.</span><span class="n">identity</span> <span class="o">(</span><span class="err">↑</span><span class="o">(</span><span class="n">sesh_tp</span><span class="bp">.</span><span class="n">dual</span> <span class="n">End</span><span class="err">?</span><span class="o">)</span> <span class="bp">::</span> <span class="n">γ</span><span class="o">)</span> <span class="err">↑</span><span class="n">End</span><span class="bp">!</span> <span class="o">(</span><span class="n">ZVar</span> <span class="n">γ</span> <span class="err">↑</span><span class="n">End</span><span class="bp">!</span><span class="o">)</span>
</pre></div>


<p>I thought that <code>rw</code> should be able to simply replace the instances of <code>sesh_tp.dual End?</code>.<br>
(<code>End?</code> and <code>End!</code> are constructors for the <code>sesh_tp</code> inductive type.)</p>

<a name="160012954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160012954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160012954">Patrick Massot (Mar 05 2019 at 15:39)</a>:</h4>
<p>We need an emoji for this error</p>

<a name="160013094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160013094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160013094">Patrick Massot (Mar 05 2019 at 15:41)</a>:</h4>
<p>It means that doing the rewrite will give you an expression which doesn't type check, presumably because you had a dependent type and rewrote the parameter. The classical example is:</p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="kn">notation</span> <span class="n">false</span>
<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">implicit</span> <span class="n">true</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">))</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">add_comm</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>

  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="160013133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160013133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160013133">Patrick Massot (Mar 05 2019 at 15:41)</a>:</h4>
<p>Try understanding this simple example and then your complicated one</p>


{% endraw %}
