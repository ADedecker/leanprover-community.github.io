---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html">formalizing Hilbert's axioms for plane geometry</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="185678084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678084">Marc Masdeu (Jan 15 2020 at 08:35)</a>:</h4>
<p>Hi there, I'm a mathematician getting started with Lean. After having done the natural number game and a few of the challenges, I wanted to start formalizing something easy, and I tried with Hilber'ts axioms.</p>
<p>So far, I have this little:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>
<span class="c1">-- We want to be able to define functions using the law of excluded middle</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">,</span> <span class="n">priority</span> <span class="mi">0</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>


<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">constants</span> <span class="n">Points</span> <span class="n">Lines</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span>
<span class="kn">constant</span> <span class="n">lies_on</span> <span class="o">:</span> <span class="n">Points</span> <span class="bp">→</span> <span class="n">Lines</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="n">local</span> <span class="kn">infixl</span> <span class="bp">`</span><span class="err">∈</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">lies_on</span>

<span class="kn">constant</span> <span class="n">I1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span>  <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">ℓ</span><span class="o">,</span> <span class="o">(</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span>
<span class="c1">--constant I11 : ∀ A B : Points,  A ≠ B → ∃ ℓ, ( A ∈ ℓ ) ∧ ( B ∈ ℓ )</span>
<span class="c1">--constant I12 : ∀ A B : Points, ∀ r s : Lines, (A ≠ B) →  (A ∈ r) →  (B ∈ r) →  (A ∈ s) → (B ∈ s) →  r = s</span>
<span class="kn">constant</span> <span class="n">I2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span>
<span class="kn">constant</span> <span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">)))</span>

<span class="kn">lemma</span> <span class="n">I11</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span>  <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">ℓ</span><span class="o">,</span> <span class="o">(</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">I1</span> <span class="n">A</span> <span class="n">B</span> <span class="n">h</span> <span class="k">with</span> <span class="n">ℓ</span> <span class="n">h1</span><span class="o">,</span>
<span class="n">existsi</span> <span class="n">ℓ</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">H</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">H</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">I12</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">B</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">B</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span>  <span class="n">r</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">r</span> <span class="n">s</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">hAr</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">hBr</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">hAs</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">hBs</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">I1</span> <span class="n">A</span> <span class="n">B</span> <span class="n">h</span> <span class="k">with</span> <span class="n">ℓ</span> <span class="n">h1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">r_is_ell</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">ℓ</span><span class="o">,</span>
<span class="bp">...</span>
<span class="kn">end</span>
</pre></div>


<p>The axiom I1 is an if and only if statement, and I wanted to separate the two statements as I11 and I12. I succeeded with I11 (existence) but for I12 (uniqueness) I am having trouble. I end up with the following tactic state:</p>
<div class="codehilite"><pre><span></span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span>
<span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">,</span>
<span class="n">hAr</span> <span class="o">:</span> <span class="n">A</span><span class="err">∈</span><span class="n">r</span><span class="o">,</span>
<span class="n">hBr</span> <span class="o">:</span> <span class="n">B</span><span class="err">∈</span><span class="n">r</span><span class="o">,</span>
<span class="n">hAs</span> <span class="o">:</span> <span class="n">A</span><span class="err">∈</span><span class="n">s</span><span class="o">,</span>
<span class="n">hBs</span> <span class="o">:</span> <span class="n">B</span><span class="err">∈</span><span class="n">s</span><span class="o">,</span>
<span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">),</span> <span class="n">A</span><span class="err">∈</span><span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span><span class="err">∈</span><span class="n">ℓ</span><span class="o">)</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">),</span> <span class="n">A</span><span class="err">∈</span><span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span><span class="err">∈</span><span class="n">ℓ</span><span class="o">)</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">ℓ</span>
<span class="err">⊢</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">s</span>
</pre></div>


<p>and then I want to conclude by showing that r = ell = s, so I do <code>have r_eq_ell : r = \ell</code>. This gives me the first goal of showing r = ell, and there I get stuck:</p>
<div class="codehilite"><pre><span></span><span class="mi">2</span> <span class="n">goals</span>
<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span>
<span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">,</span>
<span class="n">hAr</span> <span class="o">:</span> <span class="n">A</span><span class="err">∈</span><span class="n">r</span><span class="o">,</span>
<span class="n">hBr</span> <span class="o">:</span> <span class="n">B</span><span class="err">∈</span><span class="n">r</span><span class="o">,</span>
<span class="n">hAs</span> <span class="o">:</span> <span class="n">A</span><span class="err">∈</span><span class="n">s</span><span class="o">,</span>
<span class="n">hBs</span> <span class="o">:</span> <span class="n">B</span><span class="err">∈</span><span class="n">s</span><span class="o">,</span>
<span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">),</span> <span class="n">A</span><span class="err">∈</span><span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span><span class="err">∈</span><span class="n">ℓ</span><span class="o">)</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">),</span> <span class="n">A</span><span class="err">∈</span><span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span><span class="err">∈</span><span class="n">ℓ</span><span class="o">)</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">ℓ</span>
<span class="err">⊢</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">ℓ</span>

<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span>
<span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">,</span>
<span class="n">hAr</span> <span class="o">:</span> <span class="n">A</span><span class="err">∈</span><span class="n">r</span><span class="o">,</span>
<span class="n">hBr</span> <span class="o">:</span> <span class="n">B</span><span class="err">∈</span><span class="n">r</span><span class="o">,</span>
<span class="n">hAs</span> <span class="o">:</span> <span class="n">A</span><span class="err">∈</span><span class="n">s</span><span class="o">,</span>
<span class="n">hBs</span> <span class="o">:</span> <span class="n">B</span><span class="err">∈</span><span class="n">s</span><span class="o">,</span>
<span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">),</span> <span class="n">A</span><span class="err">∈</span><span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span><span class="err">∈</span><span class="n">ℓ</span><span class="o">)</span> <span class="n">ℓ</span> <span class="bp">∧</span>
    <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">),</span> <span class="n">A</span><span class="err">∈</span><span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span><span class="err">∈</span><span class="n">ℓ</span><span class="o">)</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">ℓ</span><span class="o">,</span>
<span class="n">r_eq_ell</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">ℓ</span>
<span class="err">⊢</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">s</span>
</pre></div>


<p>Thank you for any help!</p>
<p>PS: I know that I should be using classes or structures, but I am trying to keep it as simple as possible (and using as few non-math concepts as possible). Once I get something compiling I will try to understand how to make it up to standards.</p>

<a name="185678302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678302">Johan Commelin (Jan 15 2020 at 08:39)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> I think there are functions <code>unique_of_exists_unique</code> that take an <code>∃! foobar</code> statement, and spit out the corresponding uniqueness statement.</p>

<a name="185678307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678307">Johan Commelin (Jan 15 2020 at 08:39)</a>:</h4>
<p>But maybe you would rather prove it by yourself, as an exercise.</p>

<a name="185678386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678386">Marc Masdeu (Jan 15 2020 at 08:41)</a>:</h4>
<p>Good to know (I had seen it elsewhere) but I would like to prove the exact statement of I12 (yes, as an exercice), and more so now that I got stuck :-).</p>

<a name="185678416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678416">Johan Commelin (Jan 15 2020 at 08:41)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="k">have</span> <span class="n">r_is_ell</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">ℓ</span><span class="o">,</span>
<span class="o">{</span> <span class="n">apply</span> <span class="n">h1</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">assumption&#39;</span> <span class="o">},</span>
</pre></div>

<a name="185678472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678472">Johan Commelin (Jan 15 2020 at 08:42)</a>:</h4>
<p>Alternative:</p>
<div class="codehilite"><pre><span></span><span class="n">rcases</span> <span class="n">I1</span> <span class="n">A</span> <span class="n">B</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">ℓ</span><span class="o">,</span> <span class="n">h1_left</span><span class="o">,</span> <span class="n">h1_right</span><span class="bp">⟩</span><span class="o">,</span>
<span class="k">have</span> <span class="n">r_is_ell</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">ℓ</span><span class="o">,</span>
<span class="o">{</span> <span class="n">apply</span> <span class="n">h1_right</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">assumption&#39;</span> <span class="o">},</span>
</pre></div>

<a name="185678478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678478">Johan Commelin (Jan 15 2020 at 08:42)</a>:</h4>
<p>I changed <code>cases</code> to <code>rcases</code>. That allows you to do "recursive" cases. (And I didn't attempt to give meaningful names to the hypotheses)</p>

<a name="185678511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678511">Marc Masdeu (Jan 15 2020 at 08:43)</a>:</h4>
<p>aha! Is there a way to resolve the have with tactics? I am not so comfortable yet with switching from one way to the other..</p>

<a name="185678577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678577">Johan Commelin (Jan 15 2020 at 08:44)</a>:</h4>
<p>What do you mean?</p>

<a name="185678590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678590">Johan Commelin (Jan 15 2020 at 08:45)</a>:</h4>
<p>I proved the <code>have</code> using tactics. I used <code>{ ... }</code> to "zoom in" on one goal</p>

<a name="185678596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678596">Johan Commelin (Jan 15 2020 at 08:45)</a>:</h4>
<p>But you don't need to write those curly braces, if you don't want to</p>

<a name="185678606"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678606" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678606">Johan Commelin (Jan 15 2020 at 08:45)</a>:</h4>
<p>Or do you want to avoid the <code>have</code> altogether?</p>

<a name="185678614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678614">Marc Masdeu (Jan 15 2020 at 08:45)</a>:</h4>
<p>Oh I see. I am trying myself now. I thought that the {} was used to construct directly a term. I am in the right thread...</p>

<a name="185678706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678706">Johan Commelin (Jan 15 2020 at 08:47)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">rcases</span> <span class="n">I1</span> <span class="n">A</span> <span class="n">B</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">ℓ</span><span class="o">,</span> <span class="n">h1_left</span><span class="o">,</span> <span class="n">h1_right</span><span class="bp">⟩</span><span class="o">,</span>
<span class="n">transitivity</span><span class="o">,</span>
<span class="o">{</span> <span class="n">apply</span> <span class="n">h1_right</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">assumption&#39;</span> <span class="o">},</span>
<span class="o">{</span> <span class="n">symmetry</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h1_right</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">assumption&#39;</span> <span class="o">}</span>
</pre></div>

<a name="185678714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678714">Johan Commelin (Jan 15 2020 at 08:47)</a>:</h4>
<p>Proof without <code>have</code></p>

<a name="185678742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678742">Johan Commelin (Jan 15 2020 at 08:47)</a>:</h4>
<p>Shorter version:</p>
<div class="codehilite"><pre><span></span><span class="n">rcases</span> <span class="n">I1</span> <span class="n">A</span> <span class="n">B</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">ℓ</span><span class="o">,</span> <span class="n">h1_left</span><span class="o">,</span> <span class="n">h1_right</span><span class="bp">⟩</span><span class="o">,</span>
<span class="n">transitivity</span><span class="o">,</span>
<span class="n">swap</span><span class="o">,</span> <span class="n">symmetry</span><span class="o">,</span>
<span class="n">all_goals</span>
<span class="o">{</span> <span class="n">apply</span> <span class="n">h1_right</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">assumption&#39;</span> <span class="o">},</span>
</pre></div>

<a name="185678744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678744">Marc Masdeu (Jan 15 2020 at 08:47)</a>:</h4>
<p>OK, I got it. I thought that h1 was a function so that I could apply it by doing something like <code>h1 r</code> but this never worked. I hadn't thought of doing the <code>.right</code> and I still don't see the reasoning behind it.</p>

<a name="185678802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678802">Johan Commelin (Jan 15 2020 at 08:48)</a>:</h4>
<p>Sure, it also took me some time to parse it. But it is of the form <code>... ∧ ...</code></p>

<a name="185678806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678806">Johan Commelin (Jan 15 2020 at 08:48)</a>:</h4>
<p>And the right hand side is a function</p>

<a name="185678846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678846">Marc Masdeu (Jan 15 2020 at 08:49)</a>:</h4>
<p>Oh! How can I check this kind of things inside a proof? If h1 was defined outside, I would start trying <code>#check h1</code>, <code>#check h1 r</code> and so on, but I couldn't do anything like that inside the proof...</p>

<a name="185678911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678911">Johan Commelin (Jan 15 2020 at 08:50)</a>:</h4>
<p>Are you using VScode?</p>

<a name="185678934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678934">Johan Commelin (Jan 15 2020 at 08:50)</a>:</h4>
<p>Because it lists your entire context in the tactic state</p>

<a name="185678954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678954">Johan Commelin (Jan 15 2020 at 08:51)</a>:</h4>
<p>In the same place where you would see the output of <code>#check foobar</code></p>

<a name="185678957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678957">Marc Masdeu (Jan 15 2020 at 08:51)</a>:</h4>
<p>No, I'm using cocalc (I want some summer camp students to be able to play around with this, and wanted to set something up easy to use for them)</p>

<a name="185678967"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678967" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678967">Johan Commelin (Jan 15 2020 at 08:51)</a>:</h4>
<p>But where do you see the output of <code>#check h1</code> in CoCalc?</p>

<a name="185678968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185678968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185678968">Johan Commelin (Jan 15 2020 at 08:51)</a>:</h4>
<p>Probably in some message window somewhere</p>

<a name="185679031"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679031" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679031">Johan Commelin (Jan 15 2020 at 08:52)</a>:</h4>
<p>You are also seeing the goal that you want to prove somewhere. Right above it should be a list of all your hypotheses.</p>

<a name="185679036"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679036" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679036">Marc Masdeu (Jan 15 2020 at 08:52)</a>:</h4>
<p>Yes, there is a message window. But if I want to know the type of something, for example, I can't ask for it there.</p>

<a name="185679059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679059">Johan Commelin (Jan 15 2020 at 08:52)</a>:</h4>
<p>I'm copy-pasting this from your first message:</p>
<div class="codehilite"><pre><span></span><span class="mi">2</span> <span class="n">goals</span>
<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span>
<span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">,</span>
<span class="n">hAr</span> <span class="o">:</span> <span class="n">A</span><span class="err">∈</span><span class="n">r</span><span class="o">,</span>
<span class="n">hBr</span> <span class="o">:</span> <span class="n">B</span><span class="err">∈</span><span class="n">r</span><span class="o">,</span>
<span class="n">hAs</span> <span class="o">:</span> <span class="n">A</span><span class="err">∈</span><span class="n">s</span><span class="o">,</span>
<span class="n">hBs</span> <span class="o">:</span> <span class="n">B</span><span class="err">∈</span><span class="n">s</span><span class="o">,</span>
<span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">),</span> <span class="n">A</span><span class="err">∈</span><span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span><span class="err">∈</span><span class="n">ℓ</span><span class="o">)</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">),</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">),</span> <span class="n">A</span><span class="err">∈</span><span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span><span class="err">∈</span><span class="n">ℓ</span><span class="o">)</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">ℓ</span>
<span class="err">⊢</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">ℓ</span>
</pre></div>

<a name="185679079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679079">Marc Masdeu (Jan 15 2020 at 08:53)</a>:</h4>
<p>Yes, I see the hypotheses and everything, and they get updated as I advance. A lot like the web interface of the natural number game. What I don't have is autocompletion.</p>

<a name="185679081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679081">Johan Commelin (Jan 15 2020 at 08:53)</a>:</h4>
<p>That's where you can see <code>h1 : (λ (ℓ : Lines), A∈ℓ ∧ B∈ℓ) ℓ ∧ ∀ (y : Lines), (λ (ℓ : Lines), A∈ℓ ∧ B∈ℓ) y → y = ℓ</code></p>

<a name="185679094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679094">Johan Commelin (Jan 15 2020 at 08:53)</a>:</h4>
<p>That's the type of <code>h1</code></p>

<a name="185679110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679110">Johan Commelin (Jan 15 2020 at 08:53)</a>:</h4>
<p>Hmm... what exactly do you mean? I thought CoCalc had some form of autocomplete</p>

<a name="185679275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679275">Marc Masdeu (Jan 15 2020 at 08:56)</a>:</h4>
<p>I don't think it has any autocompletion (unless I have it disabled somehow!). What I meant --and maybe it's still me being stupid-- is that if I want to run some command (like <code>h1 r</code>) inside the proof to see what it would give me, I will probably get a useless error.</p>

<a name="185679287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679287">Alex J. Best (Jan 15 2020 at 08:56)</a>:</h4>
<p>If you are in a tactic block and you want to know the type of something you can <code>have what_am_i := thing_I_dont_know,</code> then in the info at cursor block you should see <code>what_am_i : ℕ</code>  or whatever it is</p>

<a name="185679314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679314">Marc Masdeu (Jan 15 2020 at 08:57)</a>:</h4>
<p>Oh <span class="user-mention" data-user-id="127136">@Alex J. Best</span>  this is clever! Thanks.</p>

<a name="185679317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679317">Alex J. Best (Jan 15 2020 at 08:57)</a>:</h4>
<p><a href="/user_uploads/3121/xEkVmxTm9brRbz4qtJYljgir/Screen-Shot-2020-01-15-at-14.27.06.png" target="_blank" title="Screen-Shot-2020-01-15-at-14.27.06.png">Screen-Shot-2020-01-15-at-14.27.06.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/xEkVmxTm9brRbz4qtJYljgir/Screen-Shot-2020-01-15-at-14.27.06.png" target="_blank" title="Screen-Shot-2020-01-15-at-14.27.06.png"><img src="/user_uploads/3121/xEkVmxTm9brRbz4qtJYljgir/Screen-Shot-2020-01-15-at-14.27.06.png"></a></div>

<a name="185679323"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679323" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679323">Johan Commelin (Jan 15 2020 at 08:57)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> Aha, I see. This might be one way to "hack" it:</p>
<div class="codehilite"><pre><span></span><span class="n">rcases</span> <span class="n">I1</span> <span class="n">A</span> <span class="n">B</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">ℓ</span><span class="o">,</span> <span class="n">h1</span><span class="bp">⟩</span><span class="o">,</span>
<span class="k">have</span> <span class="n">test</span> <span class="o">:=</span> <span class="n">h1</span> <span class="n">r</span><span class="o">,</span>
</pre></div>


<p>This will give you an error</p>

<a name="185679331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679331">Johan Commelin (Jan 15 2020 at 08:57)</a>:</h4>
<p>Aah, ok, Alex beat me (-;</p>

<a name="185679385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679385">Marc Masdeu (Jan 15 2020 at 08:58)</a>:</h4>
<p>You guys are incredibly helpful! Thanks!!</p>

<a name="185679397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679397">Alex J. Best (Jan 15 2020 at 08:58)</a>:</h4>
<p>This is normally how I build terms, start with a function /lemma I want to apply with no arguments as have, then add arguments one by one till it gets to what I want.</p>

<a name="185679459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679459">Marc Masdeu (Jan 15 2020 at 08:59)</a>:</h4>
<p>Aha. Yes, I want to learn how to translate the way we do math usually, into Lean.<br>
I'll go back and try to prove a few more stupid lemmas. Probably will come back very soon...</p>

<a name="185679514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679514">Johan Commelin (Jan 15 2020 at 09:00)</a>:</h4>
<p>Good luck! (-;</p>

<a name="185679551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679551">Alex J. Best (Jan 15 2020 at 09:00)</a>:</h4>
<p>Some form of tab completion works for me in Cocalc by the way <a href="/user_uploads/3121/hbgKfvJGbnGwwr4ILnbst3ju/Screen-Shot-2020-01-15-at-14.30.23.png" target="_blank" title="Screen-Shot-2020-01-15-at-14.30.23.png">Screen-Shot-2020-01-15-at-14.30.23.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/hbgKfvJGbnGwwr4ILnbst3ju/Screen-Shot-2020-01-15-at-14.30.23.png" target="_blank" title="Screen-Shot-2020-01-15-at-14.30.23.png"><img src="/user_uploads/3121/hbgKfvJGbnGwwr4ILnbst3ju/Screen-Shot-2020-01-15-at-14.30.23.png"></a></div>

<a name="185679591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679591">Alex J. Best (Jan 15 2020 at 09:01)</a>:</h4>
<p>I typed <code>apply and.</code> then hit tab, the first 20 results were random general things, but then it showed me various <code>and</code> related lemmas and their types.<br>
Actually it worked better when I did <code>apply a</code> then tab then continued typing. I think the <code>.</code> was doing something a little funny with the tab completion.</p>

<a name="185679903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185679903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185679903">Marc Masdeu (Jan 15 2020 at 09:07)</a>:</h4>
<p>I'll try. I seem to remember that in VScode the completion appeared without the tab, this confused me.</p>

<a name="185691667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185691667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185691667">Marc Masdeu (Jan 15 2020 at 12:15)</a>:</h4>
<p>OK, so I'm a bit further down. So far, I have:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>
<span class="c1">-- We want to be able to define functions using the law of excluded middle</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">,</span> <span class="n">priority</span> <span class="mi">0</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>


<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">constant</span> <span class="n">Points</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kn">constant</span> <span class="n">Lines</span> <span class="o">:</span> <span class="n">set</span><span class="o">(</span><span class="n">set</span> <span class="n">Points</span><span class="o">)</span>
<span class="kn">constant</span> <span class="n">lies_on</span> <span class="o">:</span> <span class="n">Points</span> <span class="bp">→</span> <span class="n">Lines</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="n">local</span> <span class="kn">infixl</span> <span class="bp">`</span><span class="err">∈</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">lies_on</span>
<span class="kn">notation</span> <span class="n">x</span> <span class="bp">`</span><span class="err">∋</span><span class="bp">`</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">lies_on</span> <span class="n">y</span> <span class="n">x</span>
<span class="kn">constant</span> <span class="n">I1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span>  <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">ℓ</span><span class="o">,</span> <span class="o">(</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span>
<span class="kn">constant</span> <span class="n">I2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span>
<span class="kn">constant</span> <span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">)))</span>

<span class="kn">notation</span> <span class="n">p</span> <span class="bp">`</span><span class="n">xor</span><span class="bp">`</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">q</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">I11</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span>  <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">ℓ</span><span class="o">,</span> <span class="o">(</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">I1</span> <span class="n">A</span> <span class="n">B</span> <span class="n">h</span> <span class="k">with</span> <span class="n">ℓ</span> <span class="n">h1</span><span class="o">,</span>
<span class="n">existsi</span> <span class="n">ℓ</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">H</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">H</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">I12</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">B</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">B</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span>  <span class="n">r</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">r</span> <span class="n">s</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">hAr</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">hBr</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">hAs</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">hBs</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">I1</span> <span class="n">A</span> <span class="n">B</span> <span class="n">h</span> <span class="k">with</span> <span class="n">ℓ</span> <span class="n">h1</span><span class="o">,</span>
<span class="n">transitivity</span> <span class="n">ℓ</span><span class="o">,</span>
<span class="k">have</span> <span class="n">r_eq_ell</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">ℓ</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">h1</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
<span class="n">split</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">hAr</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">hBr</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">r_eq_ell</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s_eq_ell</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">ℓ</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">h1</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
<span class="n">split</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">hAs</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">hBs</span><span class="o">,</span>
<span class="n">symmetry</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">s_eq_ell</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">there_are_two_points</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">cases</span> <span class="n">I3</span> <span class="k">with</span> <span class="n">A</span> <span class="n">BCh</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">BCh</span> <span class="k">with</span> <span class="n">B</span> <span class="n">Ch</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">Ch</span> <span class="k">with</span> <span class="n">C</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">hh</span><span class="o">,</span>
<span class="n">existsi</span> <span class="n">A</span><span class="o">,</span>
<span class="n">existsi</span> <span class="n">B</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">hh</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">distinct_lines_have_at_most_one_common_point</span> <span class="o">{</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">}</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">}</span> <span class="o">(</span><span class="n">hrs</span><span class="o">:</span> <span class="n">r</span> <span class="bp">≠</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hAr</span><span class="o">:</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">hAs</span><span class="o">:</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hBr</span><span class="o">:</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">hBs</span><span class="o">:</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">=</span> <span class="n">B</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">suffices</span> <span class="n">not_A_eq_B</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">),</span>
<span class="n">cc</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">suffices</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">s</span><span class="o">,</span>
<span class="n">contradiction</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">I12</span> <span class="n">A</span> <span class="n">B</span> <span class="n">r</span> <span class="n">s</span> <span class="n">h</span> <span class="n">hAr</span> <span class="n">hBr</span> <span class="n">hAs</span> <span class="n">hBs</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">definition</span> <span class="n">intersect</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">A</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">r</span> <span class="bp">∧</span> <span class="n">A</span><span class="err">∈</span> <span class="n">s</span>
<span class="kn">definition</span> <span class="n">parallel</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">r</span> <span class="bp">=</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬</span> <span class="n">intersect</span> <span class="n">r</span> <span class="n">s</span><span class="o">)</span>
<span class="n">local</span> <span class="kn">infixl</span> <span class="bp">`||`</span> <span class="o">:=</span> <span class="n">parallel</span>

<span class="kn">constant</span> <span class="n">parallel_postulate</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">Points</span><span class="o">}</span> <span class="o">{</span><span class="n">ℓ</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">}</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">r</span> <span class="bp">∧</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">r</span> <span class="bp">||</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">s</span> <span class="bp">||</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">s</span>

<span class="kn">constant</span> <span class="n">between</span> <span class="o">:</span> <span class="n">Points</span> <span class="bp">→</span> <span class="n">Points</span> <span class="bp">→</span> <span class="n">Points</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kn">notation</span> <span class="n">A</span> <span class="bp">`*`</span> <span class="n">B</span> <span class="bp">`*`</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">between</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span>
<span class="kn">definition</span> <span class="n">colinear</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Points</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span>
<span class="c1">-- definition noncolinear (A B C : Points) := ¬ colinear A B C</span>

<span class="kn">constant</span> <span class="n">B11</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Points</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">C</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span><span class="o">)</span>
<span class="kn">constant</span> <span class="n">B12</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Points</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">colinear</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span>
<span class="kn">constant</span> <span class="n">B2</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">}</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">C</span><span class="o">,</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span>
<span class="kn">constant</span> <span class="n">B3</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Points</span><span class="o">}</span> <span class="o">{</span><span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">((</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="o">(</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="o">)</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">B</span><span class="o">))</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="o">)</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">B</span><span class="o">))</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="o">(</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">B</span><span class="o">))</span>
<span class="c1">-- constant B4 {A B C D: Points} {ℓ : Lines}: (noncolinear A B C) ∧ (¬ A ∈ ℓ) ∧ (¬ B ∈ ℓ) ∧ (¬ C ∈ ℓ) ∧ (D ∈ ℓ) ∧ (A * D * B)  → (∃ E : Points, (A * E * C) xor (B * E * C))</span>

<span class="n">def</span> <span class="n">line_segment</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Points</span> <span class="o">:=</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="err">∪</span> <span class="o">{</span><span class="n">B</span><span class="o">}</span> <span class="err">∪</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">Points</span> <span class="bp">|</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">B</span><span class="o">}</span>
<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`#`</span> <span class="o">:=</span> <span class="n">line_segment</span>

<span class="n">def</span> <span class="n">triangle</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Points</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">colinear</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Points</span> <span class="o">:=</span> <span class="n">A</span><span class="bp">#</span><span class="n">B</span> <span class="err">∪</span> <span class="n">A</span><span class="bp">#</span><span class="n">C</span> <span class="err">∪</span> <span class="n">B</span><span class="bp">#</span><span class="n">C</span>

<span class="kn">lemma</span> <span class="n">segments_are_symmetric</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="n">A</span> <span class="bp">#</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">B</span> <span class="bp">#</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">antisymm_iff</span><span class="o">,</span>
<span class="n">split</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="k">have</span> <span class="n">hh</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">A</span> <span class="bp">∨</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">B</span> <span class="bp">∨</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">B</span><span class="o">,</span>
<span class="o">{</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">ha</span> <span class="n">hb</span><span class="o">,</span>
<span class="n">left</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">ha</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">ha</span><span class="o">,</span>
<span class="n">exfalso</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">ha</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hb</span><span class="o">,</span>
<span class="n">right</span><span class="o">,</span>
<span class="n">left</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">hb</span><span class="o">,</span>
<span class="n">exfalso</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">hb</span><span class="o">,</span>
<span class="n">right</span><span class="o">,</span>
<span class="n">right</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">h2</span><span class="o">,</span>
<span class="o">},</span>
<span class="n">cases</span> <span class="n">hh</span> <span class="k">with</span> <span class="n">H1</span> <span class="n">H2</span><span class="o">,</span>
<span class="n">left</span><span class="o">,</span>
<span class="n">right</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">singleton_def</span><span class="o">,</span>
<span class="n">left</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">H1</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">H2</span> <span class="k">with</span> <span class="n">H</span> <span class="n">G</span><span class="o">,</span>
<span class="n">left</span><span class="o">,</span>
<span class="n">left</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">set</span><span class="bp">.</span><span class="n">singleton_def</span><span class="o">,</span>
<span class="n">left</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">H</span><span class="o">,</span>
<span class="n">right</span><span class="o">,</span>
<span class="bp">...</span>
<span class="kn">end</span>
</pre></div>


<p>I am trying to prove that the segments AB and BA are the same, and I'm having lots of trouble. The "math" way to prove it is:<br>
recall that AB is defined to be the union of {A}, {B} and the points in between A and B. We have axiom I12 which says that x is betwen A and B implies x is between B and A. So <em>obviously</em> the segments AB and BA are equal. What I do in Lean is quite longer, but first I turn to a double inclusion (I would like to know how to prove the second one "by symmetry"), and I'm trying to finish one of the inclusions. I'm at the point where it's "enough" to apply axiom I12: my goal looks like:</p>
<div class="codehilite"><pre><span></span><span class="n">A</span> <span class="n">B</span> <span class="n">x</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">A</span><span class="bp">#</span><span class="n">B</span><span class="o">,</span>
<span class="n">G</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">x</span><span class="bp">*</span><span class="n">B</span>
<span class="err">⊢</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">Points</span> <span class="bp">|</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="bp">*</span><span class="n">A</span><span class="o">}</span>
</pre></div>


<p>and I want to tell Lean to "expand" hypothesis G and use I12. Any hints?</p>

<a name="185691875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185691875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185691875">Johan Commelin (Jan 15 2020 at 12:18)</a>:</h4>
<p>Ooof, some of your lines are quite long (-;</p>

<a name="185692019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185692019" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185692019">Johan Commelin (Jan 15 2020 at 12:21)</a>:</h4>
<p>In your definition of <code>triangle</code>, I think you want <code>¬ colinear A B C</code></p>

<a name="185692205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185692205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185692205">Johan Commelin (Jan 15 2020 at 12:24)</a>:</h4>
<p>Also, the Lean keyword for <code>...</code> is <code>sorry</code></p>

<a name="185692448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185692448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185692448">Johan Commelin (Jan 15 2020 at 12:26)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> Here is one way to use symmetry to reduce to 1 inclusion:</p>
<div class="codehilite"><pre><span></span><span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="n">A</span> <span class="bp">#</span> <span class="n">B</span> <span class="err">⊆</span> <span class="n">B</span> <span class="bp">#</span> <span class="n">A</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">antisymm</span><span class="bp">;</span> <span class="n">solve_by_elim</span> <span class="o">},</span>
  <span class="n">intros</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">sorry</span>
</pre></div>

<a name="185692472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185692472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185692472">Johan Commelin (Jan 15 2020 at 12:27)</a>:</h4>
<p>Ideally, the <code>wlog</code> tactic would do this for you. But I usually end up in a big fight if I try to use it.</p>

<a name="185692716"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185692716" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185692716">Johan Commelin (Jan 15 2020 at 12:30)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> Here's another hint: First prove two lemmas <code>A ∈ A#B</code> and <code>B ∈ A#B</code>. They will be useful in lots of places.</p>

<a name="185692864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185692864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185692864">Johan Commelin (Jan 15 2020 at 12:33)</a>:</h4>
<p>Also, you overwrote the standard meaning of <code>∈</code>, so my suggestions no longer typecheck</p>

<a name="185693216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185693216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185693216">Johan Commelin (Jan 15 2020 at 12:39)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">segments_are_symmetric</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="n">A</span> <span class="bp">#</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">B</span> <span class="bp">#</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="n">A</span> <span class="bp">#</span> <span class="n">B</span> <span class="err">⊆</span> <span class="n">B</span> <span class="bp">#</span> <span class="n">A</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">antisymm</span><span class="bp">;</span> <span class="n">solve_by_elim</span> <span class="o">},</span>
  <span class="n">intros</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="bp">⟨⟨</span><span class="n">rfl</span> <span class="bp">|</span> <span class="bp">⟨⟨⟩⟩⟩</span> <span class="bp">|</span> <span class="n">rfl</span> <span class="bp">|</span> <span class="bp">⟨⟨⟩⟩⟩</span> <span class="bp">|</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">unfold</span> <span class="n">line_segment</span><span class="o">,</span> <span class="n">finish</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">unfold</span> <span class="n">line_segment</span><span class="o">,</span> <span class="n">finish</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">unfold</span> <span class="n">line_segment</span><span class="o">,</span> <span class="k">have</span> <span class="o">:=</span> <span class="n">B11</span> <span class="n">h</span><span class="o">,</span> <span class="n">finish</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>

<a name="185693251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185693251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185693251">Johan Commelin (Jan 15 2020 at 12:39)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> I found that crazy <code>rcases</code> line, by writing <code>rcases? h</code> and copying from the message window.</p>

<a name="185693316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185693316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185693316">Johan Commelin (Jan 15 2020 at 12:40)</a>:</h4>
<p>All those weird brackets and <code>rfl</code>s tell Lean that most of the things you need to do are really very trivial.</p>

<a name="185693332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185693332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185693332">Johan Commelin (Jan 15 2020 at 12:40)</a>:</h4>
<p>What remains are the (mildly <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span>) interesting cases.</p>

<a name="185693537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185693537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185693537">Johan Commelin (Jan 15 2020 at 12:42)</a>:</h4>
<p><code>finish</code> is a tactic that says: "Given the current hypothesis, this is elementary logic. I can do that."</p>

<a name="185694276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185694276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185694276">Alex J. Best (Jan 15 2020 at 12:53)</a>:</h4>
<p>Just for fun I did this too without looking at Johan's, I think they're fundamentally the same? I didn't know the crazy <code>rcases</code> thing though.</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">segments_are_symmetric</span><span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="n">A</span> <span class="bp">#</span> <span class="n">B</span> <span class="bp">=</span> <span class="n">B</span> <span class="bp">#</span> <span class="n">A</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">suffices</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="n">A</span> <span class="bp">#</span> <span class="n">B</span> <span class="err">⊆</span> <span class="n">B</span> <span class="bp">#</span> <span class="n">A</span><span class="o">,</span>
<span class="o">{</span>
  <span class="n">intros</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">le_antisymm</span> <span class="o">(</span><span class="n">this</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">this</span> <span class="n">B</span> <span class="n">A</span><span class="o">),</span><span class="c1">-- i just typed library_search to get this,</span>
<span class="o">},</span>
<span class="n">rintros</span> <span class="n">A</span> <span class="n">B</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">line_segment</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">simp</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">or</span><span class="bp">.</span><span class="n">assoc</span> <span class="n">at</span> <span class="n">hx</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim3</span> <span class="n">hx</span><span class="o">,</span>
<span class="n">all_goals</span> <span class="o">{</span><span class="n">intros</span><span class="o">,</span><span class="n">try</span><span class="o">{</span><span class="n">cc</span><span class="o">},},</span>
<span class="n">apply</span> <span class="n">or</span><span class="bp">.</span><span class="n">intro_right</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">B11</span> <span class="n">a</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="185695141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185695141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185695141">Marc Masdeu (Jan 15 2020 at 13:04)</a>:</h4>
<p>Thanks guys, I'm studying your solutions now...</p>

<a name="185695410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185695410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185695410">Marc Masdeu (Jan 15 2020 at 13:08)</a>:</h4>
<p>About <span class="user-mention" data-user-id="112680">@Johan Commelin</span> complaint about long lines: I definitely agree with it, but how would you go about writing the simple statement "Given three distinct points on a line, exactly one of them is between the other two" in a concise way?</p>

<a name="185695504"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185695504" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185695504">Alex J. Best (Jan 15 2020 at 13:09)</a>:</h4>
<p>I guess Johan just means put some line breaks in at natural looking points (lean won't care)</p>

<a name="185696350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185696350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185696350">Marc Masdeu (Jan 15 2020 at 13:20)</a>:</h4>
<blockquote>
<p>I guess Johan just means put some line breaks in at natural looking points (lean won't care)</p>
</blockquote>
<p>Oh <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>

<a name="185697184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185697184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185697184">Marc Masdeu (Jan 15 2020 at 13:32)</a>:</h4>
<blockquote>
<p>Also, you overwrote the standard meaning of <code>∈</code>, so my suggestions no longer typecheck</p>
</blockquote>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> to solve this, I have decided to go back to set theory. That means that Points should be a set, and that Lines should be a set of sets of points. If I initialize</p>
<div class="codehilite"><pre><span></span>Points : set Type u
Lines : set set Points
</pre></div>


<p>then my axioms start to misbehave, because <em>I assume</em> that it doesn't make sense to write A : Points and instead I should write someting like A \in Points. Am I right?</p>

<a name="185697524"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185697524" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185697524">Kevin Buzzard (Jan 15 2020 at 13:37)</a>:</h4>
<p>I would be tempted to let points be in a type, and lines be subsets of points, if you want to go down the subset route.</p>

<a name="185697562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185697562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185697562">Kenny Lau (Jan 15 2020 at 13:37)</a>:</h4>
<p>one would first have to prove <code>lines.ext</code> then</p>

<a name="185697825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185697825" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185697825">Kevin Buzzard (Jan 15 2020 at 13:40)</a>:</h4>
<p>I can prove that</p>

<a name="185697846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185697846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185697846">Kevin Buzzard (Jan 15 2020 at 13:41)</a>:</h4>
<p>it follows from <code>propext</code></p>

<a name="185697892"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185697892" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185697892">Marc Masdeu (Jan 15 2020 at 13:41)</a>:</h4>
<blockquote>
<p>I would be tempted to let points be in a type, and lines be subsets of points, if you want to go down the subset route.</p>
</blockquote>
<p>I have two reasons to do that: I am trying to copy Hartshorne's UTM book and he defines points to be a set. The second reason is so that in this way I don't need to define what A \in ell means.</p>
<p>Your intermediate approach seems to solve my second concern, I will try that.</p>

<a name="185697946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185697946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185697946">Marc Masdeu (Jan 15 2020 at 13:42)</a>:</h4>
<blockquote>
<p>one would first have to prove <code>lines.ext</code> then</p>
</blockquote>
<p>What is that?</p>

<a name="185697986"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185697986" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185697986">Kevin Buzzard (Jan 15 2020 at 13:43)</a>:</h4>
<blockquote>
<p>he defines points to be a set</p>
</blockquote>
<p>That's because he's thinking about framing things in terms of set theory. There are two kinds of sets. There are subsets of a given set, like the even numbers, and there are generic sets about which we know nothing -- and in type theory those are types.</p>

<a name="185698012"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698012" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698012">Kevin Buzzard (Jan 15 2020 at 13:43)</a>:</h4>
<p><code>lines.ext</code> is the statement that two lines are equal if and only for all points P, P is in line 1 iff it's in line 2. One can prove this in Lean no problem.</p>

<a name="185698183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698183">Kevin Buzzard (Jan 15 2020 at 13:45)</a>:</h4>
<p>In contrast to the "generic" set of points, a line is a subset. Subsets are different to sets.</p>

<a name="185698258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698258" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698258">Marc Masdeu (Jan 15 2020 at 13:46)</a>:</h4>
<p>And two subsets are not automatically equal iff they contain the same elements? I am getting lost.</p>

<a name="185698260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698260">Kevin Buzzard (Jan 15 2020 at 13:46)</a>:</h4>
<p>I don't know anything about the various ways of doing this stuff. I know that Ali Sever followed Tarski, and IIRC a line was an abstract type. What does Hartshorne do?</p>

<a name="185698285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698285">Kevin Buzzard (Jan 15 2020 at 13:46)</a>:</h4>
<blockquote>
<p>And two subsets are not automatically equal iff they contain the same elements? I am getting lost.</p>
</blockquote>
<p>It is a trivial theorem, but it is not true by definition.</p>

<a name="185698337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698337">Kevin Buzzard (Jan 15 2020 at 13:47)</a>:</h4>
<p>In fact it is equivalent to propositional extensionality, which is talked about at great length <a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#propositional-extensionality" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#propositional-extensionality">here</a>. As a mathematician you should just ignore all this. Kenny is a constructivist, he is just trolling really.</p>

<a name="185698391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698391" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698391">Kevin Buzzard (Jan 15 2020 at 13:48)</a>:</h4>
<p>Remember that in set theory there is an axiom which says that two sets with the same elements are equal.</p>

<a name="185698450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698450">Kevin Buzzard (Jan 15 2020 at 13:49)</a>:</h4>
<p>Equal sets have the same elements -- this is obvious. Sets with the same elements are equal -- this is a theorem, whose one-line proof is "it's an axiom"</p>

<a name="185698470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698470">Kevin Buzzard (Jan 15 2020 at 13:49)</a>:</h4>
<p>so you will have to supply a one-line proof ;-)</p>

<a name="185698482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698482">Marc Masdeu (Jan 15 2020 at 13:49)</a>:</h4>
<p>From Hartshorne: "We simply postulate a set, whose elements are called <em>points</em>, together with certain subsets, which we call <em>lines</em>. We do not say what the points are, nor which subsets form lines, but we do require that these undefined notions obey certain axioms..."</p>

<a name="185698608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698608">Kevin Buzzard (Jan 15 2020 at 13:50)</a>:</h4>
<p>OK so you should make a type of points, and let lines be subsets. Then everything will work just the way Hartshorne wants.</p>

<a name="185698714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698714">Marc Masdeu (Jan 15 2020 at 13:52)</a>:</h4>
<blockquote>
<p>Equal sets have the same elements -- this is obvious. Sets with the same elements are equal -- this is a theorem, whose one-line proof is "it's an axiom"</p>
</blockquote>
<p>Oh. And Lean standard doesn't come with these theorems proven for you? I would imagine that if Lean knows what a set is, then it knows all the basic theorems on set theory.</p>

<a name="185698727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698727">Kevin Buzzard (Jan 15 2020 at 13:52)</a>:</h4>
<p>The difference between type theory and set theory is that in type theory, the only sets you can have are subsets of a fixed set. It took me a long time to realise that mathematicians use the concept of set in two different ways.</p>

<a name="185698775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698775">Kevin Buzzard (Jan 15 2020 at 13:53)</a>:</h4>
<p>It could easily be a theorem in core Lean. Kenny is just trolling. He seems to have caused you a great deal of confusion. There is nothing special about <code>lines.ext</code>. You will have to prove lots of theorems.</p>

<a name="185698841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698841">Kevin Buzzard (Jan 15 2020 at 13:53)</a>:</h4>
<p>The point is that if you make a new <em>definition</em> (e.g. <code>lines</code>) then you will have to prove lots of theorems about that definition.</p>

<a name="185698957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698957">Marc Masdeu (Jan 15 2020 at 13:55)</a>:</h4>
<p>Oh I see. And yes, I'm becoming more confused the more I learn. This is fine, though!</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">,</span> <span class="n">priority</span> <span class="mi">0</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>

<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">constant</span> <span class="n">Points</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kn">constant</span> <span class="n">Lines</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">Points</span><span class="o">)</span>
<span class="kn">constant</span> <span class="n">I1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span>  <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">ℓ</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span> <span class="o">(</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span>
</pre></div>


<p>Why does Lean complain in the last line?</p>
<p>---- &gt; I figured it out! Now Lines is a set :-)</p>

<a name="185698966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185698966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185698966">Kevin Buzzard (Jan 15 2020 at 13:55)</a>:</h4>
<p>Take a look at <a href="https://github.com/leanprover-community/mathlib/blob/master/src/data/complex/basic.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/data/complex/basic.lean">the way Lean does complex numbers</a>. A new definition, and then immediately you have to prove a bunch of trivial theorems about <code>complex</code>. Lean might have lots of theorems about sets, but if you define <code>lines</code> then you have to prove theorems about <code>lines</code> including trivial theorems.</p>

<a name="185699146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185699146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185699146">Marc Masdeu (Jan 15 2020 at 13:57)</a>:</h4>
<blockquote>
<p>Take a look at <a href="https://github.com/leanprover-community/mathlib/blob/master/src/data/complex/basic.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/data/complex/basic.lean">the way Lean does complex numbers</a>. A new definition, and then immediately you have to prove a bunch of trivial theorems about <code>complex</code>. Lean might have lots of theorems about sets, but if you define <code>lines</code> then you have to prove theorems about <code>lines</code> including trivial theorems.</p>
</blockquote>
<p>I see. That will keep me busy.</p>

<a name="185704612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185704612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185704612">Marc Masdeu (Jan 15 2020 at 14:53)</a>:</h4>
<p>This morning I sweated to prove (with help!)</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">I12</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">Lines</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">B</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">B</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span>  <span class="n">r</span> <span class="bp">=</span> <span class="n">s</span>
</pre></div>


<p>I modified it now to work with lines being sets of points:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">I12</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">r</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">B</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">B</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span>  <span class="n">r</span> <span class="bp">=</span> <span class="n">s</span>
</pre></div>


<p>But the proof I had stopped working. I am stuck at:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">I12</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">r</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">B</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">B</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span>  <span class="n">r</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">A</span> <span class="n">B</span> <span class="n">r</span> <span class="n">s</span> <span class="n">rL</span> <span class="n">sL</span> <span class="n">h</span> <span class="n">hAr</span> <span class="n">hBr</span> <span class="n">hAs</span> <span class="n">hBs</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">I1</span> <span class="n">A</span> <span class="n">B</span> <span class="n">h</span><span class="o">),</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>and I am trying to complete it using the fact that I1 is a lot stronger...</p>
<p>Moreover, I don't like that there are so many hypothesis. It seems that this is a side effect of working with sets.</p>

<a name="185706065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185706065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185706065">Bryan Gin-ge Chen (Jan 15 2020 at 15:07)</a>:</h4>
<p>If you use <code>variables</code>  you can state some hypotheses just once at the beginning of a <code>section</code> or <code>namespace</code>. See <a href="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#variables-and-sections" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#variables-and-sections">2.6 of Theorem Proving in Lean</a> if you haven't already.</p>

<a name="185706476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185706476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185706476">Bryan Gin-ge Chen (Jan 15 2020 at 15:11)</a>:</h4>
<p>Oh, I guess you may also want to state your lemma like this to avoid the giant <code>intros</code> at the start of the proof:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">I12</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Points</span><span class="o">}</span> <span class="o">(</span><span class="n">rL</span> <span class="o">:</span> <span class="n">r</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">)</span> <span class="o">(</span><span class="n">sL</span> <span class="o">:</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hAr</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">hBr</span> <span class="o">:</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">hAs</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hBs</span> <span class="o">:</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>

<a name="185706835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185706835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185706835">Johan Commelin (Jan 15 2020 at 15:15)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> At this point, if you really want to pursue the geometry formalisation (instead of just fooling around to learn more Lean), I think it would be useful to look at the previous attempts.</p>

<a name="185707250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185707250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185707250">Marc Masdeu (Jan 15 2020 at 15:19)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="254058">Marc Masdeu</span> At this point, if you really want to pursue the geometry formalisation (instead of just fooling around to learn more Lean), I think it would be useful to look at the previous attempts.</p>
</blockquote>
<p>Oh I do want to fool around. Formalizing geometry was just what I picked as a testing grounds, since it doesn't itself have much pre-requisites. Eventually I will want to teach students how to use this, so I better learn a bit first.</p>

<a name="185707545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185707545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185707545">Bryan Gin-ge Chen (Jan 15 2020 at 15:22)</a>:</h4>
<p>Could you post what you have in its entirety? Otherwise I can only guess how you corrected <code>I1</code>.</p>

<a name="185707665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185707665" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185707665">Marc Masdeu (Jan 15 2020 at 15:23)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>
<span class="c1">-- We want to be able to define functions using the law of excluded middle</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">,</span> <span class="n">priority</span> <span class="mi">0</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>


<span class="n">noncomputable</span> <span class="n">theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">constant</span> <span class="n">Points</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kn">constant</span> <span class="n">Lines</span> <span class="o">:</span> <span class="n">set</span><span class="o">(</span><span class="n">set</span><span class="o">(</span><span class="n">Points</span><span class="o">))</span>

<span class="kn">constant</span> <span class="n">I1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span>  <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">),</span> <span class="o">(</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span>
<span class="kn">constant</span> <span class="n">I2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span>
<span class="kn">constant</span> <span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">)))</span>

<span class="kn">notation</span> <span class="n">p</span> <span class="bp">`</span><span class="n">xor</span><span class="bp">`</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">q</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">I12</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">r</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">B</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span>  <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">B</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span>  <span class="n">r</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">A</span> <span class="n">B</span> <span class="n">r</span> <span class="n">s</span> <span class="n">rL</span> <span class="n">sL</span> <span class="n">h</span> <span class="n">hAr</span> <span class="n">hBr</span> <span class="n">hAs</span> <span class="n">hBs</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">I1</span> <span class="n">A</span> <span class="n">B</span> <span class="n">h</span><span class="o">),</span>

<span class="kn">end</span>
</pre></div>

<a name="185708513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185708513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185708513">Kevin Buzzard (Jan 15 2020 at 15:31)</a>:</h4>
<p>Does <code>open_locale classical</code> not automatically do the local attribute business? What happens if you delete line 3?</p>

<a name="185708728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185708728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185708728">Marc Masdeu (Jan 15 2020 at 15:33)</a>:</h4>
<p>I don't see any change. I copied line 3 from somewhere, and kept the comment since I do want to use the LEM.</p>

<a name="185709505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185709505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185709505">Bryan Gin-ge Chen (Jan 15 2020 at 15:40)</a>:</h4>
<p>The <code>unfold</code>s are unnecessary, but may help you see what's going on.</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">I12</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Points</span><span class="o">}</span> <span class="o">{</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Points</span><span class="o">}</span> <span class="o">(</span><span class="n">rL</span> <span class="o">:</span> <span class="n">r</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">)</span> <span class="o">(</span><span class="n">sL</span> <span class="o">:</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hAr</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">hBr</span> <span class="o">:</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">hAs</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hBs</span> <span class="o">:</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">I1</span> <span class="n">A</span> <span class="n">B</span> <span class="n">h</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">unfold</span> <span class="n">exists_unique</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">rL</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="n">assumption</span><span class="o">,</span>
    <span class="n">assumption</span><span class="o">,</span>
    <span class="n">finish</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">unfold</span> <span class="n">exists_unique</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">sL</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="n">assumption</span><span class="o">,</span>
    <span class="n">assumption</span><span class="o">,</span>
    <span class="n">finish</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>

<a name="185710009"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185710009" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185710009">Marc Masdeu (Jan 15 2020 at 15:45)</a>:</h4>
<p>Thanks! Now that we are at this. You changed a lot the definition of the lemma, by removing all the foralls, for example. What is the difference between the two, and which form should I prefer? The form that I had was a bit similar to what I would do in math, and this notation breaks the symmetry between forall and exists, right?</p>

<a name="185710703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185710703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185710703">Marc Masdeu (Jan 15 2020 at 15:52)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>  I don't understand what did the <code>finish</code> do...</p>

<a name="185712264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185712264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185712264">Bryan Gin-ge Chen (Jan 15 2020 at 16:06)</a>:</h4>
<p>At a mathematical level they're equivalent. There are slight differences when it comes to how Lean interprets them due to the fact that I made <code>A</code>, <code>B</code>, <code>r</code> and <code>s</code> <a href="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#implicit-arguments" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#implicit-arguments">"implicit arguments"</a> using curly braces.</p>
<p>In Lean what I wrote is generally preferred since it saves a lot of typing. (Using <code>variables</code> would be even better). Could you say more about the symmetry you expect between forall and exists? </p>
<p><code>finish</code> is a tactic which is able to clear "obvious" goals if they just boil down to logical manipulation. In this case, it turns out that you can just as well use <code>intros, refl</code> instead of <code>finish</code>.</p>

<a name="185712858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185712858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185712858">Marc Masdeu (Jan 15 2020 at 16:11)</a>:</h4>
<blockquote>
<p>Could you say more about the symmetry you expect between forall and exists? </p>
</blockquote>
<p>Well, how would you write in Lean these two statements (which I see as "symmetrical"):<br>
<code>for all x,  P(x)</code> and <code>there exists x, P(x)</code>.</p>

<a name="185713087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185713087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185713087">Bryan Gin-ge Chen (Jan 15 2020 at 16:13)</a>:</h4>
<p>I'd write them like this: <code>∀ x, P x</code>, <code>∃ x, P x</code>. They behave rather differently though.</p>

<a name="185713305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185713305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185713305">Kevin Buzzard (Jan 15 2020 at 16:15)</a>:</h4>
<p>They are yin and yang</p>

<a name="185713626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185713626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185713626">Bryan Gin-ge Chen (Jan 15 2020 at 16:18)</a>:</h4>
<p>"forall x" indicates to me that the thing that follows is a function of x. (It just happens to take values in the world of logical propositions). Lean lets us write such statements using more function-oriented syntax (we can give x as an argument to the function).</p>

<a name="185713637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185713637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185713637">Marc Masdeu (Jan 15 2020 at 16:18)</a>:</h4>
<p>Yes, that's the symmetry that I meant! But you see, if you want to write a lemma one could write:<br>
<code>lemma hasP : \forall x : Type, P x</code> or <code>lemma existsP : \exists x : Type, P x</code>. The first one can be rewritten as<br>
<code>lemma hasP {x : Type} : P x</code>. What about the second?</p>

<a name="185713691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185713691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185713691">Kevin Buzzard (Jan 15 2020 at 16:18)</a>:</h4>
<p>You can't move the exists to the left of the colon. They are different in that respect.</p>

<a name="185713773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185713773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185713773">Kevin Buzzard (Jan 15 2020 at 16:19)</a>:</h4>
<p>The general concept of "negation" switches them around</p>

<a name="185713951"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185713951" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185713951">Marc Masdeu (Jan 15 2020 at 16:20)</a>:</h4>
<blockquote>
<p>You can't move the exists to the left of the colon. They are different in that respect.</p>
</blockquote>
<p>I think that this is what I was observing. I guess one gets used to it.</p>

<a name="185713975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185713975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185713975">Johan Commelin (Jan 15 2020 at 16:20)</a>:</h4>
<p>I guess this constructive logic leaking through....</p>

<a name="185713990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185713990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185713990">Johan Commelin (Jan 15 2020 at 16:20)</a>:</h4>
<p>Because there they aren't symmetric at all.</p>

<a name="185714865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185714865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185714865">Kevin Buzzard (Jan 15 2020 at 16:29)</a>:</h4>
<p>They are like night and day. "I can see in the day, how come I can't see in the night?"</p>

<a name="185714980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185714980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185714980">Bryan Gin-ge Chen (Jan 15 2020 at 16:30)</a>:</h4>
<p>Since forall gives rise to functions maybe exists should arise from co-functions (in the sense of <a href="https://en.wikipedia.org/wiki/Coinduction" target="_blank" title="https://en.wikipedia.org/wiki/Coinduction">"co-data"</a>?)...</p>

<a name="185715114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185715114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185715114">Chris Hughes (Jan 15 2020 at 16:31)</a>:</h4>
<p>It is a coproduct.</p>

<a name="185715151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185715151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185715151">Chris Hughes (Jan 15 2020 at 16:31)</a>:</h4>
<p>And functions are products.</p>

<a name="185723201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185723201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185723201">Kevin Buzzard (Jan 15 2020 at 17:45)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> -- here's the difference between sets and types. If a mathematician says "let G be a group and let S be a set, and imagine G acts on S, blah blah blah..." then they don't actually mean this, because imagine the chaos that would ensue if a random element of G (which is just a random set) turned out to coincidentally be an element of S, or a subset of S, or something? You could imagine that this would be irritating -- or just a bit weird. We don't say "assume moreover that G and S are disjoint" though, because sometimes we might well want to set G = S. What is happening is that we want elements of G to be "things of type G" and elements of S to be "things of type S" and we know that even if there were some random sets which happened to be in G and in S by accident, it won't matter, because as long as we know what we're doing, and we call them g if they're in G and s if they're in S, we can "pretend they're different". </p>
<p>This is why you want points to be a type, because a point will always be "a thing which is a point", you'll never use a point to do anything else other than being a point. Computer scientists say "a thing of type Point" for "a thing which is a point". </p>
<p>On the other hand, you absolutely want to allow lines to contain a common point, and this is a natural part of the theory. So you don't want lines to be types, you want them to be subsets, or possibly subtypes, of the type of points.</p>

<a name="185725409"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185725409" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185725409">Marc Masdeu (Jan 15 2020 at 18:05)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> thanks for the very nice explanation. We usually don't think about this, and it's surprising how long one can be doing maths without ever having this clarified.</p>

<a name="185870984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185870984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185870984">Vaibhav Karve (Jan 16 2020 at 22:56)</a>:</h4>
<blockquote>
<p>The difference between type theory and set theory is that in type theory, the only sets you can have are subsets of a fixed set. It took me a long time to realise that mathematicians use the concept of set in two different ways.</p>
</blockquote>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Can you elaborate on that? Things that obey ZFC is one way i can think of. What's the other?</p>

<a name="185871439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185871439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185871439">Mario Carneiro (Jan 16 2020 at 23:03)</a>:</h4>
<p>There are sets, and then there are subsets. These are treated in the same way by ZFC</p>

<a name="185871742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185871742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185871742">Mario Carneiro (Jan 16 2020 at 23:06)</a>:</h4>
<p>Sometimes, you just talk about an arbitrary set taken from the universe of all sets. These are like types in type theory. Other times you have a set that lives in another set, for example an open set in a topology. These admit a reasonable notion of intersection, complement, and other such things, and they are represented by elements of the type <code>set A</code></p>

<a name="185906658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185906658" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185906658">Marc Masdeu (Jan 17 2020 at 11:19)</a>:</h4>
<p>OK back to Hilbert's axioms. I have introduced a few more axioms and proved some more basic lemmas about them. The file is getting long and Lean takes time to react after each small change, so I decide to reorganize things a bit.</p>
<ul>
<li>Is it possible to "input" (in the LaTeX terminology) a file, so that Lean just inserts the content of that file at the beginning?<br>
A better way would be to start writing a structure, and this is the route I'd like to take (mainly for the sake of learning how to do it). So I have:</li>
</ul>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="c1">-- We want to be able to define functions using the law of excluded middle</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="kn">structure</span> <span class="n">HilbertPlane</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>

<span class="o">(</span><span class="n">Lines</span> <span class="o">:</span> <span class="n">set</span><span class="o">(</span><span class="n">set</span><span class="o">(</span><span class="n">Point</span><span class="o">)))</span>
<span class="o">(</span><span class="n">lies_on</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Lines</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="o">(</span><span class="n">I1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span>  <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">),</span> <span class="o">(</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">))</span>
<span class="o">(</span><span class="n">I2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="o">(</span><span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">))))</span>
<span class="o">(</span><span class="n">between</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
</pre></div>


<p>and Lean seems happy so far. But for the next axioms I want to have some notation. In the previous version I had something like</p>
<div class="codehilite"><pre><span></span><span class="kn">notation</span> <span class="n">A</span> <span class="bp">`*`</span> <span class="n">B</span> <span class="bp">`*`</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">between</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span>
<span class="kn">definition</span> <span class="n">colinear</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∃</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">HilbertPlane</span><span class="bp">.</span><span class="n">Lines</span><span class="o">,</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span>
</pre></div>


<p>but now both lines fail. I assume that this gets me out of the structure, but I would really like to have such notation inside to be able to both state the axioms in a more readable way, and also in order to be able to use the HilbertPlane structure in an easy way later when writing theorems.<br>
How is this done in Lean (I looked at <span class="user-mention" data-user-id="120256">@Ali Sever</span> solution and in the list of axioms there is no notation being added...).<br>
Thanks!</p>

<a name="185907088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185907088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185907088">Kevin Buzzard (Jan 17 2020 at 11:26)</a>:</h4>
<p><code>import</code> = input</p>

<a name="185907173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185907173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185907173">Kevin Buzzard (Jan 17 2020 at 11:28)</a>:</h4>
<p>Marc -- if you want to get confused about imports, take a look at <a href="https://github.com/ImperialCollegeLondon/M4P33/blob/master/src/abstract_V_and_I.lean" target="_blank" title="https://github.com/ImperialCollegeLondon/M4P33/blob/master/src/abstract_V_and_I.lean">my lecture for today</a></p>

<a name="185907405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185907405" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185907405">Marc Masdeu (Jan 17 2020 at 11:32)</a>:</h4>
<blockquote>
<p>Marc -- if you want to get confused about imports, take a look at <a href="https://github.com/ImperialCollegeLondon/M4P33/blob/master/src/abstract_V_and_I.lean" target="_blank" title="https://github.com/ImperialCollegeLondon/M4P33/blob/master/src/abstract_V_and_I.lean">my lecture for today</a></p>
</blockquote>
<p>I thought that import was more like \include. In particular, if I split a file into two files (foo.lean and bar.lean) and put <code>import foo</code> in bar.lean I get complaints all over.</p>

<a name="185907445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185907445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185907445">Johan Commelin (Jan 17 2020 at 11:33)</a>:</h4>
<p><span class="user-mention" data-user-id="254058">@Marc Masdeu</span> You can use <code>import</code>, but you will have to reopen namespaces and such</p>

<a name="185907560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185907560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185907560">Marc Masdeu (Jan 17 2020 at 11:35)</a>:</h4>
<p>I thought <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> and <span class="user-mention" data-user-id="112680">@Johan Commelin</span> would tell me to definitely pursue my second option (structures). Is it that it it's not so easy to do what I wanted?</p>

<a name="185907647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185907647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185907647">Mario Carneiro (Jan 17 2020 at 11:36)</a>:</h4>
<p>You can do the notation in the middle of defining the structure by enclosing it in parentheses, like so:</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">HilbertPlane</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>

<span class="o">(</span><span class="n">Lines</span> <span class="o">:</span> <span class="n">set</span><span class="o">(</span><span class="n">set</span><span class="o">(</span><span class="n">Point</span><span class="o">)))</span>
<span class="o">(</span><span class="n">lies_on</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Lines</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="o">(</span><span class="n">I1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span>  <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">),</span> <span class="o">(</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">))</span>
<span class="o">(</span><span class="n">I2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="o">(</span><span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">))))</span>
<span class="o">(</span><span class="n">between</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kn">notation</span> <span class="n">A</span> <span class="bp">`*`</span> <span class="n">B</span> <span class="bp">`*`</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">between</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span>
</pre></div>


<p>The definition is however not so easy</p>

<a name="185907683"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185907683" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185907683">Mario Carneiro (Jan 17 2020 at 11:37)</a>:</h4>
<p>You could make it another part of the structure, but then it isn't guaranteed to have the definition you want and you have to impose that separately</p>

<a name="185907700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185907700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185907700">Johan Commelin (Jan 17 2020 at 11:37)</a>:</h4>
<p>Concerning using <code>notation</code> in the definition of a structure: See how it's done for categories a long time ago: <a href="https://github.com/leanprover-community/mathlib/blob/c06fb67cf8b7bcc3e5e76c46b699d01cd4c212a6/src/category_theory/category.lean#L46L54" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/c06fb67cf8b7bcc3e5e76c46b699d01cd4c212a6/src/category_theory/category.lean#L46L54">https://github.com/leanprover-community/mathlib/blob/c06fb67cf8b7bcc3e5e76c46b699d01cd4c212a6/src/category_theory/category.lean#L46L54</a></p>

<a name="185907749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185907749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185907749">Johan Commelin (Jan 17 2020 at 11:38)</a>:</h4>
<p>Aha, Mario beat me.</p>

<a name="185907774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185907774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185907774">Johan Commelin (Jan 17 2020 at 11:38)</a>:</h4>
<p>You have to restate the notation after the definition if you want it to exist outside the structure definition</p>

<a name="185907971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185907971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185907971">Mario Carneiro (Jan 17 2020 at 11:40)</a>:</h4>
<p>Otherwise, you have to define the structure in two stages, like so:</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">PreHilbertPlane</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>

<span class="o">(</span><span class="n">Lines</span> <span class="o">:</span> <span class="n">set</span><span class="o">(</span><span class="n">set</span><span class="o">(</span><span class="n">Point</span><span class="o">)))</span>
<span class="o">(</span><span class="n">lies_on</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Lines</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="o">(</span><span class="n">I1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span>  <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">),</span> <span class="o">(</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">))</span>
<span class="o">(</span><span class="n">I2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="o">(</span><span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">))))</span>
<span class="o">(</span><span class="n">between</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kn">notation</span> <span class="n">A</span> <span class="bp">`*`</span> <span class="n">B</span> <span class="bp">`*`</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">between</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span>

<span class="kn">definition</span> <span class="n">colinear</span> <span class="o">{</span><span class="n">Point</span><span class="o">}</span> <span class="o">(</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">PreHilbertPlane</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Lines</span><span class="o">,</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span>

<span class="kn">structure</span> <span class="n">HilbertPlane</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">PreHilbertPlane</span> <span class="n">Point</span> <span class="o">:=</span>
<span class="o">(</span><span class="kn">notation</span> <span class="bp">`</span><span class="n">colinear</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">colinear</span> <span class="n">to_PreHilbertPlane</span><span class="o">)</span>
<span class="o">(</span><span class="n">foo</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">colinear</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span><span class="o">)</span>
<span class="o">(</span><span class="n">etc</span> <span class="o">:</span> <span class="bp">...</span><span class="o">)</span>
</pre></div>

<a name="185908160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185908160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185908160">Johan Commelin (Jan 17 2020 at 11:43)</a>:</h4>
<p>How about extending the code that Kenny built in the other thread?</p>

<a name="185908575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185908575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185908575">Marc Masdeu (Jan 17 2020 at 11:49)</a>:</h4>
<p>That code has lots of things that I don't understand: class, instance, @[...], ... Also, the set of axioms is different. There are several formalizations of geometry, what I am trying to do is: take Hartshorne's UTM book and translate some chapters into Lean. I'd like to do this in the most straightforward way: ideally, you should be able to translate clear pen-and-paper thoughts into Lean, not having to re-think them. So if at some point he introduces a definition, I'd like to do so at the same point, etcetera.</p>

<a name="185908611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185908611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185908611">Marc Masdeu (Jan 17 2020 at 11:49)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Is that Lean-Kosher and not a hack? I want to think about <code>between</code> and <code>colinear</code> in a very similar way. One is an undefined property that 3 points can have, whereas the other is a defined property.</p>

<a name="185908689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185908689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185908689">Mario Carneiro (Jan 17 2020 at 11:50)</a>:</h4>
<p>The way I wrote it in the last code snippet, it is a defined property</p>

<a name="185908783"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185908783" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185908783">Mario Carneiro (Jan 17 2020 at 11:52)</a>:</h4>
<p>The version with it being an undefined property with a characterization looks like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">HilbertPlane</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>

<span class="o">(</span><span class="n">Lines</span> <span class="o">:</span> <span class="n">set</span><span class="o">(</span><span class="n">set</span><span class="o">(</span><span class="n">Point</span><span class="o">)))</span>
<span class="o">(</span><span class="n">lies_on</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Lines</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="o">(</span><span class="n">I1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span>  <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">),</span> <span class="o">(</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">))</span>
<span class="o">(</span><span class="n">I2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="o">(</span><span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">))))</span>
<span class="o">(</span><span class="n">between</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kn">notation</span> <span class="n">A</span> <span class="bp">`*`</span> <span class="n">B</span> <span class="bp">`*`</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">between</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span>
<span class="o">(</span><span class="n">colinear</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="n">colinear_def</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">,</span> <span class="n">colinear</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="o">(</span><span class="n">etc</span> <span class="o">:</span> <span class="bp">...</span><span class="o">)</span>
</pre></div>

<a name="185908942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185908942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185908942">Marc Masdeu (Jan 17 2020 at 11:54)</a>:</h4>
<blockquote>
<p>The way I wrote it in the last code snippet, it is a defined property</p>
</blockquote>
<p>Yes, I meant that the way <code>between</code> and <code>colinear</code> are introduced in the code is very different (and also now I have an extra structure, which may be useful but requires changing the layout I had initially)...</p>

<a name="185909034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185909034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185909034">Marc Masdeu (Jan 17 2020 at 11:56)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Oh! So the last code snippet does work? This is exactly what I was looking for.</p>

<a name="185909081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185909081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185909081">Mario Carneiro (Jan 17 2020 at 11:57)</a>:</h4>
<p>There is a third option, which is to have <code>colinear</code> be a (large) notation in the definition, resulting in complicated axioms, but then pick up the pieces afterward</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">HilbertPlane</span> <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>

<span class="o">(</span><span class="n">Lines</span> <span class="o">:</span> <span class="n">set</span><span class="o">(</span><span class="n">set</span><span class="o">(</span><span class="n">Point</span><span class="o">)))</span>
<span class="o">(</span><span class="n">lies_on</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Lines</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="o">(</span><span class="n">I1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span>  <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">),</span> <span class="o">(</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">))</span>
<span class="o">(</span><span class="n">I2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="o">(</span><span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">))))</span>
<span class="o">(</span><span class="n">between</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="o">(</span><span class="kn">notation</span> <span class="n">A</span> <span class="bp">`*`</span> <span class="n">B</span> <span class="bp">`*`</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">between</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span>
<span class="o">(</span><span class="kn">notation</span> <span class="bp">`</span><span class="n">colinear</span><span class="bp">`</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span>
<span class="o">(</span><span class="n">foo</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">colinear</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span><span class="o">)</span>

<span class="n">def</span> <span class="n">colinear</span> <span class="o">{</span><span class="n">Point</span><span class="o">}</span> <span class="o">(</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">HilbertPlane</span> <span class="n">Point</span><span class="o">)</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">∃</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Lines</span><span class="o">,</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span>

<span class="kn">theorem</span> <span class="n">HilbertPlane</span><span class="bp">.</span><span class="n">foo&#39;</span> <span class="o">{</span><span class="n">Point</span><span class="o">}</span> <span class="o">(</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">HilbertPlane</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">a</span><span class="o">,</span> <span class="n">colinear</span> <span class="err">Ω</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">HilbertPlane</span><span class="bp">.</span><span class="n">foo</span> <span class="bp">_</span>
</pre></div>

<a name="185909233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185909233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185909233">Mario Carneiro (Jan 17 2020 at 11:59)</a>:</h4>
<p>Note that the actual type of <code>HilbertPlane.foo</code> here is:</p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">print</span> <span class="n">HilbertPlane</span><span class="bp">.</span><span class="n">foo</span>
<span class="c1">-- def HilbertPlane.foo : ∀ {Point : Type u} (c : HilbertPlane Point) (a : Point),</span>
<span class="c1">--   (λ (A B C : Point), ∃ (ℓ : set Point) (H : ℓ ∈ c.Lines), A ∈ ℓ ∧ B ∈ ℓ ∧ C ∈ ℓ) a a a</span>
</pre></div>

<a name="185909522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185909522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185909522">Mario Carneiro (Jan 17 2020 at 12:03)</a>:</h4>
<blockquote>
<p>There are several formalizations of geometry, what I am trying to do is: take Hartshorne's UTM book and translate some chapters into Lean. I'd like to do this in the most straightforward way: ideally, you should be able to translate clear pen-and-paper thoughts into Lean, not having to re-think them. So if at some point he introduces a definition, I'd like to do so at the same point, etcetera.</p>
</blockquote>
<p>Sadly, this approach generally doesn't work out in the long term. Trying to stick too closely to a mathematical presentation can make your job harder than it already is</p>

<a name="185909608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185909608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185909608">Mario Carneiro (Jan 17 2020 at 12:04)</a>:</h4>
<p>Using a math text as a guide is a good idea, but expect to have to make small modifications frequently</p>

<a name="185909811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185909811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185909811">Marc Masdeu (Jan 17 2020 at 12:07)</a>:</h4>
<blockquote>
<p>Sadly, this approach generally doesn't work out in the long term. Trying to stick too closely to a mathematical presentation can make your job harder than it already is</p>
</blockquote>
<p>I agree with you that if you want to make such code available to others it is best to think carefully on design so that you don't run into problems later. My goal is different: I am trying to learn Lean "as a user", and one way is to see how everything that a book (or myself) would want to put in a paper can be translated. Same happens when you program: writing a library / module is very different than translating an idea you have for an algorithm into python, say.</p>

<a name="185910121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185910121" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185910121">Mario Carneiro (Jan 17 2020 at 12:12)</a>:</h4>
<p>I think what you are doing is a valuable way to learn, and a math text is a good starting point. I'm just saying that you shouldn't be afraid to make modifications in service of easier formalization</p>

<a name="185910163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185910163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185910163">Mario Carneiro (Jan 17 2020 at 12:13)</a>:</h4>
<p>which is itself important for learning how to write "lean idioms", things that work with the theorem prover rather than against it</p>

<a name="185910291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185910291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185910291">Marc Masdeu (Jan 17 2020 at 12:15)</a>:</h4>
<p>Completely agree. When I learned Python, the code that I wrote looked a lot like what I would have written in C. The more I learned, the more Python slang I could fluently speak and then I started thinking of my algorithms in a more pythonic way. I am at the first stage with Lean.</p>

<a name="185910376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185910376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185910376">Mario Carneiro (Jan 17 2020 at 12:16)</a>:</h4>
<p>While I am not saying you should just pick up Kenny's code, it does have a lot of idioms in it that could be useful for you</p>

<a name="185911701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185911701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185911701">Marc Masdeu (Jan 17 2020 at 12:36)</a>:</h4>
<p>I am trying to understand what's in there, but I find it hard (I don't yet know enough Lean language).</p>

<a name="185913019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/185913019" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#185913019">Sebastien Gouezel (Jan 17 2020 at 12:56)</a>:</h4>
<p>colinear or collinear?</p>

<a name="186095793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186095793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186095793">Marc Masdeu (Jan 20 2020 at 12:07)</a>:</h4>
<p>I have put the definitions into a class, split the code into two files and I am running into more problems.</p>
<ol>
<li>I learned that I couldn't put the definitions in <code>axioms.lean</code> because then things broke. I changed the file name into <code>hpdefs.lean</code> and suddenly it worked. This was utterly frustrating, is there a simple explanation?</li>
<li>I don't now how to use the notations that I defined in the class I made, in another file.</li>
</ol>
<p>This is my code so far:</p>
<p>hpdefs.lean file:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">namespace</span> <span class="n">hilbertplane</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="c1">-- We want to be able to define functions using the law of excluded middle</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="kn">notation</span> <span class="n">p</span> <span class="bp">`</span><span class="n">xor</span><span class="bp">`</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">q</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">p</span><span class="o">)</span>

<span class="n">class</span> <span class="n">HilbertPlane</span><span class="o">:=</span>
    <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
    <span class="o">(</span><span class="n">Lines</span> <span class="o">:</span> <span class="n">set</span><span class="o">(</span><span class="n">set</span><span class="o">(</span><span class="n">Point</span><span class="o">)))</span>

    <span class="o">(</span><span class="n">I1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span>  <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">),</span> <span class="o">(</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">))</span>
    <span class="o">(</span><span class="n">I2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span>
    <span class="o">(</span><span class="n">I3</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">))))</span>
    <span class="o">(</span><span class="n">between</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="kn">notation</span> <span class="n">A</span> <span class="bp">`*`</span> <span class="n">B</span> <span class="bp">`*`</span> <span class="n">C</span> <span class="o">:=</span> <span class="n">between</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span>
    <span class="o">(</span><span class="n">collinear</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="n">collinear_def</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">,</span> <span class="n">collinear</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">,</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span>
    <span class="o">(</span><span class="n">noncollinear</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="n">noncollinear_def</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">,</span> <span class="n">noncollinear</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="n">collinear</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span>

    <span class="o">(</span><span class="n">B11</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">C</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span><span class="o">))</span>
    <span class="o">(</span><span class="n">B12</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">collinear</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">))</span>
    <span class="o">(</span><span class="n">B2</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">C</span><span class="o">,</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span>
    <span class="o">(</span><span class="n">B3</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">{</span><span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">}</span>
        <span class="o">(</span><span class="n">hAB</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hAC</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span><span class="o">)</span> <span class="o">(</span><span class="n">hBC</span> <span class="o">:</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span><span class="o">)</span>
        <span class="o">(</span><span class="n">hAl</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">(</span><span class="n">hBl</span> <span class="o">:</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">(</span><span class="n">hCl</span> <span class="o">:</span> <span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">:</span>
        <span class="o">((</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="o">(</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="o">)</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">B</span><span class="o">))</span> <span class="bp">∨</span>
        <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="o">)</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">B</span><span class="o">))</span> <span class="bp">∨</span>
        <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="o">(</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">B</span><span class="o">)))</span>

    <span class="o">(</span><span class="n">B4</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span><span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">{</span><span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">}</span>
        <span class="o">(</span><span class="n">hnc</span><span class="o">:</span> <span class="n">noncollinear</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span>
        <span class="o">(</span><span class="n">hnAl</span><span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">))</span> <span class="o">(</span><span class="n">hnBl</span><span class="o">:</span> <span class="bp">¬</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">(</span><span class="n">hnCl</span><span class="o">:</span> <span class="bp">¬</span> <span class="n">C</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span>
        <span class="o">(</span><span class="n">hDl</span><span class="o">:</span> <span class="n">D</span> <span class="err">∈</span> <span class="n">ℓ</span><span class="o">)</span> <span class="o">(</span><span class="n">hADB</span><span class="o">:</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">D</span> <span class="bp">*</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">E</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">E</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="n">xor</span> <span class="o">(</span><span class="n">B</span> <span class="bp">*</span> <span class="n">E</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)))</span>

    <span class="o">(</span><span class="n">intersect</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="n">intersect_def</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span><span class="o">(</span><span class="n">Point</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">intersect</span> <span class="n">r</span> <span class="n">s</span> <span class="bp">↔</span> <span class="bp">∃</span> <span class="n">A</span> <span class="o">:</span> <span class="n">Point</span><span class="o">,</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">r</span> <span class="bp">∧</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">s</span><span class="o">))</span>

    <span class="o">(</span><span class="n">parallel</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">Point</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
    <span class="o">(</span><span class="n">parallel_def</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">r</span> <span class="n">s</span> <span class="bp">↔</span>  <span class="n">r</span> <span class="err">∈</span> <span class="n">Lines</span> <span class="bp">∧</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">Lines</span> <span class="bp">→</span> <span class="o">(</span><span class="n">r</span> <span class="bp">=</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬</span> <span class="o">(</span><span class="n">intersect</span> <span class="n">r</span> <span class="n">s</span><span class="o">)))</span>
    <span class="o">(</span><span class="kn">notation</span> <span class="n">r</span> <span class="bp">`||`</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">parallel</span> <span class="n">r</span> <span class="n">s</span><span class="o">)</span>

    <span class="o">(</span><span class="n">parallel_postulate</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="n">Point</span><span class="o">}</span> <span class="o">{</span><span class="n">ℓ</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Point</span><span class="o">}</span>
        <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">)</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="n">r</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">Lines</span><span class="o">)</span> <span class="o">:</span>
        <span class="n">A</span> <span class="err">∈</span> <span class="n">r</span> <span class="bp">∧</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">r</span> <span class="bp">||</span> <span class="n">ℓ</span> <span class="bp">∧</span> <span class="n">s</span> <span class="bp">||</span> <span class="n">ℓ</span> <span class="bp">→</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">s</span><span class="o">)</span>

    <span class="o">(</span><span class="n">line_segment</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Point</span> <span class="o">:=</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="err">∪</span> <span class="o">{</span><span class="n">B</span><span class="o">}</span> <span class="err">∪</span> <span class="o">{</span><span class="n">C</span> <span class="bp">|</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">C</span> <span class="bp">*</span> <span class="n">B</span><span class="o">})</span>
    <span class="o">(</span><span class="kn">notation</span> <span class="n">A</span> <span class="bp">`#`</span> <span class="n">B</span> <span class="o">:=</span> <span class="n">line_segment</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span>
    <span class="o">(</span><span class="n">triangle</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span>  <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">noncollinear</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Point</span> <span class="o">:=</span> <span class="o">(</span><span class="n">A</span><span class="bp">#</span><span class="n">B</span><span class="o">)</span> <span class="err">∪</span> <span class="o">(</span><span class="n">A</span><span class="bp">#</span><span class="n">C</span><span class="o">)</span> <span class="err">∪</span> <span class="o">(</span><span class="n">B</span><span class="bp">#</span><span class="n">C</span><span class="o">))</span>

<span class="kn">end</span> <span class="n">hilbertplane</span>
</pre></div>


<p>firstlemmas.lean</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="bp">.</span><span class="n">hpdefs</span>

<span class="kn">open</span> <span class="n">hilbertplane</span>

<span class="kn">variables</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">HilbertPlane</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Point</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">ℓ</span> <span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">set</span><span class="o">(</span><span class="err">Ω</span><span class="bp">.</span><span class="n">Point</span><span class="o">)}</span>


<span class="kn">lemma</span> <span class="n">I11</span> <span class="o">:</span>  <span class="bp">∀</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">ℓ</span> <span class="err">∈</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Lines</span><span class="o">,</span> <span class="o">(</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">ℓ</span> <span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">HilbertPlane</span><span class="bp">.</span><span class="n">I1</span> <span class="n">A</span> <span class="n">B</span> <span class="n">h</span> <span class="k">with</span> <span class="n">ℓ</span> <span class="n">h1</span><span class="o">,</span>
<span class="n">existsi</span> <span class="n">ℓ</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h1</span> <span class="k">with</span> <span class="n">H</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">exists_of_exists_unique</span> <span class="n">H</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">endpoints_are_in_segment</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">A</span> <span class="err">∈</span> <span class="n">A</span><span class="bp">#</span><span class="n">B</span> <span class="bp">∧</span> <span class="n">B</span> <span class="err">∈</span> <span class="n">A</span><span class="bp">#</span><span class="n">B</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">split</span><span class="bp">;</span> <span class="o">{</span>
<span class="n">unfold</span> <span class="n">line_segment</span><span class="o">,</span>
<span class="n">finish</span><span class="o">,</span>
<span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>and the lemma <code>endpoints_are_in_segment</code> bothers Lean because it doesn't understand the <code>#</code> notation. Any pointers? Thank you.</p>

<a name="186098024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186098024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186098024">Mario Carneiro (Jan 20 2020 at 12:40)</a>:</h4>
<p>The filename thing sounds mysterious. Could you describe more precisely what you did and what happened?</p>

<a name="186098125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186098125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186098125">Mario Carneiro (Jan 20 2020 at 12:42)</a>:</h4>
<p>One possibility that comes to mind is that <code>axioms</code> is a keyword, so if you write <code>import axioms</code> it will import nothing and then start declaring axioms</p>

<a name="186098304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186098304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186098304">Mario Carneiro (Jan 20 2020 at 12:45)</a>:</h4>
<p>If you really want to call the file <code>axioms.lean</code>, you can import it using french quote escapes: <code>import «axioms»</code></p>

<a name="186098433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186098433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186098433">Mario Carneiro (Jan 20 2020 at 12:46)</a>:</h4>
<p>As for notations, you have to redeclare all the notations outside the structure because they are scoped to the structure definition itself</p>

<a name="186100042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186100042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186100042">Marc Masdeu (Jan 20 2020 at 13:07)</a>:</h4>
<blockquote>
<p>The filename thing sounds mysterious. Could you describe more precisely what you did and what happened?</p>
</blockquote>
<p>Rename the file <code>hpdefs.lean</code> into <code>axioms.lean</code>. Then in <code>firstlemmas.lean</code> have the first line <code>import .axioms</code> and Lean complains. But your explanation is reasonable. I will avoid this file name in the future.</p>

<a name="186265955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186265955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186265955">Marc Masdeu (Jan 22 2020 at 08:48)</a>:</h4>
<p>OK, I got stuck again. I don't see why the following code does not work:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="c1">-- We want to be able to define functions using the law of excluded middle</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="n">class</span> <span class="n">HilbertPlane</span><span class="o">:=</span>
    <span class="o">(</span><span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
    <span class="o">(</span><span class="n">Lines</span> <span class="o">:</span> <span class="n">set</span><span class="o">(</span><span class="n">set</span><span class="o">(</span><span class="n">Point</span><span class="o">)))</span>
    <span class="o">(</span><span class="n">line_segment</span> <span class="o">:</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">Point</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">Point</span><span class="o">)</span>
    <span class="o">(</span><span class="n">line_segment_def</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">line_segment</span> <span class="n">A</span> <span class="n">B</span> <span class="bp">=</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="err">∪</span> <span class="o">{</span><span class="n">B</span><span class="o">})</span>

<span class="kn">constant</span> <span class="err">Ω</span> <span class="o">:</span> <span class="n">HilbertPlane</span>

<span class="kn">lemma</span> <span class="n">endpoints_are_in_segment</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="o">(</span><span class="err">Ω</span><span class="bp">.</span><span class="n">line_segment</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>It is frustrating, since this works perfectly:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="c1">-- We want to be able to define functions using the law of excluded middle</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="kn">constant</span> <span class="n">Point</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kn">constant</span> <span class="n">Lines</span> <span class="o">:</span> <span class="n">set</span><span class="o">(</span><span class="n">set</span><span class="o">(</span><span class="n">Point</span><span class="o">))</span>
<span class="kn">definition</span> <span class="n">line_segment</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">Point</span> <span class="o">:=</span> <span class="o">{</span><span class="n">A</span><span class="o">}</span> <span class="err">∪</span> <span class="o">{</span><span class="n">B</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">endpoints_are_in_segment</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="n">line_segment</span> <span class="n">A</span> <span class="n">B</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">unfold</span> <span class="n">line_segment</span><span class="o">,</span>
<span class="n">finish</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>Apart from the solution, I would appreciate being able to tell in the future how to fix these issues (by reading at errors, or using "debugging" commands in Lean). I hope I didn't have to constantly ask Zulip...</p>

<a name="186267136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186267136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186267136">Mario Carneiro (Jan 22 2020 at 09:04)</a>:</h4>
<p>Let's start with the error message.</p>
<div class="codehilite"><pre><span></span>invalid field notation, function &#39;HilbertPlane.line_segment&#39; does not have explicit argument with type (HilbertPlane ...)
</pre></div>


<p>Okay, that's weird. What type does it actually have?</p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">print</span> <span class="n">HilbertPlane</span><span class="bp">.</span><span class="n">line_segment</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span>
<span class="n">def</span> <span class="n">HilbertPlane</span><span class="bp">.</span><span class="n">line_segment</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">HilbertPlane</span><span class="o">],</span> <span class="n">HilbertPlane</span><span class="bp">.</span><span class="n">Point</span> <span class="bp">→</span> <span class="n">HilbertPlane</span><span class="bp">.</span><span class="n">Point</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">HilbertPlane</span><span class="bp">.</span><span class="n">Point</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">HilbertPlane</span><span class="o">],</span> <span class="o">[</span><span class="n">HilbertPlane</span><span class="bp">.</span><span class="n">line_segment</span> <span class="n">c</span><span class="o">]</span>
</pre></div>


<p>Notice that <code>c</code> here, the <code>HilbertPlane</code> argument in question, is in square brackets. That means it is intended to be inferred by type class inference. Why? Because you called <code>HilbertPlane</code> a <code>class</code> rather than a <code>structure</code>.</p>

<a name="186267723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186267723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186267723">Mario Carneiro (Jan 22 2020 at 09:13)</a>:</h4>
<p>The idea with typeclass arguments is that you don't specify them, you let lean figure them out. Let's try that:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">endpoints_are_in_segment</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="o">(</span><span class="n">line_segment</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<div class="codehilite"><pre><span></span>unknown identifier &#39;line_segment&#39;
</pre></div>


<p>Thanks lean. Guess we need to open the namespace</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">HilbertPlane</span>
<span class="kn">lemma</span> <span class="n">endpoints_are_in_segment</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="o">(</span><span class="n">line_segment</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<div class="codehilite"><pre><span></span>failed to synthesize type class instance for
A : Point,
B : Point
⊢ HilbertPlane
</pre></div>


<p>Okay, getting closer. It says it can't find an instance of <code>HilbertPlane</code>. (Notice also that it omits the <code>Ω</code> in <code>Point</code>. Clearly that's how it expects you to write it.) I will note at this point that <code>HilbertPlane</code> has no arguments, which is rather unusual for a typeclass. It's really only a useful construct if there is only ever one <code>HilbertPlane</code> around, but maybe that's the case for you.</p>

<a name="186267740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186267740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186267740">Mario Carneiro (Jan 22 2020 at 09:13)</a>:</h4>
<p>In any case, we can add it as an instance variable, and then lean should find it:</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="o">[</span><span class="n">HilbertPlane</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">HilbertPlane</span>
<span class="kn">lemma</span> <span class="n">endpoints_are_in_segment</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="o">(</span><span class="n">line_segment</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<div class="codehilite"><pre><span></span>kernel failed to type check declaration &#39;endpoints_are_in_segment&#39; this is usually due to a buggy tactic or a bug in the builtin elaborator
elaborated type:
  ∀ [_inst_1 : HilbertPlane] (A B : Point), A ∈ line_segment A B
elaborated value:
  λ [_inst_1 : HilbertPlane] (A B : Point), sorry
nested exception message:
invalid reference to undefined universe level parameter &#39;u_1&#39;
</pre></div>


<p>Ooh, these are extra special errors that you get if you managed to fool the tactic framework into producing an invalid proof. I think this will go away if you actually finish the proof, though.</p>

<a name="186268141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186268141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186268141">Mario Carneiro (Jan 22 2020 at 09:18)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="o">[</span><span class="n">HilbertPlane</span><span class="o">]</span>

<span class="kn">open</span> <span class="n">HilbertPlane</span>
<span class="kn">lemma</span> <span class="n">endpoints_are_in_segment</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="o">(</span><span class="n">line_segment</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">line_segment_def</span><span class="o">]</span>
</pre></div>


<div class="codehilite"><pre><span></span>kernel failed to type check declaration &#39;endpoints_are_in_segment&#39; this is usually due to a buggy tactic or a bug in the builtin elaborator
elaborated type:
  ∀ [_inst_1 : HilbertPlane] (A B : Point), A ∈ line_segment A B
elaborated value:
  λ [_inst_1 : HilbertPlane] (A B : Point),
    eq.mpr
      ...
      trivial
nested exception message:
invalid reference to undefined universe level parameter &#39;u_1&#39;
</pre></div>


<p>Apparently my hope was unfounded. This is an actual bug in lean, so I'm not sure what the best workaround is, but explicitly including the instance seems to work:</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="o">[</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">HilbertPlane</span><span class="o">]</span>
<span class="n">include</span> <span class="err">Ω</span>

<span class="kn">open</span> <span class="n">HilbertPlane</span>
<span class="kn">lemma</span> <span class="n">endpoints_are_in_segment</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="err">∈</span> <span class="o">(</span><span class="n">line_segment</span> <span class="n">A</span> <span class="n">B</span><span class="o">))</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">line_segment_def</span><span class="o">]</span> <span class="c1">-- works</span>
</pre></div>

<a name="186269915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186269915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186269915">Marc Masdeu (Jan 22 2020 at 09:42)</a>:</h4>
<p>Oh wow! This is a great explanation!! I will see if I can fit this into the rest of the code. Still, I doubt I'd be able to debug something like this in the future. Lean is hard.</p>

<a name="186274345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186274345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186274345">Patrick Massot (Jan 22 2020 at 10:45)</a>:</h4>
<p>I really don't see the point of having a type class with no argument. Why don't you make the type of points a parameter of <code>HilbertPlane</code>? This would be useful if you want to extend to three-dimensional geometry. Then you'll have subtypes having a <code>HilbertPlane</code> structure.</p>

<a name="186279198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186279198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186279198">Mario Carneiro (Jan 22 2020 at 11:52)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> One reason you might not want to use <code>HilbertPlane P</code> where <code>P</code> is the type of points is that there are also lines to deal with. Would you write <code>Lines P</code> for that type?</p>

<a name="186283929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186283929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186283929">Kevin Buzzard (Jan 22 2020 at 13:01)</a>:</h4>
<blockquote>
<p>Oh wow! This is a great explanation!! I will see if I can fit this into the rest of the code. Still, I doubt I'd be able to debug something like this in the future. Lean is hard.</p>
</blockquote>
<p>Algebraic number theory is hard. There's a learning curve. I couldn't do my first year example sheets for a long time. Working on them taught me basic logic, then defining schemes taught me about classes and structures, and then I learnt how to read the error messages, and now I can usually solve problems myself. The way to learn it is to do exactly what you're doing -- try some maths at a level which is suitable for your current formalisation skills and ask when you get stuck, then repeat</p>

<a name="186295344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186295344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186295344">Marc Masdeu (Jan 22 2020 at 15:15)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> and <span class="user-mention" data-user-id="110031">@Patrick Massot</span>  I will probably deal with these issues later...</p>

<a name="186295575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186295575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186295575">Marc Masdeu (Jan 22 2020 at 15:17)</a>:</h4>
<p>Now I have a file <code>hpdefs.lean</code> and a file <code>lesson1.lean</code>, this second one with some lemmas that seem to compile (I'm still using CoCalc for this). I want to start a new file, <code>lesson2.lean</code>. I type this into the new file:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="bp">.</span><span class="n">lesson1</span>

<span class="kn">open</span> <span class="n">hilbertplane</span>

<span class="kn">variables</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">HilbertPlane</span><span class="o">}</span>
</pre></div>


<p>and it already complains that "imported file '/home/user/leanprojects/test/src/lesson1.lean' uses sorry" (which I can't see in that file). So what does that error message mean actually?</p>

<a name="186295681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186295681" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186295681">Patrick Massot (Jan 22 2020 at 15:18)</a>:</h4>
<p>The sorry may be in a file imported by lesson1</p>

<a name="186295930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186295930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186295930">Marc Masdeu (Jan 22 2020 at 15:20)</a>:</h4>
<p>lesson1 only imports hpdefs, which has no sorry's either...</p>

<a name="186296511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186296511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186296511">Marc Masdeu (Jan 22 2020 at 15:26)</a>:</h4>
<p>It turns out that cocalc had issues with some sort of caching. I restarted everything and the complaint went away... Thanks <span class="user-mention" data-user-id="110031">@Patrick Massot</span> !</p>

<a name="186371280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186371280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186371280">Marc Masdeu (Jan 23 2020 at 09:29)</a>:</h4>
<p>This question should be quick: I have the state:</p>
<div class="codehilite"><pre><span></span><span class="err">Ω</span> <span class="o">:</span> <span class="n">HilbertPlane</span><span class="o">,</span>
<span class="n">A</span> <span class="o">:</span> <span class="n">HilbertPlane</span><span class="bp">.</span><span class="n">Point</span>
<span class="err">⊢</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">HilbertPlane</span><span class="bp">.</span><span class="n">Point</span> <span class="bp">|</span> <span class="n">A</span> <span class="bp">*</span> <span class="n">C</span><span class="bp">*</span><span class="n">A</span><span class="o">}</span> <span class="bp">=</span> <span class="err">∅</span>
</pre></div>


<p>This is a trivial statement, directly following from the axiom:</p>
<div class="codehilite"><pre><span></span>    <span class="o">(</span><span class="n">B12</span> <span class="o">(</span><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Point</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">A</span> <span class="bp">*</span> <span class="n">B</span> <span class="bp">*</span> <span class="n">C</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">A</span> <span class="bp">≠</span> <span class="n">B</span> <span class="bp">∧</span> <span class="n">A</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">B</span> <span class="bp">≠</span> <span class="n">C</span> <span class="bp">∧</span> <span class="n">collinear</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span><span class="o">))</span>
</pre></div>


<p>but I don't see how to do it in Lean. I would like to say to Lean:<br>
1) Let C be a point in the left set.<br>
2) By B12 A B A we have A \neq A, contradiction.</p>

<a name="186371793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186371793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186371793">Patrick Massot (Jan 23 2020 at 09:36)</a>:</h4>
<p>A generic start would be <code>ext C, suffices : ¬ A*C*A, by simpa,</code>.</p>

<a name="186371934"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186371934" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186371934">Marc Masdeu (Jan 23 2020 at 09:39)</a>:</h4>
<p>The ext C is what I didn't know...</p>

<a name="186372997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/formalizing%20Hilbert%27s%20axioms%20for%20plane%20geometry/near/186372997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/57307formalizingHilbertsaxiomsforplanegeometry.html#186372997">Marc Masdeu (Jan 23 2020 at 09:56)</a>:</h4>
<p>I then intro'd h : A * C * A<br>
I want to apply B12's second inequality (one of the 4 and statements). I try <code>have g : HilbertPlane.B12 A C A,</code> but it doesn't work.</p>


{% endraw %}

{% include archive_update.html %}