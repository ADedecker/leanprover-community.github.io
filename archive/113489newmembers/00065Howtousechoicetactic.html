---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/00065Howtousechoicetactic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/00065Howtousechoicetactic.html">How to use choice tactic?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="181176749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20choice%20tactic%3F/near/181176749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/00065Howtousechoicetactic.html#181176749">Li Yao'an (Nov 20 2019 at 03:20)</a>:</h4>
<p>When we have an existential statement, we can use choice to construct a witness w. However, while w retains the correct type, the fact that it is a witness to a particular proposition is sometimes (seemingly) lost.  Here is an example:</p>
<div class="codehilite"><pre><span></span>import tactic
open function
noncomputable theory

def inv {α β} (f : α → β) (h : surjective f) : β → α :=
begin
    intro b, rw [surjective] at h,
    choose a h using h b, exact a
end

theorem should_be_trivial {α β} (f : α → β) (h : surjective f) : let f&#39; := inv f h in ∀ b : β, f (f&#39; b) = b :=
begin
    simp, intro b, rw inv, admit
end
</pre></div>


<p>Rewriting inv gives some scary-looking term, and simp-ing gives "f (classical.some _) = b", when it seems that the proposition that choice was made on has been lost.</p>
<p>What is a good way of recovering the proposition in an existential statement? How could this proof be fixed? (A proof ending with "assumption" would be extra nice, to show how the proposition can be added as a hypothesis)</p>

<a name="181179817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20choice%20tactic%3F/near/181179817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/00065Howtousechoicetactic.html#181179817">Bryan Gin-ge Chen (Nov 20 2019 at 04:53)</a>:</h4>
<p>The key is <code>classical.some_spec</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">function</span>
<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">def</span> <span class="n">inv</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intro</span> <span class="n">b</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">surjective</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">choose</span> <span class="n">a</span> <span class="n">h</span> <span class="kn">using</span> <span class="n">h</span> <span class="n">b</span><span class="o">,</span> <span class="n">exact</span> <span class="n">a</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">should_be_trivial</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="k">let</span> <span class="n">f&#39;</span> <span class="o">:=</span> <span class="n">inv</span> <span class="n">f</span> <span class="n">h</span> <span class="k">in</span> <span class="bp">∀</span> <span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">f&#39;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intros</span> <span class="n">f&#39;</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">h</span> <span class="n">b</span><span class="o">),</span>
<span class="kn">end</span>

<span class="c1">-- n.b. using tactics in defs is discouraged (because it leads to scary-looking terms)</span>
<span class="n">def</span> <span class="n">inv&#39;</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some</span> <span class="o">(</span><span class="n">h</span> <span class="n">b</span><span class="o">)</span>
</pre></div>

<a name="181180803"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/How%20to%20use%20choice%20tactic%3F/near/181180803" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/00065Howtousechoicetactic.html#181180803">Bryan Gin-ge Chen (Nov 20 2019 at 05:22)</a>:</h4>
<p><code>foo_spec</code> seems to be the conventional name for the theorem that provides the defining property of <code>foo</code>, e.g. <code>nat.find_greatest_spec</code> (for <code>nat.find_greatest</code>), <code>finset.choose_spec</code> (for <code>finset.choose</code>), etc.</p>


{% endraw %}

{% include archive_update.html %}