---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/45316exprfieldsand.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html">expr: fields and @</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="163597173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/163597173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#163597173">Fabian Glöckle (Apr 17 2019 at 20:17)</a>:</h4>
<p>Hello everyone, in <code>meta</code> I am trying to build an <code>expr</code> for <code>@has_add.add _ _ _ _</code>. How are class/structure fields and the <code>@</code>-notation implemented? When I ask <code>expr.app_fn</code> about <code>to_expr ``(@has_add.add)</code>, I get <code>has_add.add</code>. (?)</p>

<a name="163599659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/163599659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#163599659">Fabian Glöckle (Apr 17 2019 at 20:50)</a>:</h4>
<p>To be more precise, I want the <code>has_add.add</code> part to be dynamic (generated from a string to also support <code>has_mul.mul</code> etc.); the <code>@</code>is always needed.</p>

<a name="163605271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/163605271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#163605271">Fabian Glöckle (Apr 17 2019 at 22:08)</a>:</h4>
<p>Is the <code>@</code> an <code>annotation</code>? My tests indicate no...</p>
<div class="codehilite"><pre><span></span><span class="n">meta</span> <span class="n">def</span> <span class="n">diagnose</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">option</span> <span class="o">(</span><span class="n">name</span> <span class="bp">×</span> <span class="n">expr</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">exp</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">@</span><span class="n">has_add</span><span class="bp">.</span><span class="n">add</span><span class="o">),</span>
   <span class="n">res</span> <span class="err">←</span> <span class="n">pure</span> <span class="err">$</span> <span class="n">expr</span><span class="bp">.</span><span class="n">is_annotation</span> <span class="n">exp</span><span class="o">,</span>
   <span class="n">type</span> <span class="err">←</span> <span class="n">infer_type</span> <span class="n">exp</span><span class="o">,</span>
   <span class="n">trace</span> <span class="n">type</span><span class="o">,</span>
   <span class="n">trace</span> <span class="n">res</span><span class="o">,</span>
   <span class="n">return</span> <span class="n">res</span>
</pre></div>


<p>--&gt; trace output:</p>
<div class="codehilite"><pre><span></span><span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="err">?</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="n">none</span>
</pre></div>


<p>without the <code>@</code>:</p>
<div class="codehilite"><pre><span></span><span class="err">?</span><span class="n">m_1</span> <span class="bp">→</span> <span class="err">?</span><span class="n">m_1</span> <span class="bp">→</span> <span class="err">?</span><span class="n">m_1</span>
<span class="n">none</span>
</pre></div>

<a name="163612370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/163612370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#163612370">Simon Hudon (Apr 18 2019 at 00:13)</a>:</h4>
<p><code>@</code> is used by the elaborator. It is only present pre-terms (i.e. <code>pexpr</code>). Consider:</p>
<div class="codehilite"><pre><span></span><span class="n">meta</span> <span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="k">let</span> <span class="n">e</span> <span class="o">:=</span> <span class="bp">``</span><span class="o">(</span><span class="bp">@</span><span class="n">has_add</span><span class="bp">.</span><span class="n">add</span> <span class="o">),</span>
   <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">e</span><span class="bp">.</span><span class="n">to_raw_fmt</span><span class="o">,</span>
   <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">e</span><span class="bp">.</span><span class="n">is_annotation</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">e</span> <span class="o">:=</span> <span class="bp">``</span><span class="o">(</span><span class="n">has_add</span><span class="bp">.</span><span class="n">add</span> <span class="o">),</span>
   <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">e</span><span class="bp">.</span><span class="n">to_raw_fmt</span><span class="o">,</span>
   <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="n">e</span><span class="bp">.</span><span class="n">is_annotation</span>

<span class="n">run_cmd</span> <span class="n">foo</span>
</pre></div>

<a name="163612381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/163612381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#163612381">Simon Hudon (Apr 18 2019 at 00:13)</a>:</h4>
<p>It prints:</p>
<div class="codehilite"><pre><span></span>[macro annotation (const has_add.add [])]
(some (@, has_add.add))
(const has_add.add [])
none
</pre></div>

<a name="163612432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/163612432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#163612432">Simon Hudon (Apr 18 2019 at 00:14)</a>:</h4>
<p><code> ``(@has_add.add)</code> is a pre-term but <code>to_expr</code> makes it into a term</p>

<a name="163615437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/163615437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#163615437">Keeley Hoek (Apr 18 2019 at 01:25)</a>:</h4>
<p>I'm not sure what you want it to "behave like @ for", but be aware of <code>tactic.mk_mapp</code> which lets you provided all of the (even implicit) arguments implicitly or explicitly.</p>

<a name="163940245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/163940245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#163940245">Fabian Glöckle (Apr 22 2019 at 21:31)</a>:</h4>
<p>Thanks!<br>
<span class="user-mention" data-user-id="110026">@Simon Hudon</span> Can I add this annotation to a <code>pexpr</code>? No, because <code>meta constant macro_def : Type</code> belongs to the kernel?<br>
<span class="user-mention" data-user-id="110111">@Keeley Hoek</span> Can I build such an <code>app</code> which involves <code>var n</code> terms I want to bind later on? (I got <code>failed to infer type, unexpected bound variable occurrence</code>).</p>

<a name="163940444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/163940444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#163940444">Fabian Glöckle (Apr 22 2019 at 21:33)</a>:</h4>
<p>My goal is to add a declaration like</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">has_add_compatible</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">i₁</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">i₂</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">),</span>
  <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span><span class="o">},</span> <span class="n">f</span> <span class="o">(</span><span class="bp">@</span><span class="n">has_add</span><span class="bp">.</span><span class="n">add</span> <span class="n">α</span> <span class="n">i₁</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">@</span><span class="n">has_add</span><span class="bp">.</span><span class="n">add</span> <span class="n">β</span> <span class="n">i₂</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">y</span><span class="o">)</span>
</pre></div>


<p>to the environment with <code>has_add.add</code>being a template parameter which could also be set to <code>has_mul.mul</code>.</p>

<a name="163997876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/163997876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#163997876">Fabian Glöckle (Apr 23 2019 at 15:03)</a>:</h4>
<p>Do my questions make sense? Can I further elaborate on anything? Any help is appreciated <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>

<a name="164000124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/164000124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#164000124">Simon Hudon (Apr 23 2019 at 15:28)</a>:</h4>
<p>Hey! Sorry I forgot to answer</p>

<a name="164000326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/164000326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#164000326">Simon Hudon (Apr 23 2019 at 15:30)</a>:</h4>
<p>You don't need to generate <code>@</code> to create that definition. The following has the same effect:</p>
<div class="codehilite"><pre><span></span><span class="n">do</span> <span class="n">add</span> <span class="bp">&lt;-</span> <span class="n">mk_const</span> <span class="n">has_add</span><span class="bp">.</span><span class="n">add</span><span class="o">,</span>
   <span class="n">return</span> <span class="err">$</span> <span class="n">add</span> <span class="n">α</span> <span class="n">i₁</span> <span class="n">x</span> <span class="n">y</span>
</pre></div>

<a name="164000373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/164000373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#164000373">Simon Hudon (Apr 23 2019 at 15:31)</a>:</h4>
<p>or more simply: <code>mk_mapp `has_add.add [α,i₁,x,y]</code></p>

<a name="164000645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/164000645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#164000645">Simon Hudon (Apr 23 2019 at 15:34)</a>:</h4>
<p>While in writing an expression like <code>@has_add.add α i₁ x y</code> you need the added tool of <code>@</code> to specify implicit arguments, in building <code>expr</code> trees, you have to work harder if you want to omit an implicit argument. That's because <code>app f x</code> means the same whether the type of the expression <code>f</code> is <code>Π x : t, t'</code> or <code>Π {x : t}, t'</code>.</p>

<a name="164000846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/164000846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#164000846">Simon Hudon (Apr 23 2019 at 15:37)</a>:</h4>
<p>If you want to omit the first implicit argument, you have to first discover that it is indeed an implicit argument, then, you have to create a meta variable <code>v</code> of the right type and feed it to <code>f</code>: <code>app f v</code>. Then you have "omitted" the first arguments: you're relying on unification to figure out what it is</p>

<a name="164000975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/164000975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#164000975">Simon Hudon (Apr 23 2019 at 15:38)</a>:</h4>
<p>You can also use <code>tactic.mk_app</code> which behaves very similarly to what I described</p>

<a name="164014929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/164014929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#164014929">Fabian Glöckle (Apr 23 2019 at 18:16)</a>:</h4>
<p>Great, thanks, that clears up my questions about how <code>app</code> works for <code>expr</code>and <code>pexpr</code>!</p>

<a name="164015074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/164015074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#164015074">Fabian Glöckle (Apr 23 2019 at 18:18)</a>:</h4>
<p>I was trying to mix this with reflected code like in the following, is that possible?</p>
<div class="codehilite"><pre><span></span><span class="n">meta</span> <span class="n">def</span> <span class="n">add_compatible_def</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">command</span> <span class="o">:=</span>
<span class="n">do</span> <span class="k">let</span> <span class="n">has_x_name</span> <span class="o">:=</span> <span class="n">name</span><span class="bp">.</span><span class="n">mk_string</span> <span class="o">(</span><span class="n">string</span><span class="bp">.</span><span class="n">append</span> <span class="s2">&quot;has_&quot;</span> <span class="n">x</span><span class="o">)</span> <span class="n">name</span><span class="bp">.</span><span class="n">anonymous</span><span class="o">,</span>
   <span class="k">let</span> <span class="n">has_x_x_name</span> <span class="o">:=</span> <span class="n">name</span><span class="bp">.</span><span class="n">mk_string</span> <span class="n">x</span> <span class="n">has_x_name</span><span class="o">,</span>
   <span class="n">has_x</span> <span class="err">←</span> <span class="n">mk_const</span> <span class="n">has_x_name</span><span class="o">,</span>
   <span class="n">has_x_x</span> <span class="err">←</span> <span class="n">mk_const</span> <span class="n">has_x_x_name</span><span class="o">,</span>
   <span class="n">decl_type</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">Π</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="err">%%</span><span class="n">has_x</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="err">%%</span><span class="n">has_x</span> <span class="n">β</span><span class="o">],</span> <span class="o">(</span><span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">),</span>
   <span class="n">decl_body</span> <span class="err">←</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">i₁</span> <span class="o">:</span> <span class="err">%%</span><span class="n">has_x</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">i₂</span> <span class="o">:</span> <span class="err">%%</span><span class="n">has_x</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">),</span>
                          <span class="bp">∀</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">},</span> <span class="n">f</span> <span class="o">(</span><span class="err">%%</span><span class="n">has_x_x</span> <span class="n">α</span> <span class="n">i₁</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="err">%%</span><span class="n">has_x_x</span> <span class="n">β</span> <span class="n">i₂</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">y</span><span class="o">)),</span>
   <span class="n">decl</span> <span class="err">←</span> <span class="n">pure</span> <span class="err">$</span> <span class="n">mk_definition</span> <span class="bp">`</span><span class="n">compatible</span> <span class="o">[</span><span class="bp">`</span><span class="n">u</span><span class="o">,</span> <span class="bp">`</span><span class="n">v</span><span class="o">]</span> <span class="n">decl_type</span> <span class="n">decl_body</span><span class="o">,</span>
   <span class="n">add_decl</span> <span class="n">decl</span>
</pre></div>

<a name="164015166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/164015166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#164015166">Fabian Glöckle (Apr 23 2019 at 18:19)</a>:</h4>
<p>Currently the reflected code does not accept the arguments this way:</p>
<div class="codehilite"><pre><span></span><span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
<span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="n">i₁</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">α</span><span class="o">,</span>
<span class="n">i₂</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">β</span><span class="o">,</span>
<span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">,</span>
<span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span>
<span class="err">⊢</span> <span class="n">has_add</span> <span class="kt">Type</span>
<span class="n">Additional</span> <span class="n">information</span><span class="o">:</span>
<span class="kn">context</span><span class="o">:</span> <span class="n">switched</span> <span class="n">to</span> <span class="n">simple</span> <span class="n">application</span> <span class="n">elaboration</span> <span class="n">procedure</span> <span class="n">because</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">use</span> <span class="n">expected</span> <span class="n">type</span> <span class="n">to</span> <span class="n">elaborate</span> <span class="n">it</span><span class="o">,</span> <span class="n">error</span> <span class="n">message</span>
  <span class="n">too</span> <span class="n">many</span> <span class="n">arguments</span>
</pre></div>

<a name="164015854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/expr%3A%20fields%20and%20%40/near/164015854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/45316exprfieldsand.html#164015854">Simon Hudon (Apr 23 2019 at 18:27)</a>:</h4>
<p>Instead of using <code>Π</code> and <code>λ</code> in your quasiquotes, use <code>mk_local'</code> to create variables like <code>α</code> and <code>β</code> and the instances, then you use <code>to_expr</code> and quasiquotes to create <code> ``((%%α → %%β) → Prop)</code>and you use <code>pis</code> to create the pis and similarly with <code>lambdas</code> to create the lambdas.</p>


{% endraw %}
