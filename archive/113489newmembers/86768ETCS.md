---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/86768ETCS.html
---

## Stream: [new members](https://leanprover-community.github.io/archive/113489newmembers/index.html)
### Topic: [ETCS](https://leanprover-community.github.io/archive/113489newmembers/86768ETCS.html)

---

<base href="https://leanprover.zulipchat.com">
{% raw %}
#### [ David Michael Roberts (Oct 10 2018 at 07:32)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520140):
<p>I might have a crack at showing that sets form a category that is a model of ETCS <a href="https://ncatlab.org/nlab/show/ETCS" target="_blank" title="https://ncatlab.org/nlab/show/ETCS">https://ncatlab.org/nlab/show/ETCS</a></p>

#### [ David Michael Roberts (Oct 10 2018 at 07:33)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520152):
<p>Or at least build a model of ETCS in Lean. Not sure quite what the sets of Lean <em>are</em> yet.</p>

#### [ David Michael Roberts (Oct 10 2018 at 07:35)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520216):
<p>I mean, I notice that in <code>set_theory.zfc</code> presets are used, but I can't tell if these are the same as Bishop-style presets (<a href="https://ncatlab.org/nlab/show/preset" target="_blank" title="https://ncatlab.org/nlab/show/preset">https://ncatlab.org/nlab/show/preset</a>) and then sets are what are sometimes called setoids (<a href="https://ncatlab.org/nlab/show/equivalence+relation#setoids" target="_blank" title="https://ncatlab.org/nlab/show/equivalence+relation#setoids">https://ncatlab.org/nlab/show/equivalence+relation#setoids</a>)</p>

#### [ Simon Hudon (Oct 10 2018 at 07:36)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520260):
<p>There are multiple formalizations of sets in Lean, depending on your needs. <code>set_theory.zfc</code> is if you're interested in (untyped) ZFC set theory, <code>data.set</code> formalize sets whose elements have a certain type as predicates on that type and <code>data.finset</code> formalizes finite sets whose elements also have a given type.</p>

#### [ Simon Hudon (Oct 10 2018 at 07:37)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520277):
<p>In <code>set_theory.zfc</code> there is <code>pSet</code> but there's also <code>Set</code> which might be more useful</p>

#### [ Mario Carneiro (Oct 10 2018 at 07:42)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520450):
<p>I think that <code>pSet</code> is indeed a preset in the nLab sense</p>

#### [ David Michael Roberts (Oct 10 2018 at 07:42)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520457):
<p>Yes, I could show that ZFC-sets give a model of ETCS, but it would be more interesting to show that one could build the category of "sets" directly, without knowing a well-founded \in-tree structure on them.</p>

#### [ Mario Carneiro (Oct 10 2018 at 07:43)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520466):
<p>although of course there is an equality relation on <code>pSet</code>, since it is a type; this equality is too fine for ZFC and <code>Set</code> is a quotient of this by set extensionality</p>

#### [ David Michael Roberts (Oct 10 2018 at 07:43)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520467):
<p>So I guess: is there a way to talk about sets native to Lean, as there is in HoTT, for instance? (where there is the type of hSets)</p>

#### [ Mario Carneiro (Oct 10 2018 at 07:43)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520468):
<p>hSet = Type in lean</p>

#### [ David Michael Roberts (Oct 10 2018 at 07:43)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520469):
<p>Oh, cool!</p>

#### [ Mario Carneiro (Oct 10 2018 at 07:43)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520472):
<p>all types are "sets" in the HoTT sense, because of proof irrelevance</p>

#### [ David Michael Roberts (Oct 10 2018 at 07:44)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520526):
<p>So, in principle, one could try to show that Type is (the objects of) a category—perhaps this is done already—and then show it is a term of type <code>ETCS</code>, once that is defined.</p>

#### [ Mario Carneiro (Oct 10 2018 at 07:45)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520544):
<p>yes, that should not be difficult</p>

#### [ Simon Hudon (Oct 10 2018 at 07:45)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520546):
<p>There is a category of types in <code>category_theory.types</code></p>

#### [ Scott Morrison (Oct 10 2018 at 07:45)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520547):
<p>The category structure on <code>Type</code> is at <a href="https://github.com/leanprover/mathlib/blob/master/category_theory/types.lean" target="_blank" title="https://github.com/leanprover/mathlib/blob/master/category_theory/types.lean">https://github.com/leanprover/mathlib/blob/master/category_theory/types.lean</a></p>

#### [ Mario Carneiro (Oct 10 2018 at 07:45)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520549):
<p>also ^ that</p>

#### [ Simon Hudon (Oct 10 2018 at 07:46)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520589):
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> not fast enough!</p>

#### [ Scott Morrison (Oct 10 2018 at 07:46)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520591):
<p>:-)</p>

#### [ Scott Morrison (Oct 10 2018 at 07:46)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520593):
<p>I was running a longer race. :-)</p>

#### [ Simon Hudon (Oct 10 2018 at 07:47)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520607):
<p>Now you understand why some of my code snippets have small type errors in them :P</p>

#### [ David Michael Roberts (Oct 10 2018 at 07:50)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520725):
<p>OK, cool, thanks :-)</p>

#### [ Mario Carneiro (Oct 10 2018 at 07:50)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520730):
<p>What's more, I think there is a model of ETCS in <code>Type</code></p>

#### [ Mario Carneiro (Oct 10 2018 at 07:51)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520738):
<p>i.e. a suitably large inductive type can give you all the types you need to interpret the operations of ETCS</p>

#### [ David Michael Roberts (Oct 10 2018 at 07:51)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520740):
<p>As an aside: is there a handy chart that details the various unicode autocompletion shortcuts? and/or LaTeX : autocompl shortcut table?</p>

#### [ Mario Carneiro (Oct 10 2018 at 07:51)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520744):
<p>If you want the full list you should look at the vscode extension file</p>

#### [ Mario Carneiro (Oct 10 2018 at 07:52)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520791):
<p>but it is quite large and likely auto-populated with a bunch of things from LaTeX</p>

#### [ Bryan Gin-ge Chen (Oct 10 2018 at 07:52)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520794):
<p>You can also paste in symbols from <a href="https://github.com/EdAyers/mathlib/blob/doc/docs/unicode.md" target="_blank" title="https://github.com/EdAyers/mathlib/blob/doc/docs/unicode.md">this page</a> and hover over them to see what the completion is.</p>

#### [ David Michael Roberts (Oct 10 2018 at 07:52)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520796):
<p>Which lives...? (thanks, btw)</p>

#### [ David Michael Roberts (Oct 10 2018 at 07:52)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520801):
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>  cool, thanks</p>

#### [ Mario Carneiro (Oct 10 2018 at 07:52)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520810):
<p><a href="https://github.com/leanprover/vscode-lean/blob/master/translations.json" target="_blank" title="https://github.com/leanprover/vscode-lean/blob/master/translations.json">https://github.com/leanprover/vscode-lean/blob/master/translations.json</a></p>

#### [ Bryan Gin-ge Chen (Oct 10 2018 at 07:52)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520811):
<p><a href="https://github.com/leanprover/vscode-lean/blob/master/translations.json" target="_blank" title="https://github.com/leanprover/vscode-lean/blob/master/translations.json">Here's</a> the vscode file</p>

#### [ David Michael Roberts (Oct 10 2018 at 07:54)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520872):
<p><span class="emoji emoji-1f44d" title="+1">:+1:</span></p>

#### [ Mario Carneiro (Oct 10 2018 at 07:55)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135520877):
<p>The maintainer of the extension (Gabriel Ebner) is quite receptive to adding new symbols if you spot one in high unicode that you like</p>

#### [ Jesse Michael Han (Oct 13 2018 at 06:14)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135716573):
<p><span class="user-mention" data-user-id="130272">@David Michael Roberts</span> Nice seeing you here!</p>
<p><code>Type</code> is indeed a model of ETCS; function extensionality should correspond to well-pointedness,  working in <code>classical</code>, we have choice, <code>Prop</code> is the subobject classifier, and  the NNO is <code>nat</code>.</p>

#### [ David Michael Roberts (Oct 13 2018 at 06:22)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135716828):
<p>Sure, but is it _proved_ to be a model of ETCS? And, if I use the constructive fragment, do I get a model of the constructive version (a la I guess Mike Shulman's "material and structural set theories" paper)</p>

#### [ David Michael Roberts (Oct 13 2018 at 06:22)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135716833):
<p>Oh, and thanks, <span class="user-mention" data-user-id="116045">@Jesse Michael Han</span>  :-)</p>

#### [ David Michael Roberts (Oct 13 2018 at 06:23)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135716853):
<p>Also, one could go the whole hog and show without using even <code>Prop</code> that Type is some kind of predicative topos...</p>

#### [ David Michael Roberts (Oct 13 2018 at 06:24)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135716897):
<p>That said, this is just to get me wet behind the ears and play around with stuff that I care about.</p>

#### [ Mario Carneiro (Oct 13 2018 at 06:24)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135716898):
<p>Do you know what that should mean?</p>

#### [ David Michael Roberts (Oct 13 2018 at 06:26)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135716988):
<p>There is a constructive version of well-pointedness, that doesn't force Booleanness. just that "a global element of the subobject classifier is false if and only if it is not true." (from <a href="https://ncatlab.org/nlab/show/well-pointed+topos" target="_blank" title="https://ncatlab.org/nlab/show/well-pointed+topos">https://ncatlab.org/nlab/show/well-pointed+topos</a>)</p>

#### [ David Michael Roberts (Oct 13 2018 at 06:27)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135717000):
<p>And as far as predicative stuff, one could show directly that Type is a Pi-W-pretopos satisfying some version of WISC (??? not sure about that one), following eg Benno van den Berg</p>

#### [ David Michael Roberts (Oct 13 2018 at 06:29)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135717053):
<p>For instance "the category of Bishop sets in Martin-Löf type theory is a predicative topos" (<a href="https://ncatlab.org/nlab/show/predicative+topos" target="_blank" title="https://ncatlab.org/nlab/show/predicative+topos">https://ncatlab.org/nlab/show/predicative+topos</a>)</p>

#### [ Mario Carneiro (Oct 13 2018 at 07:12)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135718340):
<p>I'm not sure about WISC, seems like any version of the axiom of choice is likely to be false without <code>choice</code>, but I checked the proof that epis are surjective in lean:</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>
<span class="kn">theorem</span> <span class="n">epi</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>
  <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="n">h</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">),</span> <span class="n">g</span> <span class="err">∘</span> <span class="n">f</span> <span class="bp">=</span> <span class="n">h</span> <span class="err">∘</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">g</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">ulift</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">⟨∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">h</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">ulift</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">true</span><span class="bp">⟩</span> <span class="k">in</span>
<span class="k">have</span> <span class="n">g</span> <span class="bp">=</span> <span class="n">h</span><span class="o">,</span> <span class="k">from</span> <span class="n">H</span> <span class="bp">_</span> <span class="n">g</span> <span class="n">h</span> <span class="o">(</span><span class="n">funext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">congr_arg</span> <span class="n">ulift</span><span class="bp">.</span><span class="n">up</span> <span class="err">$</span> <span class="n">eq_true_intro</span> <span class="err">$</span> <span class="k">by</span> <span class="n">exact</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">),</span>
<span class="k">by</span> <span class="n">injection</span> <span class="n">congr_fun</span> <span class="n">this</span> <span class="n">y</span><span class="bp">;</span> <span class="n">exact</span> <span class="n">cast</span> <span class="n">eq_true</span> <span class="n">h_1</span>
</pre></div>


<p>and it looks like you need <code>Prop</code> and <code>propext</code> essentially (you can't prove it using <code>trunc</code>, and you certainly can't prove it "constructively" i.e. with a sigma)</p>

#### [ Mario Carneiro (Oct 13 2018 at 07:24)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135718618):
<p>Actually I find this to be an interesting example of a "nonconstructive" constructive exists, in the sense that you can't upgrade the exists to a data type even though the proof does not use choice.</p>

#### [ Mario Carneiro (Oct 13 2018 at 08:02)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135719664):
<p>I am almost certain that WISC is not provable, although I don't think there is an easy proof of this. I don't think Asaf Karagila's proof <a href="https://arxiv.org/pdf/1212.4396.pdf" target="_blank" title="https://arxiv.org/pdf/1212.4396.pdf">https://arxiv.org/pdf/1212.4396.pdf</a> is much affected by the presence of inaccessible cardinals, so it should be independent of lean as well by simulation in ZFC + omega inaccessibles (below the first inaccessible because we are working in <code>Type</code>).</p>

#### [ David Michael Roberts (Oct 13 2018 at 09:11)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135721449):
<p>Well, I did prove (on paper) that WISC isn't provable from the axioms of an elementary topos, by constructing a topos where it fails :-)</p>

#### [ Mario Carneiro (Oct 13 2018 at 09:13)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135721505):
<p>I suppose that's also an option... I guess lean has a bit more structure though, so maybe you have to do that with pi-W-toposes? Is that a thing?</p>

#### [ Jesse Michael Han (Oct 13 2018 at 21:19)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135743749):
<p><span class="user-mention" data-user-id="130272">@David Michael Roberts</span> I'm not sure if</p>
<blockquote>
<p>a global element of the subobject classifier is false if and only if it is not true</p>
</blockquote>
<p>holds without invoking <code>classical</code>. Without being able to take a filterquotient of <code>Prop</code>, it's just a massive Heyting algebra, and even with excluded middle, if Lean knows that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊢</mo><mi>p</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>p</mi></mrow><annotation encoding="application/x-tex"> \vdash p \vee \neg p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mrel">⊢</span><span class="mord mathit">p</span><span class="mbin">∨</span><span class="mord mathrm">¬</span><span class="mord mathit">p</span></span></span></span>, it does not necessarily decide if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">p</span></span></span></span> is true or false.</p>
<p>Lean is also not quite a topos over <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68611em;"></span><span class="strut bottom" style="height:0.68611em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbf">S</span><span class="mord mathbf">e</span><span class="mord mathbf">t</span></span></span></span></span>, for it lacks externally indexed colimits (while <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathrm">Σ</span></span></span></span>-types and quotient types give all internally indexed colimits).</p>

#### [ Mario Carneiro (Oct 14 2018 at 01:40)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135752172):
<p><span class="user-mention" data-user-id="116045">@Jesse Michael Han</span> Could you unpack what that statement about the subobject classifier should mean? I assume <code>Prop</code> is a subobject classifier for <code>Type</code> even without <code>choice</code> (but assuming <code>propext</code>), because every monomorphism in <code>Type</code> is an injection, and so it factors through the subtype on the range.</p>
<p>Actually, I see another problem: If f : A -&gt; X is a monomorphism and g : X -&gt; Prop is the function <code>g x = \ex a, f x = a</code>, then we want a pullback square with the <code>true : unit -&gt; Prop</code> function. But the subtype is a pullback, and A is not constructively isomorphic to the subtype, so I don't think it holds. That is, <code>Prop</code> isn't even a subobject classifier.</p>

#### [ Jesse Michael Han (Oct 14 2018 at 02:56)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135754838):
<p>That's interesting. (I assume you mean <code>g x = \ex a, f a = x</code>.) Why is the image of an injection not constructively isomorphic to its domain?</p>

#### [ Mario Carneiro (Oct 14 2018 at 03:16)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135755636):
<p>There are a few ways to look at it. My favorite is to think in terms of what is "data" vs "erased" stuff, which corresponds to stuff that the computer could actually execute or manipulate. If you have a function f : A -&gt; X where A and X are both data types, then f is a real <em>function</em>, something that transforms one kind of representation into another. There is no guarantee that this transformation is invertible, and in particular assuming that f is injective does not supply you with such an inverse. (This is why <code>equiv</code> contains an explicit inverse function, and <code>bijection</code> is a weaker notion.) So defining a function from A to {x // x \in range f} is easy by restricting the codomain of f, but you don't have enough data for the converse function.</p>
<p>In set theory you would use the exists assumption to give the value, but since this is a Prop, it is "not data" and can't be turned into data. If you use a Type-valued equivalent, like <code>trunc {a // f a = x}</code>, then it would be constructively bijective, but in this case I'm not sure it's a pullback.</p>

#### [ Jesse Michael Han (Oct 14 2018 at 03:25)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135755884):
<p>If that's the case, when maybe one does need 'classical' to show that <code>Prop</code> (which is then <code>bool</code>) is a subobject classifier after all.</p>
<p>Could you explain why couldn't we do something like, take the collection of pairs <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(a, f(a))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> and flip the pairs to get an inverse?</p>

#### [ Mario Carneiro (Oct 14 2018 at 03:26)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135755947):
<p>Ah, here's another way to show choiceless <code>Type</code> is not a topos:</p>
<blockquote>
<p>Corollary 4.2. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold">C</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68611em;"></span><span class="strut bottom" style="height:0.68611em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbf">C</span></span></span></span></span> is balanced, i.e., a morphism in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold">C</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68611em;"></span><span class="strut bottom" style="height:0.68611em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbf">C</span></span></span></span></span> is an isomorphism iff it is both monic and epic. (<a href="https://ncatlab.org/nlab/show/subobject+classifier" target="_blank" title="https://ncatlab.org/nlab/show/subobject+classifier">https://ncatlab.org/nlab/show/subobject+classifier</a>)</p>
</blockquote>
<p>This is not true in <code>Type</code>, since as I said monic means <code>injective</code> and epic means <code>surjective</code>, and the conjunction of these is <code>bijective</code> which is not the same as <code>equiv</code> which is isomorphism.</p>

#### [ Mario Carneiro (Oct 14 2018 at 03:27)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135755957):
<p>Actually unique choice is enough to prove that a bijection is an equiv</p>

#### [ Mario Carneiro (Oct 14 2018 at 03:27)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135755959):
<p>so you can still get this property without collapsing Prop = bool</p>

#### [ Mario Carneiro (Oct 14 2018 at 03:29)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756014):
<blockquote>
<p>Could you explain why couldn't we do something like, take the collection of pairs <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(a, f(a))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> and flip the pairs to get an inverse?</p>
</blockquote>
<p>because that's not how functions are defined in type theory. In type theory every function is given by a term that has a free variable for the argument</p>

#### [ Mario Carneiro (Oct 14 2018 at 03:29)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756017):
<p>That is, "functions" and "functional relations" are not the same</p>

#### [ Mario Carneiro (Oct 14 2018 at 03:30)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756071):
<p>a definition like that one would give a functional relation, but proving that a functional relation induces a function requires unique choice</p>

#### [ Mario Carneiro (Oct 14 2018 at 03:31)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756084):
<p>By the way, this kind of thing comes up even in "real math". For example, the derivative of a function is a functional relation, not a function</p>

#### [ Mario Carneiro (Oct 14 2018 at 03:32)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756136):
<p>You can of course use choice to upgrade it to a function but it's not quite natural and lean will make it feel a little awkward</p>

#### [ Jesse Michael Han (Oct 14 2018 at 03:34)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756215):
<p>Right, I see.</p>
<blockquote>
<p>Ah, here's another way to show choiceless <code>Type</code> is not a topos:</p>
<blockquote>
<p>Corollary 4.2. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold">C</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68611em;"></span><span class="strut bottom" style="height:0.68611em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbf">C</span></span></span></span></span> is balanced, i.e., a morphism in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold">C</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68611em;"></span><span class="strut bottom" style="height:0.68611em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathbf">C</span></span></span></span></span> is an isomorphism iff it is both monic and epic. (<a href="https://ncatlab.org/nlab/show/subobject+classifier" target="_blank" title="https://ncatlab.org/nlab/show/subobject+classifier">https://ncatlab.org/nlab/show/subobject+classifier</a>)</p>
</blockquote>
<p>This is not true in <code>Type</code>, since as I said monic means <code>injective</code> and epic means <code>surjective</code>, and the conjunction of these is <code>bijective</code> which is not the same as <code>equiv</code> which is isomorphism.</p>
</blockquote>
<p>This is what one usually uses to show that the image of a mono is isomorphic to its domain, so that makes sense.</p>

#### [ David Michael Roberts (Oct 14 2018 at 03:51)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756739):
<p>Well, that was the informal explanation. The real definition is Def 4.1 in Shulman's <a href="https://arxiv.org/pdf/1808.05204.pdf" target="_blank" title="https://arxiv.org/pdf/1808.05204.pdf">https://arxiv.org/pdf/1808.05204.pdf</a> and is stated in the context of a Heyting category, so no subobject classifier necessary.</p>

#### [ David Michael Roberts (Oct 14 2018 at 03:52)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756798):
<p>Also, I wouldn't naively take Prop to be the subobject classifier. What about <code>1 -&gt;  Prop</code>?</p>

#### [ Mario Carneiro (Oct 14 2018 at 03:54)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756815):
<p><code>Prop</code> and <code>1 -&gt; Prop</code> are isomorphic</p>

#### [ David Michael Roberts (Oct 14 2018 at 03:55)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756863):
<p>Ah, well... :-/</p>

#### [ David Michael Roberts (Oct 14 2018 at 03:57)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756915):
<p>Looking at </p>
<blockquote>
<p>Def 4.1 in Shulman's <a href="https://arxiv.org/pdf/1808.05204.pdf" target="_blank" title="https://arxiv.org/pdf/1808.05204.pdf">https://arxiv.org/pdf/1808.05204.pdf</a> </p>
</blockquote>
<p>part a) gives me pause. The other parts b)-d) seem ok (Epis are surjective, "every function 1-&gt; U \cup V factors through U or V" and <code>1-&gt;0</code> is empty).</p>

#### [ Mario Carneiro (Oct 14 2018 at 03:59)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135756990):
<p>I guess (b) isn't obvious to me, mostly because I'm learning the terminology as I go</p>

#### [ Mario Carneiro (Oct 14 2018 at 04:02)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757108):
<p>But (a) does indeed look to be false. If <code>m : A -&gt; X</code> is <code>bijective</code>, then for every <code>x : X</code> (add <code>1 -&gt; </code> if you like) there exists <code>y : A</code> such that <code>f x = y</code>, but it is not necessarily an isomorphism</p>

#### [ David Michael Roberts (Oct 14 2018 at 04:03)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757116):
<p>By Remark 4.2 b) is equiv to epis are surjective, which you proved above.</p>

#### [ Mario Carneiro (Oct 14 2018 at 04:03)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757119):
<p>But, I think we have to be more careful about what the actual category under discussion is. Is all the metatheory being internalized to Lean?</p>

#### [ Mario Carneiro (Oct 14 2018 at 04:04)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757171):
<p>That is, if you prove there exists a morphism that may not mean that there is a closed term morphism</p>

#### [ David Michael Roberts (Oct 14 2018 at 04:04)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757172):
<p>Hmm, not sure. I was vaguely planning on formalising Mike's definitions and seeing what happened.</p>

#### [ Mario Carneiro (Oct 14 2018 at 04:05)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757206):
<p>I can almost imagine that knowing that every <code>x : 1 -&gt; X </code> splits over <code>m</code> in some strong external sense implying that there is an inverse function</p>

#### [ Mario Carneiro (Oct 14 2018 at 04:05)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757207):
<p>but that has its own issues</p>

#### [ Mario Carneiro (Oct 14 2018 at 04:06)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757249):
<p>If you assume choice, then of course you get all these properties</p>

#### [ Reid Barton (Oct 14 2018 at 04:06)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757252):
<p>I just tuned in and I'm not really sure what is going on here, but in the opposite direction it seems that (c) could fail if you interpreted "either A or B must be ..." in a strong external sense, as well</p>

#### [ David Michael Roberts (Oct 14 2018 at 04:07)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757257):
<blockquote>
<p>I can almost imagine that knowing that every <code>x : 1 -&gt; X </code> splits over <code>m</code> in some strong external sense implying that there is an inverse function</p>
</blockquote>
<p>ah, that would be quantifying over <code>1-&gt;X</code> I suppose, leading to a section (?). This is the old problem that with the strong constructive quantifier the axiom of choice is simply true.</p>

#### [ Reid Barton (Oct 14 2018 at 04:08)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757296):
<p>Same with (b) if you interpret the statement as a Pi/Sigma rather than a forall/exists</p>

#### [ David Michael Roberts (Oct 14 2018 at 04:08)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757299):
<blockquote>
<p>I just tuned in and I'm not really sure what is going on here, but in the opposite direction it seems that (c) could fail if you interpreted "either A or B must be ..." in a strong external sense, as well</p>
</blockquote>
<p>I would imagine it's not meant to be exclusive or.</p>

#### [ Reid Barton (Oct 14 2018 at 04:08)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757302):
<p>I mean that you could interpret it as a sum type</p>

#### [ Mario Carneiro (Oct 14 2018 at 04:08)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757305):
<p>it's certainly exclusive or, but that's not the hard part</p>

#### [ David Michael Roberts (Oct 14 2018 at 04:08)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757306):
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>  yes, I imagine so.</p>

#### [ Reid Barton (Oct 14 2018 at 04:08)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757310):
<p>rather than the propositional truncation thereof</p>

#### [ David Michael Roberts (Oct 14 2018 at 04:09)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757320):
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span>  but what if A=B as subobjects of X? (here I'm using Remark 4.2 again)</p>

#### [ Reid Barton (Oct 14 2018 at 04:09)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757324):
<p>I haven't read the preceding part of the paper so I'm not sure whether the metatheory is intended to be classical or what.</p>

#### [ Mario Carneiro (Oct 14 2018 at 04:10)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757404):
<p>If A = B then <code>1 = A \cup A</code>, and then by pushing the unique element of 1 around you find A = 1 and hence 1 has two distinct elements, which is false</p>

#### [ Mario Carneiro (Oct 14 2018 at 04:11)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757433):
<p>Actually I'm not even sure why that is an axiom, seems like it should be true in the base theory</p>

#### [ Mario Carneiro (Oct 14 2018 at 04:13)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757503):
<p>If <code>1 = A \cup B</code> then you get a distinguished element of <code>A \cup B</code>, and by following it you find which one is isomorphic to 1</p>

#### [ Mario Carneiro (Oct 14 2018 at 04:13)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757512):
<p>then again that relies on elementwise reasoning so it probably isn't true in the base theory</p>

#### [ David Michael Roberts (Oct 14 2018 at 04:14)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757578):
<p>Fair enough. Gotta run now, though</p>

#### [ Reid Barton (Oct 14 2018 at 04:16)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757675):
<p>BTW, are you allowing <code>funext</code>?</p>

#### [ Mario Carneiro (Oct 14 2018 at 04:17)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757688):
<p>I was assuming the other two axioms</p>

#### [ Mario Carneiro (Oct 14 2018 at 04:17)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757704):
<p>It is true that without quot.sound you have to worry about funext</p>

#### [ Reid Barton (Oct 14 2018 at 04:17)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757705):
<p>Okay good, otherwise I was confused about some earlier stuff.</p>

#### [ Mario Carneiro (Oct 14 2018 at 04:18)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135757754):
<p>and in that case I'm not sure there is a good theory at all, since the category is all about equalities of morphisms which are functions</p>

#### [ Kevin Buzzard (Oct 14 2018 at 12:15)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135771585):
<p>I love that #new users has all these questions about how <code>@</code> works etc  and then a huge thread about topos theory :-)</p>

#### [ David Michael Roberts (Oct 14 2018 at 12:45)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135772669):
<p>Tbh I barely know how <code>@</code> works, too, but I am coming at this top-down, which is probably the wrong way to do it.</p>

#### [ Kevin Buzzard (Oct 14 2018 at 15:23)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135777652):
<p>I don't think there are right and wrong ways to do it. I think we're still figuring out the best ways to learn and to direct growth of Lean. I think the best way to do it is to try all the ways we can think of.</p>

#### [ Jesse Michael Han (Oct 14 2018 at 19:55)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/ETCS/near/135787077):
<p>Re: the preceding discussion, I think one again needs unique choice to show (besides ruling out things like uninvertible bijections) that any epimorphism satisfies the universal property with respect to its kernel relation on its domain (i.e. is regular).</p>


{% endraw %}
