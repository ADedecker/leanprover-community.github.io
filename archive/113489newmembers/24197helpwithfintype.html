---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/24197helpwithfintype.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html">help with fintype</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="188777502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/help%20with%20fintype/near/188777502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html#188777502">Matt E (Feb 21 2020 at 21:42)</a>:</h4>
<p>I have a type of words over alphabets (which I am treating as enumerated types). </p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="err">Γ</span> <span class="bp">|</span> <span class="n">X</span> <span class="bp">|</span> <span class="n">Y</span>

<span class="kn">inductive</span> <span class="n">word</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">ε</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">word</span>
<span class="bp">|</span> <span class="n">nonempty</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">word</span> <span class="bp">→</span> <span class="n">word</span>
<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">∙</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">100</span> <span class="o">:=</span> <span class="n">word</span><span class="bp">.</span><span class="n">nonempty</span>

<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">X</span> <span class="err">∙</span> <span class="n">ε</span> <span class="o">:</span> <span class="n">word</span> <span class="err">Γ</span><span class="o">)</span>
</pre></div>


<p>I would like to have a <code>matrix (word Γ) (word Γ) _</code>, but this doesn't work as we would need <code>instance : fintype (word Γ)</code> (which surely is not constructible). So I started an attempt at finite words</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">max_length</span> <span class="o">:=</span> <span class="mi">1000</span>
<span class="kn">inductive</span> <span class="n">finword</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">empty</span> <span class="o">:</span> <span class="n">finword</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">nonempty</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span><span class="bp">+</span><span class="mi">1</span> <span class="bp">&lt;=</span> <span class="n">max_length</span><span class="o">}</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finword</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">finword</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
</pre></div>


<p>I have no idea really how to prove <code>fintype</code> for this. Maybe I need to rethink my approach. Thanks in advance for any suggestions. For reference I am trying to model what is called on slide 7 here "Closed and Consistent Finite Hankel Matrices", which as you can see are in the first instance finite matrices indexed by words in a language (hopefully once I have the correct type for such a matrix, then the closed &amp; consistent predicates will be easy) <a href="https://borjaballe.github.io/slides/turing18.pdf" target="_blank" title="https://borjaballe.github.io/slides/turing18.pdf">https://borjaballe.github.io/slides/turing18.pdf</a></p>

<a name="188778987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/help%20with%20fintype/near/188778987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html#188778987">Reid Barton (Feb 21 2020 at 22:01)</a>:</h4>
<p>I would just not use <code>matrix</code></p>

<a name="188779003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/help%20with%20fintype/near/188779003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html#188779003">Reid Barton (Feb 21 2020 at 22:02)</a>:</h4>
<p>A function seems fine</p>

<a name="188779994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/help%20with%20fintype/near/188779994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html#188779994">Matt E (Feb 21 2020 at 22:16)</a>:</h4>
<p>hm, yes I suppose a "partial" function <code>word α -&gt; word α -&gt; option bool</code> could work... I was thinking it would be useful to draw on the <code>matrix</code> methods, but actually it does not have the main thing I need which is some kind of <code>add_row</code>. let's see if I can define that...</p>

<a name="188793709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/help%20with%20fintype/near/188793709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html#188793709">Matt E (Feb 22 2020 at 02:32)</a>:</h4>
<p>so this is working well enough so far:</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">decidable_eq</span> <span class="n">α</span><span class="o">]</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="n">table</span><span class="bp">`</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">word</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">word</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">bool</span>

<span class="n">def</span> <span class="n">add_row</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">table</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">row</span> <span class="o">:</span> <span class="n">word</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">entries</span> <span class="o">:</span> <span class="n">word</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">bool</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">function</span><span class="bp">.</span><span class="n">update</span> <span class="n">t</span> <span class="n">row</span> <span class="n">entries</span>

<span class="n">def</span> <span class="n">consistent</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="n">table</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">word</span> <span class="n">α</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">T</span> <span class="n">p₁</span> <span class="bp">=</span> <span class="n">T</span> <span class="n">p₂</span> <span class="bp">→</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span><span class="err">∙</span><span class="n">p₁</span><span class="o">)</span> <span class="bp">=</span> <span class="n">T</span> <span class="o">(</span><span class="n">a</span><span class="err">∙</span><span class="n">p₂</span><span class="o">)</span>
</pre></div>


<p>now, ideally I would have a function that for any table, either proves consistency or gives a counterexample (or at least gives a bool answer for consistent or not). I should be able to construct that function as a term of some type right? I'm having trouble getting started</p>

<a name="188794472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/help%20with%20fintype/near/188794472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html#188794472">Mario Carneiro (Feb 22 2020 at 02:53)</a>:</h4>
<p>You should probably make <code>table</code> a definition rather than a notation</p>

<a name="188794516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/help%20with%20fintype/near/188794516" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html#188794516">Mario Carneiro (Feb 22 2020 at 02:54)</a>:</h4>
<p>You can't decide <code>consistent T</code> unless <code>word A</code> is finite</p>

<a name="188794526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/help%20with%20fintype/near/188794526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html#188794526">Mario Carneiro (Feb 22 2020 at 02:54)</a>:</h4>
<p>and <code>A</code></p>

<a name="188794545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/help%20with%20fintype/near/188794545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html#188794545">Mario Carneiro (Feb 22 2020 at 02:55)</a>:</h4>
<p>The type you want to construct is <code>decidable (consistent T)</code></p>

<a name="188794551"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/help%20with%20fintype/near/188794551" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html#188794551">Mario Carneiro (Feb 22 2020 at 02:56)</a>:</h4>
<p>although this is only the weaker form; for the stronger form you need some specialized proof-or-counterexample type</p>

<a name="188808316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/help%20with%20fintype/near/188808316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html#188808316">Matt E (Feb 22 2020 at 09:11)</a>:</h4>
<p>thanks. so I'm back to square one - I know how to deal with proving <code>fintype A</code> but <code>word A</code> just isn't finite (it is basically <code>list A</code>). so was my original <code>finword</code>sketch possibly a non insane idea?</p>

<a name="188819826"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/help%20with%20fintype/near/188819826" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html#188819826">Matt E (Feb 22 2020 at 14:33)</a>:</h4>
<p>right, so I'm pretty happy with this</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">x</span>
<span class="kn">inductive</span> <span class="n">fin</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>

<span class="kn">inductive</span> <span class="n">finword</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">empty</span>    <span class="o">{}</span>      <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>     <span class="o">:</span> <span class="n">finword</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">fin</span><span class="bp">.</span><span class="n">zero</span>
<span class="bp">|</span> <span class="n">nonempty</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">len</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">}</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">finword</span> <span class="n">n</span> <span class="n">len</span> <span class="bp">→</span> <span class="n">finword</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">len</span><span class="bp">.</span><span class="n">succ</span>

<span class="kn">infixr</span> <span class="bp">`</span> <span class="err">∙</span> <span class="bp">`</span> <span class="o">:</span><span class="mi">100</span> <span class="o">:=</span> <span class="n">finword</span><span class="bp">.</span><span class="n">nonempty</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="n">ε</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">finword</span><span class="bp">.</span><span class="n">empty</span>
</pre></div>


<p>but now I'm stuck on the type of tables:<br>
<code>def mytable : finword α 100 _ → finword α 100 _ → option bool |  ε ε := tt ...</code> clearly isn't valid, but neither is filling in any particular <code>fin</code> for the <code>_</code>. so it seems I would need to make that argument implicit in <code>finword</code>, but I'm not sure if that's possible...</p>

<a name="188820722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/help%20with%20fintype/near/188820722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html#188820722">Matt E (Feb 22 2020 at 14:59)</a>:</h4>
<p>this works, including the word lengths manually but is not very elegant</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">mytable</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="mi">10</span><span class="o">,</span> <span class="n">finword</span> <span class="err">Γ</span> <span class="mi">10</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">finword</span> <span class="err">Γ</span> <span class="mi">10</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">option</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">fin</span><span class="bp">.</span><span class="n">zero</span>  <span class="n">fin</span><span class="bp">.</span><span class="n">zero</span>  <span class="n">ε</span>          <span class="n">ε</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">fin</span><span class="bp">.</span><span class="n">succ</span> <span class="n">fin</span><span class="bp">.</span><span class="n">zero</span><span class="o">)</span> <span class="n">fin</span><span class="bp">.</span><span class="n">zero</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">X</span><span class="err">∙</span><span class="n">ε</span><span class="o">)</span> <span class="n">ε</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">none</span>
</pre></div>

<a name="188821509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/help%20with%20fintype/near/188821509" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24197helpwithfintype.html#188821509">Matt E (Feb 22 2020 at 15:21)</a>:</h4>
<p>and further, for a moderately sized table, lean does not want to compile it (<code>deep recursion was detected at 'replace'</code>)</p>


{% endraw %}

{% include archive_update.html %}