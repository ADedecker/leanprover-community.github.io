---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/16809rwat.html
---

## Stream: [new members](https://leanprover-community.github.io/archive/113489newmembers/index.html)
### Topic: [rw at *](https://leanprover-community.github.io/archive/113489newmembers/16809rwat.html)

---

<base href="https://leanprover.zulipchat.com">
{% raw %}
#### [ Ali Sever (Aug 01 2018 at 15:53)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/130715172):
<p>If I have <code>h : a = b</code>, and I want to get rid of all the <code>a</code>s  in my hypotheses, I use <code>rw h at *</code>. But sometimes some are unaffected, and I have to manually go through them, using <code>rw h at h37</code>. Am I doing something wrong or is there a better way?</p>

#### [ Kenny Lau (Aug 01 2018 at 15:59)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/130715571):
<p><code>subst h</code></p>

#### [ Ali Sever (Aug 01 2018 at 23:24)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/130742552):
<p>That didn't work.</p>

#### [ Simon Hudon (Aug 01 2018 at 23:32)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/130742974):
<p>I think that should be <code>subst a</code></p>

#### [ Simon Hudon (Aug 01 2018 at 23:33)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/130742978):
<p>(if a is a variable)</p>

#### [ Kenny Lau (Aug 01 2018 at 23:33)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/130742985):
<p>nah, it's <code>subst h</code></p>

#### [ Simon Hudon (Aug 01 2018 at 23:34)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/130743052):
<p>Alternatively, <code>simp only [h] at *</code> might help</p>

#### [ Mario Carneiro (Aug 01 2018 at 23:47)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/130743727):
<p>both <code>subst a</code> and <code>subst h</code> should work</p>

#### [ Ali Sever (Aug 11 2018 at 22:18)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131967570):
<p>Can someone explain why the following doesn't work?</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span>  <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">a</span> <span class="n">p</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">g</span> <span class="n">p</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">f</span> <span class="n">p</span> <span class="o">(</span><span class="n">g</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="c1">-- exact h1.symm ▸ h2.symm ▸ h (doesn&#39;t work)</span>
<span class="n">exact</span> <span class="n">h2</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">h1</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">h</span>
<span class="kn">end</span>
</pre></div>

#### [ Gabriel Ebner (Aug 11 2018 at 22:22)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131967688):
<p>Try <code>refine h1.symm ▸ _</code> (instead of exact).  Then you see the expected type Lean uses to elaborate <code>h2.symm ▸ h</code> and you'll see why it doesn't work.</p>

#### [ Ali Sever (Aug 11 2018 at 22:25)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131967774):
<p>If I have <code>q</code>instead of <code>g p</code>, the order doesn't matter, why does <code>g p</code> including <code>p</code> change how it works?</p>

#### [ Ali Sever (Aug 11 2018 at 22:29)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131967915):
<p>Isn't there a way to make subst only work once?</p>

#### [ Gabriel Ebner (Aug 11 2018 at 22:32)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131968029):
<p>It works with <code>q</code> instead of <code>g p</code> because <code>q</code> does not contain <code>p</code>.  No, when <code>▸</code> is elaborated, all occurrences of the lhs are replaced in the expected type.  In a sense <code>h ▸ _</code> in term mode does pretty much the same as <code>rw ← h</code> in tactic mode.</p>

#### [ Patrick Massot (Aug 11 2018 at 22:33)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131968039):
<blockquote>
<p>In a sense <code>h ▸ _</code> in term mode does pretty much the same as <code>rw ← h</code> in tactic mode.</p>
</blockquote>
<p>Except for obeying.</p>

#### [ JIANXIONG SUN (Aug 11 2018 at 23:57)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131970450):
<p>Can someone help me to prove that a * b + c * d = b * a + d * c , seems that mul_comm cannot work here</p>

#### [ Scott Morrison (Aug 12 2018 at 00:03)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131970633):
<p>Have you tried <code>ring</code>? &lt;--- oops, this won't work: this is me being a mathematician and forgetting "ring" doesn't mean "commutative ring".</p>

#### [ Scott Morrison (Aug 12 2018 at 00:03)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131970641):
<p>You can also use <code>conv</code> to restrict where the <code>rw</code> acts.</p>

#### [ Patrick Massot (Aug 12 2018 at 00:09)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131970840):
<p><code>ring</code> will work if you assume <code>comm_ring</code> instance</p>

#### [ Scott Morrison (Aug 12 2018 at 00:10)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131970884):
<p>oh, that's cool, I hadn't known that!</p>

#### [ Patrick Massot (Aug 12 2018 at 00:15)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131971004):
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">ring</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>  <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">ring</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>  <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_comm</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>  <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">conv</span> <span class="o">{</span>
      <span class="n">to_lhs</span><span class="o">,</span>
      <span class="n">congr</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
      <span class="n">skip</span><span class="o">,</span>
      <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>  <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">c</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">conv</span> <span class="o">{</span>
      <span class="n">for</span> <span class="o">(</span><span class="n">a</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">mul_comm</span> <span class="o">},</span>
      <span class="n">for</span> <span class="o">(</span><span class="n">c</span><span class="bp">*</span><span class="n">d</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">mul_comm</span> <span class="o">},</span>
  <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

#### [ Patrick Massot (Aug 12 2018 at 00:15)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131971008):
<p>The second one is a bit silly, but fun</p>

#### [ Mario Carneiro (Aug 12 2018 at 03:13)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131975463):
<p>I often use partial specification to describe where to rewrite, although this doesn't always work and then you can use the <code>conv</code> approach</p>
<div class="codehilite"><pre><span></span>example {α : Type*} [comm_ring α] {a b c d : α} :  a * b + c * d = b * a + d * c :=
by rw [mul_comm, mul_comm c]
</pre></div>

#### [ Mario Carneiro (Aug 12 2018 at 03:13)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131975469):
<p>Also, <code>by simp [mul_comm]</code> works</p>

#### [ Mario Carneiro (Aug 12 2018 at 03:14)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131975512):
<p><span class="user-mention" data-user-id="110087">@Scott Morrison</span> In fact <code>ring</code> is <em>only</em> for commutative (semi)rings. Perhaps I should have put <code>comm</code> in the name but I don't have any idea how to normalize a noncommutative ring</p>

#### [ Scott Morrison (Aug 12 2018 at 03:15)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/131975517):
<p>Perhaps we should put <code>noncomm_</code> in the name of a noncommutative ring. :-)</p>

#### [ JIANXIONG SUN (Aug 12 2018 at 17:56)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/132002007):
<p>Oh, I see, thank you very much</p>

#### [ Ali Sever (Aug 14 2018 at 20:21)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/132126762):
<p>How would one check to see which lemmas simp used? I want to suppress one of them.</p>

#### [ Patrick Massot (Aug 14 2018 at 20:29)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/132127189):
<p><code>set_option trace.simplify.rewrite true</code></p>

#### [ Ali Sever (Aug 19 2018 at 13:51)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/132401970):
<p>Is it impractical to have a tactic/function that does eq.subst with def eq things?</p>

#### [ Kenny Lau (Aug 19 2018 at 14:20)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/132402856):
<p>I don't think that's computable.</p>

#### [ Simon Hudon (Aug 19 2018 at 17:27)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/132409890):
<p><span class="user-mention" data-user-id="120256">@Ali Sever</span> Do you know about <code>dsimp</code> and <code>simp!</code>?</p>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> do you think it's uncomputable because def equality is not transitive? That doesn't matter as long as the language is strongly normalizing: every definition is guaranteed to terminate</p>

#### [ Ali Sever (Aug 19 2018 at 17:34)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/132410176):
<p>I want to be able to do something in the lines of <code>exact q ▸ h</code>, but I have to do</p>
<div class="codehilite"><pre><span></span><span class="n">suffices</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">this</span> <span class="bp">▸</span> <span class="n">h</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">q</span><span class="o">,</span>
</pre></div>


<p>where <code>q</code>is def eq to a proof of <code>a = b</code>.</p>

#### [ Chris Hughes (Aug 19 2018 at 17:39)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/132410344):
<p>You can do <code>(show a = b, from q) ▸ h</code></p>

#### [ Ali Sever (Aug 19 2018 at 17:44)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/132410562):
<p>I guess that's close enough, but I'm still wondering why it isn't its own function.</p>

#### [ Chris Hughes (Aug 19 2018 at 17:45)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/132410586):
<p>you might be able to try <code>erw q</code></p>

#### [ Reid Barton (Aug 19 2018 at 17:53)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/132410896):
<p>I would be curious to know whether that ever works; I've only seen <code>erw</code> see through definitional equalities in the goal/hypothesis to be rewritten</p>

#### [ Reid Barton (Aug 19 2018 at 17:55)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/132410966):
<p>It does seem like <code>rw</code> could try to reduce the rule until it is at least of the form <code>_ = _</code>, if it isn't already of that form</p>

#### [ Reid Barton (Aug 19 2018 at 17:56)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20at%20%2A/near/132411016):
<p>Or <code>iff</code></p>


{% endraw %}
