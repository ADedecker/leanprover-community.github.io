---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/51886Induction.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html">Induction</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="134579977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134579977" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134579977">Alistair Tucker (Sep 25 2018 at 07:30)</a>:</h4>
<p>Hello again! I'm still having a little trouble with my induction. In the example below the second dite gives me</p>
<div class="codehilite"><pre><span></span><span class="n">term</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">),</span> <span class="n">sol</span><span class="bp">.</span><span class="n">v</span> <span class="n">s</span> <span class="bp">_</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="bp">Π</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">sol</span><span class="bp">.</span><span class="n">V</span> <span class="n">s</span> <span class="bp">_</span> <span class="bp">→</span> <span class="n">β</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="bp">¬</span><span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">V</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">→</span> <span class="n">β</span>
</pre></div>


<p>But by the definition, V s hs should be the same as sol.V s (lt_of_ne s hs h)?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">open</span> <span class="n">nat</span> <span class="n">finset</span>

<span class="n">def</span> <span class="n">names</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">string</span> <span class="o">:=</span> <span class="o">{</span><span class="s2">&quot;BARC&quot;</span><span class="o">,</span> <span class="s2">&quot;HSBC&quot;</span><span class="o">,</span> <span class="s2">&quot;LLOY&quot;</span><span class="o">,</span> <span class="s2">&quot;NATW&quot;</span><span class="o">,</span> <span class="s2">&quot;RBSG&quot;</span><span class="o">,</span> <span class="s2">&quot;SANT&quot;</span><span class="o">,</span> <span class="s2">&quot;STDCH&quot;</span><span class="o">}</span>
<span class="n">def</span> <span class="n">B</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">//</span> <span class="n">s</span> <span class="err">∈</span> <span class="n">names</span><span class="o">}</span>

<span class="kn">structure</span> <span class="n">soln</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">),</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">V</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">find_domain</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">soln</span> <span class="n">α</span> <span class="n">β</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span>
<span class="kn">variable</span> <span class="o">{</span><span class="n">solve_pde</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">soln</span> <span class="n">α</span> <span class="n">β</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">V</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span>

<span class="n">def</span> <span class="n">solve_system</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">soln</span> <span class="n">α</span> <span class="n">β</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">nat</span><span class="bp">.</span><span class="n">rec</span>
    <span class="o">(</span><span class="k">let</span> <span class="n">V</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">not_lt_zero</span> <span class="o">(</span><span class="n">card</span> <span class="n">s</span><span class="o">)</span> <span class="n">hs</span><span class="o">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">V</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">not_lt_zero</span> <span class="o">(</span><span class="n">card</span> <span class="n">s</span><span class="o">)</span> <span class="n">hs</span><span class="o">)</span> <span class="k">in</span>
        <span class="bp">@</span><span class="n">soln</span><span class="bp">.</span><span class="n">mk</span> <span class="n">α</span> <span class="n">β</span> <span class="mi">0</span> <span class="n">V</span> <span class="n">v</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">sol</span> <span class="o">:</span> <span class="n">soln</span> <span class="n">α</span> <span class="n">β</span> <span class="n">n</span><span class="o">),</span>
        <span class="k">let</span> <span class="n">lt_of_ne</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="o">:=</span>
            <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">∨</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">lt_succ_iff_lt_or_eq</span><span class="bp">.</span><span class="n">mp</span> <span class="n">hs</span><span class="o">,</span>
            <span class="k">assume</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h1</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">h</span> <span class="n">h2</span><span class="o">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">V</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="o">:=</span>
            <span class="n">dite</span> <span class="o">(</span><span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>
                <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">),</span> <span class="n">find_domain</span> <span class="n">α</span> <span class="n">β</span> <span class="n">n</span> <span class="n">s</span> <span class="n">h</span> <span class="n">sol</span><span class="o">)</span>
                <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">),</span> <span class="n">sol</span><span class="bp">.</span><span class="n">V</span> <span class="n">s</span> <span class="o">(</span><span class="n">lt_of_ne</span> <span class="n">s</span> <span class="n">hs</span> <span class="n">h</span><span class="o">))</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">V</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
            <span class="n">dite</span> <span class="o">(</span><span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>
                <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">),</span> <span class="n">solve_pde</span> <span class="n">α</span> <span class="n">β</span> <span class="n">n</span> <span class="n">s</span> <span class="n">h</span> <span class="n">sol</span> <span class="o">(</span><span class="n">V</span> <span class="n">s</span> <span class="n">hs</span><span class="o">))</span>
                <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">),</span> <span class="n">sol</span><span class="bp">.</span><span class="n">v</span> <span class="n">s</span> <span class="o">(</span><span class="n">lt_of_ne</span> <span class="n">s</span> <span class="n">hs</span> <span class="n">h</span><span class="o">))</span> <span class="k">in</span>
        <span class="bp">@</span><span class="n">soln</span><span class="bp">.</span><span class="n">mk</span> <span class="n">α</span> <span class="n">β</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">V</span> <span class="n">v</span><span class="o">)</span>
</pre></div>

<a name="134579994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134579994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134579994">Alistair Tucker (Sep 25 2018 at 07:30)</a>:</h4>
<p>As you can probably tell by the names, I am attempting some applied mathematics :)</p>

<a name="134590793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134590793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134590793">Reid Barton (Sep 25 2018 at 11:49)</a>:</h4>
<p><code>V s hs</code> isn't equal to <code>sol.V s (lt_of_ne s hs h)</code> in general, only when you have the hypothesis <code>¬card s = n</code>, and even then it's not a definitional equality. You have to use <code>dif_neg</code> to simplify the <code>dite</code>.</p>

<a name="134590965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134590965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134590965">Reid Barton (Sep 25 2018 at 11:53)</a>:</h4>
<p>I haven't looked carefully at what's going on here, but I wonder if there might be an easier way--it looks like you're constructing a "solution for all sets of size &lt; n" by induction on n, where we just pass to the inductive hypothesis if the set is not of the new size--then why not just define a "solution for all sets of size = n", and then if you want to reproduce the type of <code>soln</code>, just provide <code>n = card s</code></p>

<a name="134592386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134592386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134592386">Alistair Tucker (Sep 25 2018 at 12:20)</a>:</h4>
<p>Thanks! I have applied dif_neg but the final step eludes me...</p>
<div class="codehilite"><pre><span></span><span class="k">let</span> <span class="n">v</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">B</span><span class="o">)</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">&lt;</span> <span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">V</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
    <span class="n">dite</span> <span class="o">(</span><span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>
        <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">n</span><span class="o">),</span> <span class="n">solve_pde</span> <span class="n">α</span> <span class="n">β</span> <span class="n">n</span> <span class="n">s</span> <span class="n">h</span> <span class="n">sol</span> <span class="o">(</span><span class="n">V</span> <span class="n">s</span> <span class="n">hs</span><span class="o">))</span>
        <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">card</span> <span class="n">s</span> <span class="bp">≠</span> <span class="n">n</span><span class="o">),</span>
            <span class="k">have</span> <span class="n">V</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">=</span> <span class="n">sol</span><span class="bp">.</span><span class="n">V</span> <span class="n">s</span> <span class="o">(</span><span class="n">lt_of_ne</span> <span class="n">s</span> <span class="n">hs</span> <span class="n">h</span><span class="o">),</span> <span class="k">from</span> <span class="n">dif_neg</span> <span class="n">h</span><span class="o">,</span>
            <span class="n">sol</span><span class="bp">.</span><span class="n">v</span> <span class="n">s</span> <span class="o">(</span><span class="n">lt_of_ne</span> <span class="n">s</span> <span class="n">hs</span> <span class="n">h</span><span class="o">))</span> <span class="k">in</span>
</pre></div>

<a name="134592520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134592520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134592520">Alistair Tucker (Sep 25 2018 at 12:23)</a>:</h4>
<p>Your description of my intended algorithm is spot on. The reason I am trying to accumulate the Vs and vs in each successive soln is so that I can prove certain relations between them.</p>

<a name="134592759"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134592759" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134592759">Reid Barton (Sep 25 2018 at 12:27)</a>:</h4>
<p>Now there are two ways to proceed</p>

<a name="134592811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134592811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134592811">Reid Barton (Sep 25 2018 at 12:28)</a>:</h4>
<p>The easier way is to change the last line to something like <code>by rw this; exact sol.v s (lt_of_ne s hs h)</code>, or the term-mode equivalent using <code>eq.rec</code></p>

<a name="134593877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134593877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134593877">Alistair Tucker (Sep 25 2018 at 12:44)</a>:</h4>
<p>Got it! Thank you.</p>

<a name="134594108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/134594108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#134594108">Reid Barton (Sep 25 2018 at 12:48)</a>:</h4>
<p>The slightly more complicated way is to instead use the equality <code>this</code> to turn the hypothesis <code>y ∈ V s hs</code> into a proof of <code>y ∈ sol.V s _</code>--this will probably make things easier later if you want to prove things about the values of <code>v</code>, because the actual <code>β</code> value won't be wrapped inside a <code>rw</code>/<code>eq.rec</code></p>

<a name="154250457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154250457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154250457">Patrick Thomas (Jan 03 2019 at 16:40)</a>:</h4>
<p>Suppose I have the following:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">lambda</span>

<span class="kn">inductive</span> <span class="n">exp</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span>

<span class="kn">inductive</span> <span class="n">is_subterm</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="c1">-- x ∈ Sub (x)</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">string</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span>

<span class="c1">-- e1 ∈ Sub ((e1 e2))</span>
<span class="bp">|</span> <span class="n">app_l</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e1</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">e2</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="n">e1</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span>

<span class="c1">-- e2 ∈ Sub ((e1 e2))</span>
<span class="bp">|</span> <span class="n">app_r</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e1</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">e2</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="n">e2</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span>

<span class="c1">-- (e1 e2) ∈ Sub ((e1 e2))</span>
<span class="bp">|</span> <span class="n">app_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e1</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">e2</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span>

<span class="c1">-- e ∈ Sub ((λ x . e))</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">e</span><span class="o">)</span>

<span class="c1">-- (λ x . e) ∈ Sub ((λ x . e))</span>
<span class="bp">|</span> <span class="n">abs_self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">e</span><span class="o">)</span>
</pre></div>


<p>Is it possible to prove that is_subterm does not hold for something? For example, could one prove that if <code>x</code> is a lambda variable, then the only subterm of <code>x</code> is <code>x</code> itself?</p>

<a name="154250562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154250562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154250562">Patrick Massot (Jan 03 2019 at 16:42)</a>:</h4>
<p>Doesn't it contradict <code>is_subterm.abs</code>?</p>

<a name="154250752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154250752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154250752">Patrick Thomas (Jan 03 2019 at 16:46)</a>:</h4>
<p>Are you saying that the statement "if <code>x</code> is a lambda variable, then the only subterm of <code>x</code> is <code>x</code> itself", does not hold because of <code>is_subterm.abs</code>? I'm not sure I see why that would be the case?</p>

<a name="154250754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154250754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154250754">Gabriel Ebner (Jan 03 2019 at 16:46)</a>:</h4>
<p>This is provable (hint: try the <code>cases</code> tactic):</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">y</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_subterm</span> <span class="n">y</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">y</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span>
</pre></div>

<a name="154250765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154250765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154250765">Rob Lewis (Jan 03 2019 at 16:46)</a>:</h4>
<p>You may need to be a little careful about how you state it, but this is a good place to take advantage of the equation compiler. It will discharge the structurally impossible cases for you.</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">s</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="o">(</span><span class="n">is_subterm</span><span class="bp">.</span><span class="n">var</span> <span class="bp">_</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>


<p>(As Gabriel points out, <code>cases</code> will do the same thing.)</p>

<a name="154250796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154250796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154250796">Patrick Massot (Jan 03 2019 at 16:48)</a>:</h4>
<p>oh I missed "variable" in "lambda variable", it's on the next line here</p>

<a name="154251107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154251107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154251107">Patrick Thomas (Jan 03 2019 at 16:52)</a>:</h4>
<p>Thank you. I will have to do some reading on tactics and the equation compiler.</p>

<a name="154251985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154251985" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154251985">Patrick Thomas (Jan 03 2019 at 17:09)</a>:</h4>
<p>I'm still learning how induction is handled in Lean. Does the inductive definition create theorems related to what is not an object of the defined type?</p>

<a name="154252289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154252289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154252289">Rob Lewis (Jan 03 2019 at 17:14)</a>:</h4>
<p>The only objects of the defined type are the ones that can be defined using the constructors. This is a "theorem" that's captured by the type's induction principle. In your case, look at <code>#check is_subterm.cases_on </code>.</p>

<a name="154253410"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154253410" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154253410">Kenny Lau (Jan 03 2019 at 17:37)</a>:</h4>
<p>should we use <code>nat</code> instead of <code>string</code>?</p>

<a name="154254942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154254942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154254942">Patrick Thomas (Jan 03 2019 at 18:03)</a>:</h4>
<p>Is the following what Gabriel means by the <code>cases</code> tactic?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span> <span class="o">:=</span>
    <span class="n">exp</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">e</span>
    <span class="o">(</span><span class="k">show</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">string</span><span class="o">),</span> <span class="n">is_subterm</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">),</span> <span class="k">from</span>
    <span class="k">assume</span> <span class="n">y</span> <span class="o">:</span> <span class="n">string</span><span class="o">,</span>
</pre></div>


<p>I'm not sure how to proceed from here.</p>

<a name="154254968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154254968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154254968">Kenny Lau (Jan 03 2019 at 18:03)</a>:</h4>
<p>well by the <code>cases</code> tactic he means <code>by cases e</code></p>

<a name="154254973"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154254973" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154254973">Kenny Lau (Jan 03 2019 at 18:03)</a>:</h4>
<p>but I don't know if you're familiar with using tactics</p>

<a name="154255034"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154255034" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154255034">Patrick Thomas (Jan 03 2019 at 18:04)</a>:</h4>
<p>Oh. No, I'm not.</p>

<a name="154255194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154255194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154255194">Gabriel Ebner (Jan 03 2019 at 18:06)</a>:</h4>
<p>Actually I mean by cases on the <code>is_subterm</code> proof:<br>
<code>begin intro h, cases h, end</code>  (you can easily solve the remaining goal)</p>

<a name="154265785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154265785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154265785">Kenny Lau (Jan 03 2019 at 20:55)</a>:</h4>
<p>why bother making <code>is_subterm</code> inductive</p>

<a name="154265902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154265902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154265902">Patrick Thomas (Jan 03 2019 at 20:57)</a>:</h4>
<p>I thought it would have to be. What is the alternative?</p>

<a name="154266764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154266764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154266764">Kenny Lau (Jan 03 2019 at 21:13)</a>:</h4>
<p>well it isn't inductive (i.e. recursive) so maybe just make it a def or something</p>

<a name="154267466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154267466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154267466">Patrick Thomas (Jan 03 2019 at 21:25)</a>:</h4>
<p>Hmm. I was trying to formalize the recursive definition of the set of all subterms of a lambda expression given by definition 1.3.5 here: <a href="https://play.google.com/books/reader?id=orsrBQAAQBAJ&amp;hl=en_US&amp;pg=GBS.PA5.w.4.0.36" target="_blank" title="https://play.google.com/books/reader?id=orsrBQAAQBAJ&amp;hl=en_US&amp;pg=GBS.PA5.w.4.0.36">https://play.google.com/books/reader?id=orsrBQAAQBAJ&amp;hl=en_US&amp;pg=GBS.PA5.w.4.0.36</a><br>
Did I do this wrong?</p>

<a name="154267703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154267703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154267703">Rob Lewis (Jan 03 2019 at 21:29)</a>:</h4>
<p>You're missing the recursive calls. The set of subterms of (M N) is the union of the subterms of M, the subterms of N, and the singleton set {(M N)}.</p>

<a name="154267747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154267747" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154267747">Rob Lewis (Jan 03 2019 at 21:29)</a>:</h4>
<p>In your definition, (M N) only has three subterms: M, N, and (M N).</p>

<a name="154267858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154267858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154267858">Rob Lewis (Jan 03 2019 at 21:30)</a>:</h4>
<p>This is a perfectly good situation to use an inductive predicate, but the one you wrote isn't the one you wanted.</p>

<a name="154269430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154269430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154269430">Patrick Thomas (Jan 03 2019 at 21:56)</a>:</h4>
<p>Does adding the following fix it?</p>
<div class="codehilite"><pre><span></span><span class="bp">|</span> <span class="n">app_l&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">e1</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">e2</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="o">(</span><span class="n">is_subterm</span> <span class="n">e</span> <span class="n">e1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">app_r&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">e1</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">e2</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="o">(</span><span class="n">is_subterm</span> <span class="n">e</span> <span class="n">e2</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">string</span><span class="o">)</span> <span class="o">(</span><span class="n">e1</span> <span class="o">:</span> <span class="n">exp</span><span class="o">),</span> <span class="o">(</span><span class="n">is_subterm</span> <span class="n">e</span> <span class="n">e1</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">e1</span><span class="o">)</span>
</pre></div>


<p>Also, is there a way to formalize this as a set, similar to the definition in the book?</p>

<a name="154269672"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154269672" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154269672">Gabriel Ebner (Jan 03 2019 at 22:00)</a>:</h4>
<p>Sure, you can just write a recursive function:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">subterms</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">multiset</span> <span class="n">exp</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">}</span>
<span class="c1">-- ...</span>
</pre></div>


<p>I'm not sure why they use multisets instead of sets though.</p>

<a name="154269810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154269810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154269810">Rob Lewis (Jan 03 2019 at 22:02)</a>:</h4>
<p>You could add those, and you can also reduce some of the others into one case.</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">is_subterm</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">self</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">is_subterm</span> <span class="n">x</span> <span class="n">x</span>
<span class="bp">|</span> <span class="n">app_l</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="n">x</span><span class="o">,</span> <span class="n">is_subterm</span> <span class="n">x</span> <span class="n">e₁</span> <span class="bp">→</span> <span class="n">is_subterm</span> <span class="n">x</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">app_r</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="n">x</span><span class="o">,</span> <span class="n">is_subterm</span> <span class="n">x</span> <span class="n">e₂</span> <span class="bp">→</span> <span class="n">is_subterm</span> <span class="n">x</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">e</span> <span class="n">s</span> <span class="n">x</span><span class="o">,</span> <span class="n">is_subterm</span> <span class="n">x</span> <span class="n">e</span> <span class="bp">→</span> <span class="n">is_subterm</span> <span class="n">x</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">s</span> <span class="n">e</span><span class="o">)</span>
</pre></div>

<a name="154270313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154270313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154270313">Kenny Lau (Jan 03 2019 at 22:12)</a>:</h4>
<p>and rename <code>self</code> into <code>refl</code>...</p>

<a name="154270442"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154270442" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154270442">Kenny Lau (Jan 03 2019 at 22:15)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_subterm</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">s</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="bp">||</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="n">e₁</span> <span class="bp">||</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="n">e₂</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">s</span> <span class="n">e&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">s</span> <span class="n">e&#39;</span><span class="o">)</span> <span class="bp">||</span> <span class="n">is_subterm</span> <span class="n">e</span> <span class="n">e&#39;</span>
</pre></div>

<a name="154270505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154270505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154270505">Kenny Lau (Jan 03 2019 at 22:16)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_subterm</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">exp</span><span class="o">)</span> <span class="o">:</span> <span class="n">exp</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">var</span> <span class="n">s</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">app</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="bp">||</span> <span class="n">is_subterm</span> <span class="n">e₁</span> <span class="bp">||</span> <span class="n">is_subterm</span> <span class="n">e₂</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">s</span> <span class="n">e&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">e</span> <span class="bp">=</span> <span class="n">exp</span><span class="bp">.</span><span class="n">abs</span> <span class="n">s</span> <span class="n">e&#39;</span><span class="o">)</span> <span class="bp">||</span> <span class="n">is_subterm</span> <span class="n">e&#39;</span>
</pre></div>

<a name="154270926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/154270926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#154270926">Patrick Thomas (Jan 03 2019 at 22:24)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> Cool. Could something similar be done for the set of all lambda terms?</p>

<a name="160262747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160262747" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160262747">Patrick Thomas (Mar 08 2019 at 04:26)</a>:</h4>
<p>I was wondering what the error "nested occurrence 'and (sub_is_def P x N) (not (has_mem.mem.{0 0} var (set.{0} var) (set.has_mem.{0} var) y (FV N)))' contains variables that are not parameters" means in the last definition of:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">var</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kn">inductive</span> <span class="n">pre_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">-&gt;</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">-&gt;</span> <span class="n">pre_term</span> <span class="bp">-&gt;</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">-&gt;</span> <span class="n">pre_term</span> <span class="bp">-&gt;</span> <span class="n">pre_term</span>

<span class="n">def</span> <span class="n">FV</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">-&gt;</span> <span class="n">set</span> <span class="n">var</span>
<span class="bp">|</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span> <span class="o">)</span> <span class="o">:=</span> <span class="o">{</span> <span class="n">x</span> <span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="o">(</span> <span class="n">P</span> <span class="o">)</span> <span class="err">∪</span> <span class="n">FV</span> <span class="o">(</span> <span class="n">Q</span> <span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span> <span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="o">(</span> <span class="n">P</span> <span class="o">)</span> <span class="err">\</span> <span class="o">{</span> <span class="n">x</span> <span class="o">}</span>

<span class="kn">inductive</span> <span class="n">sub_is_def</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">-&gt;</span> <span class="n">var</span> <span class="bp">-&gt;</span> <span class="n">pre_term</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var_same</span> <span class="o">:</span>
    <span class="k">forall</span> <span class="o">(</span> <span class="n">y</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">x</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">),</span>
    <span class="o">(</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">sub_is_def</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span> <span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">var_diff</span> <span class="o">:</span>
    <span class="k">forall</span> <span class="o">(</span> <span class="n">y</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">x</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">),</span>
    <span class="n">not</span> <span class="o">(</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">sub_is_def</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span> <span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span>
    <span class="k">forall</span> <span class="o">(</span> <span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">)</span> <span class="o">(</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">)</span> <span class="o">(</span> <span class="n">x</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">),</span>
    <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">-&gt;</span> <span class="n">sub_is_def</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">-&gt;</span> <span class="n">sub_is_def</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span> <span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">:</span>
    <span class="k">forall</span> <span class="o">(</span> <span class="n">y</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">)</span> <span class="o">(</span> <span class="n">x</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">),</span>
    <span class="o">(</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">sub_is_def</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span> <span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">:</span>
    <span class="k">forall</span> <span class="o">(</span> <span class="n">y</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">)</span> <span class="o">(</span> <span class="n">x</span> <span class="o">:</span> <span class="n">var</span> <span class="o">)</span> <span class="o">(</span> <span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="o">),</span>
    <span class="n">not</span> <span class="o">(</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span> <span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span> <span class="o">(</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span> <span class="n">N</span> <span class="o">)</span> <span class="o">)</span> <span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">sub_is_def</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span> <span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
</pre></div>


<p>It seems to be related to the <code>/\</code> in <code>abs_diff</code>.</p>

<a name="160268512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160268512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160268512">Mario Carneiro (Mar 08 2019 at 07:00)</a>:</h4>
<p><code>sub_is_def</code> is embedded in a complicated way in the last proposition</p>

<a name="160268710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160268710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160268710">Mario Carneiro (Mar 08 2019 at 07:06)</a>:</h4>
<p>you have to make it a manifestly positive occurrence:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">var</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kn">inductive</span> <span class="n">pre_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>

<span class="n">def</span> <span class="n">FV</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">var</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">Q</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">\</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>

<span class="kn">inductive</span> <span class="n">sub_is_def</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var_same</span> <span class="o">(</span><span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">var_diff</span> <span class="o">(</span><span class="n">y</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">app</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">(</span><span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_diff_nel</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
</pre></div>

<a name="160349574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160349574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160349574">Patrick Thomas (Mar 09 2019 at 04:22)</a>:</h4>
<p>Thank you. What does a "manifestly positive occurrence" mean?</p>

<a name="160350668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160350668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160350668">Mario Carneiro (Mar 09 2019 at 04:52)</a>:</h4>
<p>The definition of an inductive specification in lean requires that all constructors for the inductive type <code>T</code> have the form <code>A1 -&gt; A2 -&gt; ... -&gt; T</code> where each <code>A</code> that mentions <code>T</code> has the form <code>B1 -&gt; B2 -&gt; ... T</code> (ignoring indexes). In other words, the only places the type <code>T</code> is allowed to appear is on the far right hand side (the constructor should produce an element of type <code>T</code>), and on the right of the left hand side (the constructors may take arguments of type <code>T</code> or arguments that are functions producing <code>T</code>). This is called "strict positivity". <code>T</code> is not allowed to appear anywhere else, so <code>mk : (T -&gt; A) -&gt; T</code> is not allowed, nor is <code>mk : ((T -&gt; A) -&gt; A) -&gt; T</code> or <code>foo T -&gt; T</code> or <code>A /\ (T \/ B) -&gt; T</code>. The last two cases are called nested inductive types, and lean can sometimes compile them to primitive inductive types, but they aren't built in.</p>

<a name="160351703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160351703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160351703">Patrick Thomas (Mar 09 2019 at 05:20)</a>:</h4>
<p>I think I sort of understand. Thank you.</p>

<a name="160352615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160352615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160352615">Patrick Thomas (Mar 09 2019 at 05:50)</a>:</h4>
<p>Is it possible to have conditions in the constructors for inductively defined functions? For example, how would one define the lambda substitution <code>x [ y := N ]</code>, which depends on whether <code>x = y</code> or <code>x != y</code>?</p>

<a name="160352684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160352684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160352684">Mario Carneiro (Mar 09 2019 at 05:52)</a>:</h4>
<p>you can use <code>if</code></p>

<a name="160352753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160352753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160352753">Patrick Thomas (Mar 09 2019 at 05:55)</a>:</h4>
<p>Is there a description of using <code>if</code> in the doc?</p>

<a name="160352800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160352800" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160352800">Mario Carneiro (Mar 09 2019 at 05:56)</a>:</h4>
<p><code>if p then a else b</code> returns <code>a</code> if <code>p</code> is true and <code>b</code> if false</p>

<a name="160352815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160352815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160352815">Mario Carneiro (Mar 09 2019 at 05:57)</a>:</h4>
<p>In inductive predicates like the above, it's a bit nicer to have separate constructors for the true and false cases, but for recursive functions we usually use <code>if</code></p>

<a name="160353287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353287">Patrick Thomas (Mar 09 2019 at 06:13)</a>:</h4>
<p>For this:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
</pre></div>


<p>I get:<br>
failed to synthesize type class instance for<br>
sub : pre_term → var → pre_term → pre_term,<br>
y x : var,<br>
N : pre_term<br>
⊢ decidable (pre_term.var x = pre_term.var y)</p>

<a name="160353493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353493">Mario Carneiro (Mar 09 2019 at 06:20)</a>:</h4>
<p>you can say <code>if x = y then ...</code></p>

<a name="160353540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353540">Patrick Thomas (Mar 09 2019 at 06:21)</a>:</h4>
<p>I see. I still get the same error.</p>

<a name="160353603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353603">Mario Carneiro (Mar 09 2019 at 06:23)</a>:</h4>
<p>What is <code>var</code>?</p>

<a name="160353647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353647">Patrick Thomas (Mar 09 2019 at 06:24)</a>:</h4>
<p><code>inductive var : Type</code></p>

<a name="160353648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353648">Mario Carneiro (Mar 09 2019 at 06:24)</a>:</h4>
<p>there are no vars?</p>

<a name="160353655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353655">Patrick Thomas (Mar 09 2019 at 06:24)</a>:</h4>
<p>I'm not sure what you mean?</p>

<a name="160353663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353663" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353663">Mario Carneiro (Mar 09 2019 at 06:25)</a>:</h4>
<p>that declaration means <code>var</code> is empty</p>

<a name="160353673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353673">Mario Carneiro (Mar 09 2019 at 06:25)</a>:</h4>
<p>you can put <code>@[derive decidable_eq]</code> to automatically derive a decidable instance for <code>var</code></p>

<a name="160353722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353722">Patrick Thomas (Mar 09 2019 at 06:26)</a>:</h4>
<p>Oh. Should I have defined <code>var</code> differently?</p>

<a name="160353727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353727">Mario Carneiro (Mar 09 2019 at 06:26)</a>:</h4>
<p>what do you want it to be? One reasonable choice is <code>def var := nat</code></p>

<a name="160353784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353784">Patrick Thomas (Mar 09 2019 at 06:28)</a>:</h4>
<p>I'm not sure. What would make the most sense for the lambda calculus? Maybe a character or a string?</p>

<a name="160353785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353785">Mario Carneiro (Mar 09 2019 at 06:28)</a>:</h4>
<p>that works too</p>

<a name="160353795"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353795" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353795">Mario Carneiro (Mar 09 2019 at 06:29)</a>:</h4>
<p>But you have to be careful with how you handle bound variable renaming if you don't use de bruijn indices</p>

<a name="160353800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353800" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353800">Mario Carneiro (Mar 09 2019 at 06:29)</a>:</h4>
<p>for example, <code>subst</code> can either rename variables, or it can be partial</p>

<a name="160353866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353866">Mario Carneiro (Mar 09 2019 at 06:31)</a>:</h4>
<p>having it be a char seems like a bad idea because if the set of variables is finite then weird things happen</p>

<a name="160353867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353867">Patrick Thomas (Mar 09 2019 at 06:31)</a>:</h4>
<p>I think it is partial in the book I am following for this. That is, it only defines substitution if it is capture avoiding.</p>

<a name="160353920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353920">Mario Carneiro (Mar 09 2019 at 06:32)</a>:</h4>
<p>if your book uses explicit names then <code>string</code> works</p>

<a name="160353922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353922">Mario Carneiro (Mar 09 2019 at 06:32)</a>:</h4>
<p>but you will need to prove a renaming lemma at some point, which will require you to know that <code>var</code> is infinite</p>

<a name="160353941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160353941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160353941">Patrick Thomas (Mar 09 2019 at 06:33)</a>:</h4>
<p>Ah. yes.</p>

<a name="160354120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160354120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160354120">Patrick Thomas (Mar 09 2019 at 06:39)</a>:</h4>
<p>I changed to <code>def var := string</code>.<br>
If I have:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>


<p>Then I get:<br>
type mismatch at application<br>
  ite (x = y) N y<br>
term<br>
  y<br>
has type<br>
  var<br>
but is expected to have type<br>
  pre_term<br>
If I go back to</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
</pre></div>


<p>Then I still get:<br>
failed to synthesize type class instance for<br>
sub : pre_term → var → pre_term → pre_term,<br>
y x : var,<br>
N : pre_term<br>
⊢ decidable (pre_term.var x = pre_term.var y)</p>

<a name="160354192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160354192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160354192">Patrick Thomas (Mar 09 2019 at 06:41)</a>:</h4>
<p>I see. I still needed <code>@[derive decidable_eq]</code>.</p>

<a name="160354739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160354739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160354739">Patrick Thomas (Mar 09 2019 at 06:59)</a>:</h4>
<p>Hmm. I'm not sure how the case where substitution is not defined is going to work in this definition. It seems there has to be an <code>else</code> for each <code>if, then</code> and for</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span>
</pre></div>


<p>I get<br>
type expected at<br>
  pre_term.app (sub P x N) (sub Q x N)<br>
term has type<br>
  pre_term</p>

<a name="160355540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160355540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160355540">Mario Carneiro (Mar 09 2019 at 07:24)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>


</blockquote>
<p>you are getting a type error because of the <code>y</code> at the end</p>

<a name="160355670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160355670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160355670">Mario Carneiro (Mar 09 2019 at 07:28)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">∧</span> <span class="n">sub_is_def</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="k">then</span> <span class="o">(</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">)</span>
</pre></div>


</blockquote>
<p>Here you don't want to have the <code>if</code> at all. You have already defined the domain of definition of <code>sub</code>, so here you can just do the easy thing - </p>
<div class="codehilite"><pre><span></span>| (pre_term.app P Q) x N := pre_term.app (sub P x N) (sub Q x N)
</pre></div>

<a name="160355685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160355685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160355685">Mario Carneiro (Mar 09 2019 at 07:29)</a>:</h4>
<p>Alternatively, you can have <code>sub</code> itself be a (partial) functional relation rather than a recursive function</p>

<a name="160355693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160355693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160355693">Mario Carneiro (Mar 09 2019 at 07:29)</a>:</h4>
<p>that is, define <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>[</mo><mi>x</mi><mo>:</mo><mo>=</mo><mi>N</mi><mo>]</mo><mo>=</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">P[x:=N]=Q</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mrel">:</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit">Q</span></span></span></span> as an inductive predicate on four arguments</p>

<a name="160355886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160355886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160355886">Mario Carneiro (Mar 09 2019 at 07:34)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">is_subst</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var_same</span> <span class="o">(</span><span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">var_diff</span> <span class="o">(</span><span class="n">y</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="n">Q&#39;</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_subst</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="n">Q&#39;</span>  <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">app</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">P&#39;</span><span class="bp">.</span><span class="n">app</span> <span class="n">Q&#39;</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">(</span><span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs_diff_nel</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span> <span class="n">P&#39;</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P&#39;</span><span class="o">)</span>
</pre></div>

<a name="160355900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160355900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160355900">Patrick Thomas (Mar 09 2019 at 07:35)</a>:</h4>
<p>Are you saying that whether <code>P x N</code> and <code>Q x N</code> are defined is already somehow part of the definition of <code>sub</code>?</p>

<a name="160355960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160355960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160355960">Mario Carneiro (Mar 09 2019 at 07:36)</a>:</h4>
<p>I suspect that it will be easier to work with the relation "the substitution of N for x in P is Q" rather than the conjunction of "the substitution is defined" and "the substitution is Q"</p>

<a name="160356021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356021">Patrick Thomas (Mar 09 2019 at 07:38)</a>:</h4>
<p>I have been attempting to follow how the book I am going through does it, so that I can prove the theorems in the same manner. I want to improve the readability of the book for myself and others.</p>

<a name="160356081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356081">Patrick Thomas (Mar 09 2019 at 07:40)</a>:</h4>
<p>It's a little circular. Reading the book to learn about the theory behind Lean, and using Lean to learn the book.</p>

<a name="160356150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356150">Patrick Thomas (Mar 09 2019 at 07:42)</a>:</h4>
<p>In this instance I am formalizing the result of this question: <a href="https://math.stackexchange.com/questions/3109334/formal-definition-of-substitution-being-defined-in-type-free-lambda-calculus?noredirect=1&amp;lq=1" target="_blank" title="https://math.stackexchange.com/questions/3109334/formal-definition-of-substitution-being-defined-in-type-free-lambda-calculus?noredirect=1&amp;lq=1">https://math.stackexchange.com/questions/3109334/formal-definition-of-substitution-being-defined-in-type-free-lambda-calculus?noredirect=1&amp;lq=1</a></p>

<a name="160356479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356479">Patrick Thomas (Mar 09 2019 at 07:53)</a>:</h4>
<p>In the case of</p>
<div class="codehilite"><pre><span></span><span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span>
</pre></div>


<p>what will happen if I pass a pre_term for <code>P</code> or <code>Q</code> to the function for which the substitution is not defined?</p>

<a name="160356646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356646">Mario Carneiro (Mar 09 2019 at 07:58)</a>:</h4>
<p>you get garbage</p>

<a name="160356659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356659">Mario Carneiro (Mar 09 2019 at 07:59)</a>:</h4>
<p>but you get garbage no matter what with the "total function" / "domain of definition" approach</p>

<a name="160356664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356664" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356664">Mario Carneiro (Mar 09 2019 at 07:59)</a>:</h4>
<p>The four place relation avoids this</p>

<a name="160356931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160356931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160356931">Patrick Thomas (Mar 09 2019 at 08:05)</a>:</h4>
<p>I see. I still hate to depart from the book, since many of the proofs involve showing that a given substitution is defined.</p>

<a name="160357096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160357096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160357096">Patrick Thomas (Mar 09 2019 at 08:08)</a>:</h4>
<p>I think using:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">var</span> <span class="o">:=</span> <span class="n">string</span>
<span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">decidable_eq</span><span class="o">]</span>

<span class="kn">inductive</span> <span class="n">pre_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>

<span class="n">def</span> <span class="n">FV</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">var</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">Q</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">\</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>

<span class="kn">inductive</span> <span class="n">sub_is_def</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var_same</span> <span class="o">(</span><span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">var_diff</span> <span class="o">(</span><span class="n">y</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">P</span><span class="bp">.</span><span class="n">app</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">(</span><span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_diff_nel</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>

<span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">))</span>
</pre></div>


<p>may be closest to what they have.</p>

<a name="160357292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160357292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160357292">Patrick Thomas (Mar 09 2019 at 08:15)</a>:</h4>
<p>Although, yes, I guess keeping sub_is_def and adding the four place relation is about the same.</p>

<a name="160377957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160377957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160377957">Patrick Thomas (Mar 09 2019 at 18:21)</a>:</h4>
<p>What does the syntax <code>(P.app Q)</code>mean? Why that and not <code>(pre_term.app P Q)</code>?</p>

<a name="160378143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160378143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160378143">Bryan Gin-ge Chen (Mar 09 2019 at 18:26)</a>:</h4>
<p>I think this is an example of "dot notation". There's a thread on it here: <a href="#narrow/stream/113488-general/topic/dot.20notation.20confusion" title="#narrow/stream/113488-general/topic/dot.20notation.20confusion">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/dot.20notation.20confusion</a></p>

<a name="160379095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/160379095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#160379095">Patrick Thomas (Mar 09 2019 at 18:53)</a>:</h4>
<p>Thank you.</p>

<a name="162901853"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162901853" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162901853">Patrick Thomas (Apr 09 2019 at 11:39)</a>:</h4>
<p>I was wondering if someone would mind showing me how to set up the form of proof for the last lemma here (lemma_1_2_5_i). I'm pretty sure I want to do induction on <code>M</code>, but I'm having difficulty figuring out the syntax.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>
<span class="kn">open</span> <span class="n">set</span>

<span class="n">def</span> <span class="n">var</span> <span class="o">:=</span> <span class="bp">ℕ</span>
<span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">decidable_eq</span><span class="o">]</span>

<span class="kn">inductive</span> <span class="n">pre_term</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="n">abs</span> <span class="o">:</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>

<span class="n">def</span> <span class="n">FV</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">var</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">∪</span> <span class="n">FV</span> <span class="n">Q</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">\</span> <span class="o">{</span><span class="n">x</span><span class="o">}</span>


<span class="kn">lemma</span> <span class="n">lemma_1</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span> <span class="k">from</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_of_mem_diff</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span><span class="o">,</span> <span class="k">from</span> <span class="n">mt</span> <span class="n">s1</span><span class="o">,</span>
<span class="k">show</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span><span class="o">,</span> <span class="k">from</span> <span class="n">s2</span> <span class="n">a1</span>


<span class="kn">lemma</span> <span class="n">lemma_2</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">t</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span> <span class="bp">↔</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">t</span><span class="o">,</span> <span class="k">from</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_diff</span> <span class="n">x</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span><span class="o">,</span> <span class="k">from</span> <span class="n">s1</span><span class="bp">.</span><span class="n">elim_left</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s3</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span> <span class="err">\</span> <span class="n">t</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">t</span><span class="o">),</span> <span class="k">from</span> <span class="n">mt</span> <span class="n">s2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s4</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">x</span> <span class="err">∈</span> <span class="n">s</span> <span class="bp">∧</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">t</span><span class="o">),</span> <span class="k">from</span> <span class="n">s3</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">show</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">s</span><span class="o">,</span> <span class="k">from</span> <span class="n">not_and&#39;</span><span class="bp">.</span><span class="n">elim_left</span> <span class="n">s4</span> <span class="n">a2</span>


<span class="kn">lemma</span> <span class="n">lemma_3</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span><span class="n">var</span> <span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">\</span> <span class="o">{</span><span class="n">y</span><span class="o">},</span> <span class="k">from</span> <span class="n">lemma_1</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">show</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">),</span> <span class="k">from</span> <span class="n">s1</span>


<span class="kn">lemma</span> <span class="n">lemma_4</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">),</span>
<span class="k">assume</span> <span class="n">a2</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span> <span class="err">\</span> <span class="o">{</span><span class="n">y</span><span class="o">},</span> <span class="k">from</span> <span class="n">a1</span><span class="o">,</span>
<span class="k">have</span> <span class="n">s2</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="o">{</span><span class="n">y</span><span class="o">},</span> <span class="k">from</span> <span class="n">mt</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_singleton_iff</span><span class="bp">.</span><span class="n">elim_left</span> <span class="n">a2</span><span class="o">,</span>
<span class="k">show</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">P</span><span class="o">,</span> <span class="k">from</span> <span class="n">lemma_2</span> <span class="n">s1</span> <span class="n">s2</span>


<span class="c1">-- M [ x := N ]</span>
<span class="kn">inductive</span> <span class="n">sub_is_def</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var_same</span> <span class="o">(</span><span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">var_diff</span> <span class="o">(</span><span class="n">y</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">(</span><span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_diff_nel</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span>

<span class="n">def</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="n">N</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">(</span><span class="n">sub</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="k">then</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="o">(</span><span class="n">sub</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">))</span>

<span class="kn">inductive</span> <span class="n">is_subst</span> <span class="o">:</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">var</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="n">pre_term</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">var_same</span> <span class="o">(</span><span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="n">N</span>
<span class="bp">|</span> <span class="n">var_diff</span> <span class="o">(</span><span class="n">y</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">y</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">app</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="n">Q&#39;</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_subst</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="n">Q</span> <span class="n">x</span> <span class="n">N</span> <span class="n">Q&#39;</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">P&#39;</span> <span class="n">Q&#39;</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs_same</span> <span class="o">(</span><span class="n">P</span> <span class="n">x</span> <span class="n">N</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">x</span> <span class="n">P</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs_diff_nel</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">abs_diff</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">P</span> <span class="n">N</span> <span class="n">P&#39;</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">≠</span> <span class="n">y</span> <span class="bp">→</span> <span class="n">y</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">N</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="n">P</span> <span class="n">x</span> <span class="n">N</span> <span class="n">P&#39;</span> <span class="bp">→</span> <span class="n">is_subst</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">y</span> <span class="n">P&#39;</span><span class="o">)</span>


<span class="kn">lemma</span> <span class="n">lemma_1_2_5_i</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">M</span><span class="o">,</span>
<span class="k">show</span> <span class="n">sub_is_def</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span>
</pre></div>

<a name="162902578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162902578" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162902578">Chris Hughes (Apr 09 2019 at 11:51)</a>:</h4>
<p>This is one way. Your induction hypothesis will be called <code>lemma_1_2_5_i</code></p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">lemma_1_2_5_i</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">),</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">M</span> <span class="bp">→</span> <span class="n">sub_is_def</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">N</span> <span class="n">h</span><span class="o">,</span> <span class="n">sorry</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">N</span> <span class="n">h</span><span class="o">,</span> <span class="n">sorry</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">N</span> <span class="n">h</span><span class="o">,</span> <span class="n">sorry</span>
</pre></div>

<a name="162902794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162902794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162902794">Mario Carneiro (Apr 09 2019 at 11:54)</a>:</h4>
<p>Are you familiar with tactic proofs? It's a bit easier to handle these big inductive predicates using <code>induction</code></p>

<a name="162902814"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162902814" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162902814">Mario Carneiro (Apr 09 2019 at 11:54)</a>:</h4>
<p>something like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">lemma_1_2_5_i</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">a1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="n">M</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">induction</span> <span class="n">M</span><span class="o">,</span>
  <span class="n">case</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="o">{</span>
    <span class="n">by_cases</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">M</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">h</span><span class="o">,</span> <span class="n">constructor</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">constructor</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">app</span> <span class="o">:</span> <span class="n">M₁</span> <span class="n">M₂</span> <span class="n">IH₁</span> <span class="n">IH₂</span> <span class="o">{</span>
    <span class="n">constructor</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">IH₁</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">FV</span><span class="o">]</span> <span class="n">at</span> <span class="n">a1</span><span class="o">,</span> <span class="n">tauto</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">apply</span> <span class="n">IH₂</span><span class="o">,</span> <span class="n">simp</span> <span class="o">[</span><span class="n">FV</span><span class="o">]</span> <span class="n">at</span> <span class="n">a1</span><span class="o">,</span> <span class="n">tauto</span> <span class="o">}</span> <span class="o">},</span>
  <span class="n">case</span> <span class="n">pre_term</span><span class="bp">.</span><span class="n">abs</span> <span class="o">:</span> <span class="n">y</span> <span class="n">M</span> <span class="n">IH</span> <span class="o">{</span>
    <span class="n">by_cases</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">h</span><span class="o">,</span> <span class="n">constructor</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">sub_is_def</span><span class="bp">.</span><span class="n">abs_diff_nel</span> <span class="n">h</span> <span class="n">a1</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="162903356"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162903356" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162903356">Patrick Thomas (Apr 09 2019 at 12:02)</a>:</h4>
<p>Mario: No, not that familiar. I'll have to look these commands up. Thank you.<br>
Chris: What does the <code>h</code> in each case correspond to?</p>

<a name="162903466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162903466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162903466">Johan Commelin (Apr 09 2019 at 12:04)</a>:</h4>
<p><span class="user-mention" data-user-id="139442">@Patrick Thomas</span> A proof that <code>x ∉ FV M</code></p>

<a name="162903486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162903486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162903486">Patrick Thomas (Apr 09 2019 at 12:05)</a>:</h4>
<p>Ahh. Thank you.</p>

<a name="162906492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162906492" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162906492">Patrick Thomas (Apr 09 2019 at 12:46)</a>:</h4>
<p>How would I match each case of the inductively defined proposition without tactics? For example:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">var</span><span class="o">)</span> <span class="o">(</span><span class="n">N</span> <span class="o">:</span> <span class="n">pre_term</span><span class="o">)</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∉</span> <span class="n">FV</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">M</span><span class="o">))</span> <span class="o">:</span> <span class="n">sub_is_def</span> <span class="o">(</span><span class="n">pre_term</span><span class="bp">.</span><span class="n">var</span> <span class="n">M</span><span class="o">)</span> <span class="n">x</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>

<a name="162907575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162907575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162907575">Patrick Thomas (Apr 09 2019 at 13:01)</a>:</h4>
<p>Actually, how are each of the cases in sub_is_def matched in the proof that Mario gave?</p>

<a name="162908849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162908849" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162908849">Mario Carneiro (Apr 09 2019 at 13:17)</a>:</h4>
<p>The proof is by induction on <code>M</code>, not <code>sub_is_def</code></p>

<a name="162908877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162908877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162908877">Mario Carneiro (Apr 09 2019 at 13:17)</a>:</h4>
<p>so there is one case for each constructor of <code>pre_term</code></p>

<a name="162908965"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162908965" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162908965">Mario Carneiro (Apr 09 2019 at 13:18)</a>:</h4>
<p>But it is proving <code>sub_is_def</code>, and in most of the cases I use <code>constructor</code> to pick the appropriate constructor</p>

<a name="162908979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162908979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162908979">Patrick Thomas (Apr 09 2019 at 13:18)</a>:</h4>
<p>What does constructor do?</p>

<a name="162909017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162909017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162909017">Mario Carneiro (Apr 09 2019 at 13:19)</a>:</h4>
<p>it's basically <code>apply sub_is_def.var_same &lt;|&gt; apply sub_is_def.var_diff &lt;|&gt; ...</code></p>

<a name="162910341"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Induction/near/162910341" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/51886Induction.html#162910341">Patrick Thomas (Apr 09 2019 at 13:34)</a>:</h4>
<p>Interesting. Thank you.</p>


{% endraw %}
