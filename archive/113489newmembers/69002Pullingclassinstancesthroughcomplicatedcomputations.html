---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html">Pulling class instances through "complicated" computations</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="172748298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172748298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172748298">Robert Spencer (Aug 08 2019 at 08:43)</a>:</h4>
<p>Good morning all.</p>
<p>I wonder if anyone could help me understand how best to tackle the following.  In a nutshell, I am performing some computations on types (taking quotients of submodules) and lean is struggling to find an instance I need for the result (that a quotient of a submodule is indeed a module).</p>
<p>Here is my minimal code.  Mathematically I am defining a filtration of a module, and then finding its subquotients.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span>

<span class="n">universes</span> <span class="n">U₁</span> <span class="n">U₂</span>

<span class="kn">namespace</span> <span class="n">list</span>
  <span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">U₁</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">U₂</span><span class="o">}</span>
  <span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span>

  <span class="c1">-- Much like head,</span>
  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">head&#39;&#39;</span><span class="o">:</span> <span class="bp">Π</span>  <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">L</span> <span class="bp">≠</span> <span class="o">[]</span> <span class="bp">→</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="o">[]</span>        <span class="n">h</span> <span class="o">:=</span> <span class="n">absurd</span> <span class="n">rfl</span> <span class="n">h</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">x</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="kn">lemma</span> <span class="n">chain&#39;_desc_left</span> <span class="o">:</span> <span class="n">chain&#39;</span> <span class="n">R</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">L</span><span class="o">)</span> <span class="bp">→</span> <span class="n">chain&#39;</span> <span class="n">R</span> <span class="n">L</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">L</span><span class="bp">;</span> <span class="n">simp</span><span class="o">[</span><span class="n">chain&#39;</span><span class="o">]</span>

  <span class="n">def</span> <span class="n">chain&#39;_apply_between</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="n">R</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">y</span> <span class="bp">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">(</span><span class="n">rel_of_chain_cons</span> <span class="n">h</span><span class="o">))</span> <span class="bp">::</span>
                       <span class="o">(</span><span class="n">chain&#39;_apply_between</span> <span class="o">(</span><span class="n">y</span> <span class="bp">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">chain&#39;_desc_left</span> <span class="n">h</span><span class="o">)</span> <span class="o">)</span>

<span class="kn">end</span> <span class="n">list</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="n">class</span> <span class="n">filtration</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">mods</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>
  <span class="o">(</span><span class="n">is_fil</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="o">(</span><span class="n">has_le</span><span class="bp">.</span><span class="n">le</span><span class="o">)</span> <span class="n">mods</span><span class="o">)</span>

<span class="n">def</span> <span class="n">mk_quotient</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">))</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">≤</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">((</span><span class="n">submodule</span><span class="bp">.</span><span class="n">map_subtype</span><span class="bp">.</span><span class="n">order_iso</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">l</span><span class="bp">⟩</span><span class="o">)</span>


<span class="n">def</span> <span class="n">factors</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filtration</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;_apply_between</span> <span class="o">(</span><span class="n">mk_quotient</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="n">F</span><span class="bp">.</span><span class="n">mods</span> <span class="n">F</span><span class="bp">.</span><span class="n">is_fil</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filtration</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span> <span class="bp">≠</span> <span class="o">[])</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">M</span>                                          <span class="c">/-</span><span class="cm"> M : Type -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">((</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">head&#39;&#39;</span> <span class="n">h</span><span class="o">)</span>                 <span class="c">/-</span><span class="cm"> list.head&#39;&#39; (factors R M F) h : Type -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">neg_smul</span> <span class="n">R</span> <span class="n">M</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>                        <span class="c">/-</span><span class="cm"> neg_smul : ∀ (r : R) (x : M), -r • x = -(r • x) -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">neg_smul</span> <span class="n">R</span> <span class="o">((</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">head&#39;&#39;</span> <span class="n">h</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span>
</pre></div>


<p>The last line fails, </p>
<div class="codehilite"><pre><span></span>failed to synthesize type class instance for
R : Type,
_inst_1 : ring R,
M : Type,
_inst_2 : add_comm_group M,
_inst_3 : module R M,
F : filtration R M,
h : factors R M F ≠ list.nil
⊢ add_comm_group (list.head&#39;&#39; (factors R M F) h)
</pre></div>


<p>Now, there is an instance defined in mathlib for <code>instance : add_comm_group (quotient p) </code>, which, once you unpack <code>head''</code> and <code>chain'_apply_between</code> is really what we are looking at.</p>
<p>How would be the best way to help lean find this instance?  I have two ideas: either a bunch of lemmas that carry the instances over each step or bundling the type with its instance data (in a similar manner to <code>submodule</code>) so that it is all in one place.  Are either of these good lean practice?</p>
<p>Hope I am not missing something obvious and stupid!</p>

<a name="172749428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172749428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172749428">Mario Carneiro (Aug 08 2019 at 09:03)</a>:</h4>
<p>I would first point out that your use of <code>list Type</code> is rather unidiomatic and can lead to this kind of issues</p>

<a name="172749499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172749499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172749499">Mario Carneiro (Aug 08 2019 at 09:04)</a>:</h4>
<p>It's almost useless to have a <code>list Type</code> because you don't know where the types came from so you don't know what structure they carry (like add_comm_group structure here)</p>

<a name="172749538"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172749538" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172749538">Mario Carneiro (Aug 08 2019 at 09:05)</a>:</h4>
<p>and you can't use the usual list lemmas because that leads to an equality of types which is problematic (aka "evil")</p>

<a name="172750025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172750025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172750025">Mario Carneiro (Aug 08 2019 at 09:14)</a>:</h4>
<p>One possibility is to use <code>fin n -&gt; Type</code> instead, which has better characteristics. But you need to know <code>n</code>, which here is something like <code>mods.length - 1</code> which is not so nice, especially in a rigid position like the <code>n</code> in <code>fin n</code>. You can remove the dependency by extending the list by some suitable default value past the end, for example if <code>modn n := if h : n &lt; mods.length then mods.nth_le n h else \top</code>, then you can prove <code>is_filn n : modn n &lt;= modn (n+1)</code> and then write <code>factors n := mk_quotient (is_filn n)</code> and now everything unfolds nicely.</p>

<a name="172751046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172751046">Robert Spencer (Aug 08 2019 at 09:36)</a>:</h4>
<p>I understand that <code>list Type</code> is a problem, exactly for the reasons stated.</p>
<p>I had thought that <code>fin n -&gt; A</code> was almost interchangeable with <code>list A</code>, as there are suitable coercions between them (I think).  As you say, though, <code>fin n</code> requires you to know <code>n</code>.  This is not the end of the world for me I don't think.  I'd much rather not extend the filtration past the top, as I would like to distinguish between <code>0 &lt; U_1 &lt; U_2 &lt; M</code> and <code>0 &lt; U_1 &lt; U_2 &lt; M &lt; M</code> as filtrations.</p>
<p>This problem completely goes away if we have a <code>list (submodule R M)</code> for example because <code>submodule R M</code> is itself a structure and carries instances associated to that structure.  In an earlier draft of this I redefined a <code>modules</code> structure along the lines of</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">modules</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">carrier</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">add_comm_group</span> <span class="o">:</span> <span class="n">add_comm_group</span> <span class="n">carrier</span><span class="o">)</span>
  <span class="o">(</span><span class="n">module</span> <span class="o">:</span> <span class="n">module</span> <span class="n">R</span> <span class="n">carrier</span><span class="o">)</span>
</pre></div>


<p>and then defined suitable coercions to <code>Type</code>, and instances of <code>add_comm_group</code> on that coercion etc. etc.  This felt very dirty though, and not at all in the spirit of lean, but did let me have a <code>list (modules R)</code> very easily.</p>

<a name="172751056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172751056">Kevin Buzzard (Aug 08 2019 at 09:36)</a>:</h4>
<p>The problem seems to be that each of the subquotients has type <code>Type</code>, but type class inference isn't smart enough to spot that it can put a module structure on the subquotients. I suspect this problem could be solved by bundling. If you had a type whose terms were R-modules, rather than the current set-up where M is a parameter for the R-module set-up, then perhaps things would go better.</p>

<a name="172751218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172751218">Robert Spencer (Aug 08 2019 at 09:39)</a>:</h4>
<p>"Bundling" such as the above <code>structure</code>?</p>

<a name="172751295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172751295">Kevin Buzzard (Aug 08 2019 at 09:41)</a>:</h4>
<p>At the minute you have terms of type <code>Type</code> and it's not generally true that a random term of this type is a module, so Lean's typeclass system can't deal with what you are trying to do. I guess another possibility would be to make your own structure consisting of a list and an R-module structure of each element of the list, and then work with these structures.</p>

<a name="172751402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172751402">Kevin Buzzard (Aug 08 2019 at 09:43)</a>:</h4>
<p>Sorry, I'm on the London underground and I only have sporadic reception [messages are being sent before I see earlier messages you sent]. Yes, you're making the bundled category of R-modules. I am sure <span class="user-mention" data-user-id="110087">@Scott Morrison</span> would thoroughly approve and would argue that it was, or perhaps should be, in the spirit of Lean. Different people seem to have different opinions on the matter.</p>

<a name="172751651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172751651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172751651">Kevin Buzzard (Aug 08 2019 at 09:49)</a>:</h4>
<p>Currently people believe that submodules of a given module should be a type, but that rings should not be a type (R should be a type and then the ring structure should be handled by the typeclass systems). Modules over a given ring are somewhere in the middle. Currently we're letting the typeclass system try and handle them -- but it's not clear to me whether this is "right" -- there will be advantages and disadvantages to each approach I guess. I will remark that we had real problems trying to make the typeclass system work with modules, there were a couple of failed attempts. The mathlib code</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">module</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">semimodule</span> <span class="n">α</span> <span class="n">β</span>

<span class="kn">structure</span> <span class="n">module</span><span class="bp">.</span><span class="n">core</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">has_scalar</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">smul_add</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">r</span> <span class="err">•</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">r</span> <span class="err">•</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">add_smul</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="n">s</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">s</span> <span class="err">•</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">mul_smul</span> <span class="o">:</span> <span class="bp">∀</span><span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="n">s</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="n">s</span> <span class="err">•</span> <span class="n">x</span><span class="o">)</span>
<span class="o">(</span><span class="n">one_smul</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">x</span> <span class="o">:</span> <span class="n">β</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span><span class="o">)</span>

<span class="n">def</span> <span class="n">module</span><span class="bp">.</span><span class="n">of_core</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">ring</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">module</span><span class="bp">.</span><span class="n">core</span> <span class="n">α</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">module</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">letI</span> <span class="o">:=</span> <span class="n">M</span><span class="bp">.</span><span class="n">to_has_scalar</span><span class="bp">;</span> <span class="n">exact</span>
<span class="o">{</span> <span class="n">zero_smul</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="err">•</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">M</span><span class="bp">.</span><span class="n">add_smul</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">add_left_cancel</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">smul_zero</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">r</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">r</span> <span class="err">•</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">β</span><span class="o">)</span> <span class="bp">+</span> <span class="n">r</span> <span class="err">•</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">r</span> <span class="err">•</span> <span class="mi">0</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span> <span class="n">M</span><span class="bp">.</span><span class="n">smul_add</span><span class="bp">;</span> <span class="n">simp</span><span class="o">,</span>
    <span class="n">add_left_cancel</span> <span class="n">this</span><span class="o">,</span>
  <span class="bp">..</span><span class="n">M</span> <span class="o">}</span>
</pre></div>


<p>already seems to indicate that something funny is going on.</p>


{% endraw %}

{% include archive_update.html %}