---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html">Pulling class instances through "complicated" computations</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="172748298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Pulling%20class%20instances%20through%20%22complicated%22%20computations/near/172748298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/69002Pullingclassinstancesthroughcomplicatedcomputations.html#172748298">Robert Spencer (Aug 08 2019 at 08:43)</a>:</h4>
<p>Good morning all.</p>
<p>I wonder if anyone could help me understand how best to tackle the following.  In a nutshell, I am performing some computations on types (taking quotients of submodules) and lean is struggling to find an instance I need for the result (that a quotient of a submodule is indeed a module).</p>
<p>Here is my minimal code.  Mathematically I am defining a filtration of a module, and then finding its subquotients.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">list</span>

<span class="n">universes</span> <span class="n">U₁</span> <span class="n">U₂</span>

<span class="kn">namespace</span> <span class="n">list</span>
  <span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">U₁</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">U₂</span><span class="o">}</span>
  <span class="kn">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">}</span>

  <span class="c1">-- Much like head,</span>
  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="n">def</span> <span class="n">head&#39;&#39;</span><span class="o">:</span> <span class="bp">Π</span>  <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">L</span> <span class="bp">≠</span> <span class="o">[]</span> <span class="bp">→</span> <span class="n">α</span>
  <span class="bp">|</span> <span class="o">[]</span>        <span class="n">h</span> <span class="o">:=</span> <span class="n">absurd</span> <span class="n">rfl</span> <span class="n">h</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">x</span>

  <span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span>
  <span class="kn">lemma</span> <span class="n">chain&#39;_desc_left</span> <span class="o">:</span> <span class="n">chain&#39;</span> <span class="n">R</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">L</span><span class="o">)</span> <span class="bp">→</span> <span class="n">chain&#39;</span> <span class="n">R</span> <span class="n">L</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">L</span><span class="bp">;</span> <span class="n">simp</span><span class="o">[</span><span class="n">chain&#39;</span><span class="o">]</span>

  <span class="n">def</span> <span class="n">chain&#39;_apply_between</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span><span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="o">(</span><span class="n">R</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="n">R</span> <span class="n">L</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">β</span>
  <span class="bp">|</span> <span class="o">[]</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">[]</span>
  <span class="bp">|</span> <span class="o">(</span><span class="n">x</span> <span class="bp">::</span> <span class="n">y</span> <span class="bp">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">(</span><span class="n">rel_of_chain_cons</span> <span class="n">h</span><span class="o">))</span> <span class="bp">::</span>
                       <span class="o">(</span><span class="n">chain&#39;_apply_between</span> <span class="o">(</span><span class="n">y</span> <span class="bp">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">chain&#39;_desc_left</span> <span class="n">h</span><span class="o">)</span> <span class="o">)</span>

<span class="kn">end</span> <span class="n">list</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">R</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">[</span><span class="n">add_comm_group</span> <span class="n">M</span><span class="o">]</span> <span class="o">[</span><span class="n">module</span> <span class="n">R</span> <span class="n">M</span><span class="o">]</span>

<span class="n">class</span> <span class="n">filtration</span> <span class="o">:=</span>
  <span class="o">(</span><span class="n">mods</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">submodule</span> <span class="n">R</span> <span class="n">M</span><span class="o">))</span>
  <span class="o">(</span><span class="n">is_fil</span> <span class="o">:</span> <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;</span> <span class="o">(</span><span class="n">has_le</span><span class="bp">.</span><span class="n">le</span><span class="o">)</span> <span class="n">mods</span><span class="o">)</span>

<span class="n">def</span> <span class="n">mk_quotient</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="o">:</span> <span class="n">submodule</span> <span class="n">R</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">))</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">U</span> <span class="bp">≤</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="n">submodule</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">((</span><span class="n">submodule</span><span class="bp">.</span><span class="n">map_subtype</span><span class="bp">.</span><span class="n">order_iso</span> <span class="n">V</span><span class="o">)</span><span class="bp">.</span><span class="n">inv_fun</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">l</span><span class="bp">⟩</span><span class="o">)</span>


<span class="n">def</span> <span class="n">factors</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filtration</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="kt">Type</span> <span class="o">:=</span>
  <span class="n">list</span><span class="bp">.</span><span class="n">chain&#39;_apply_between</span> <span class="o">(</span><span class="n">mk_quotient</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="n">F</span><span class="bp">.</span><span class="n">mods</span> <span class="n">F</span><span class="bp">.</span><span class="n">is_fil</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filtration</span> <span class="n">R</span> <span class="n">M</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span> <span class="bp">≠</span> <span class="o">[])</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">M</span>                                          <span class="c">/-</span><span class="cm"> M : Type -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">((</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">head&#39;&#39;</span> <span class="n">h</span><span class="o">)</span>                 <span class="c">/-</span><span class="cm"> list.head&#39;&#39; (factors R M F) h : Type -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">neg_smul</span> <span class="n">R</span> <span class="n">M</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span>                        <span class="c">/-</span><span class="cm"> neg_smul : ∀ (r : R) (x : M), -r • x = -(r • x) -/</span>
<span class="bp">#</span><span class="kn">check</span> <span class="bp">@</span><span class="n">neg_smul</span> <span class="n">R</span> <span class="o">((</span><span class="n">factors</span> <span class="n">R</span> <span class="n">M</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">head&#39;&#39;</span> <span class="n">h</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span>
</pre></div>


<p>The last line fails, </p>
<div class="codehilite"><pre><span></span>failed to synthesize type class instance for
R : Type,
_inst_1 : ring R,
M : Type,
_inst_2 : add_comm_group M,
_inst_3 : module R M,
F : filtration R M,
h : factors R M F ≠ list.nil
⊢ add_comm_group (list.head&#39;&#39; (factors R M F) h)
</pre></div>


<p>Now, there is an instance defined in mathlib for <code>instance : add_comm_group (quotient p) </code>, which, once you unpack <code>head''</code> and <code>chain'_apply_between</code> is really what we are looking at.</p>
<p>How would be the best way to help lean find this instance?  I have two ideas: either a bunch of lemmas that carry the instances over each step or bundling the type with its instance data (in a similar manner to <code>submodule</code>) so that it is all in one place.  Are either of these good lean practice?</p>
<p>Hope I am not missing something obvious and stupid!</p>


{% endraw %}

{% include archive_update.html %}