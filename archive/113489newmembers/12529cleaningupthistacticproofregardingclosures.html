---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html">cleaning up this tactic proof (regarding closures)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="192339476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192339476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192339476">Kevin Doran (Mar 31 2020 at 02:17)</a>:</h4>
<p>I've got most of the way through the following proof; however, I'm stuck at one section (Q6). In addition, I was wondering if you could help me clean up the existing code. (live in web editor: <a href="https://tinyurl.com/upkybhm" title="https://tinyurl.com/upkybhm">https://tinyurl.com/upkybhm</a>). Any help greatly appreciated.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">normed_space</span><span class="bp">.</span><span class="n">basic</span>

<span class="c1">-- Q0. Notation for absolute. Should I reuse this from somewhere in Lean or mathlib?</span>
<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`|`</span><span class="n">x</span><span class="bp">`|`</span> <span class="o">:=</span> <span class="n">abs</span> <span class="n">x</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span>
<span class="n">def</span> <span class="n">is_adherent</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">∃</span><span class="n">y</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">|</span><span class="n">x</span> <span class="bp">-</span> <span class="n">y</span><span class="bp">|</span> <span class="bp">≤</span> <span class="n">ε</span>

<span class="kn">infix</span> <span class="bp">`</span><span class="n">is_adherent_to</span><span class="bp">`</span> <span class="o">:</span><span class="mi">55</span> <span class="o">:=</span> <span class="n">is_adherent</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span>
<span class="n">def</span> <span class="n">closure</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">|</span> <span class="n">x</span> <span class="n">is_adherent_to</span> <span class="n">X</span> <span class="o">}</span>


<span class="kn">lemma</span> <span class="n">closure_squeeze</span>
  <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">Y</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">Y</span> <span class="err">⊆</span> <span class="n">closure</span><span class="o">(</span><span class="n">X</span><span class="o">))</span> <span class="o">:</span>
<span class="n">closure</span><span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="n">closure</span><span class="o">(</span><span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- Q1. Should all unfolds be removed when finished? Are they superfluous?</span>
  <span class="c1">--unfold closure,</span>
  <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">eq_of_subset_of_subset</span><span class="o">,</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="c1">-- Q2. intro vs. assume, which is preferred? assume has the benefit of optionally being</span>
    <span class="c1">-- explicit in what is being introduced.</span>
    <span class="k">assume</span> <span class="n">h₃</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">closure</span><span class="o">(</span><span class="n">X</span><span class="o">),</span>
    <span class="n">intro</span> <span class="n">ε</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">hε</span> <span class="o">:</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h₄</span> <span class="o">:</span> <span class="n">x</span> <span class="n">is_adherent_to</span> <span class="n">X</span><span class="o">,</span> <span class="k">from</span> <span class="n">h₃</span><span class="o">,</span>
    <span class="n">unfold</span> <span class="n">is_adherent</span> <span class="n">at</span> <span class="n">h₄</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h₅</span> <span class="o">:</span> <span class="bp">∃</span><span class="n">x&#39;</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">|</span><span class="n">x</span><span class="bp">-</span><span class="n">x&#39;</span><span class="bp">|</span> <span class="bp">≤</span> <span class="n">ε</span><span class="o">,</span> <span class="k">from</span> <span class="n">h₃</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h₅</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">x&#39;</span> <span class="n">h_exists_temp</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h_exists_temp</span><span class="o">,</span>
    <span class="n">intros</span> <span class="n">h₆</span> <span class="n">h₇</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h₈</span> <span class="o">:</span> <span class="n">x&#39;</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="k">from</span> <span class="n">h₁</span> <span class="n">h₆</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">x&#39;</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">h₈</span> <span class="n">h₇</span>
  <span class="o">},</span>
  <span class="o">{</span>
    <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h₃</span> <span class="o">:</span> <span class="n">y</span> <span class="err">∈</span> <span class="n">closure</span><span class="o">(</span><span class="n">Y</span><span class="o">),</span>
    <span class="n">intro</span> <span class="n">ε</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">hε</span> <span class="o">:</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span>
    <span class="c1">-- Q3. What is a better way to get a δ = ε/3? It takes...</span>
    <span class="k">have</span> <span class="n">h₄</span> <span class="o">:</span> <span class="bp">∃</span><span class="n">δ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">δ</span> <span class="bp">=</span> <span class="n">ε</span><span class="bp">/</span><span class="mi">3</span><span class="o">,</span> <span class="k">from</span> <span class="n">exists_eq</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h₄</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">δ</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">hδ</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">=</span> <span class="n">ε</span><span class="bp">/</span><span class="mi">3</span><span class="o">,</span>
    <span class="c1">-- ... me 4 lines.</span>
    <span class="c1">-- Q4. What is the proof for h₅ exactly? library_search doesn&#39;t turn up anything.</span>
    <span class="k">have</span> <span class="n">h₅</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h₆</span> <span class="o">:</span> <span class="bp">∃</span><span class="n">y&#39;</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span> <span class="bp">|</span><span class="n">y</span> <span class="bp">-</span> <span class="n">y&#39;</span><span class="bp">|</span> <span class="bp">≤</span> <span class="n">δ</span><span class="o">,</span> <span class="k">from</span> <span class="n">h₃</span> <span class="n">δ</span> <span class="n">h₅</span><span class="o">,</span>
    <span class="c1">-- Q5. Is there a better way to access the two proofs (hy&#39; and h₇)? It takes ...</span>
    <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h₆</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">y&#39;</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">temp</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">temp</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">hy&#39;</span> <span class="o">:</span> <span class="n">y&#39;</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h₇</span> <span class="o">:</span> <span class="bp">|</span><span class="n">y</span> <span class="bp">-</span> <span class="n">y&#39;</span><span class="bp">|</span> <span class="bp">≤</span> <span class="n">δ</span><span class="o">,</span>
    <span class="c1">--- ... me 6 lines.</span>
    <span class="k">have</span> <span class="n">h₈</span> <span class="o">:</span> <span class="n">y&#39;</span> <span class="err">∈</span> <span class="n">closure</span><span class="o">(</span><span class="n">X</span><span class="o">),</span> <span class="k">from</span> <span class="n">h₂</span> <span class="n">hy&#39;</span><span class="o">,</span>
    <span class="c1">-- This next bit is a repeat of Q5..</span>
    <span class="k">have</span> <span class="n">h₉</span> <span class="o">:</span> <span class="bp">∃</span><span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">|</span><span class="n">y&#39;</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">|</span> <span class="bp">≤</span> <span class="n">δ</span><span class="o">,</span> <span class="k">from</span> <span class="n">h₈</span> <span class="n">δ</span> <span class="n">h₅</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h₉</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">temp</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">temp</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">hx</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h₁₀</span> <span class="o">:</span> <span class="bp">|</span><span class="n">y&#39;</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">|</span> <span class="bp">≤</span> <span class="n">δ</span><span class="o">,</span>
    <span class="c1">-- ... another 6 lines.</span>
    <span class="c1">-- Q6. I&#39;m a bit stuck on the following line. I think, what is needed is something like:</span>
    <span class="c1">--    norm_add_le_of_le (by apply_instance) h₇ h₁₀,</span>
    <span class="k">have</span> <span class="n">h₁₁</span> <span class="o">:</span> <span class="bp">|</span><span class="n">y</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">|</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">*</span><span class="n">δ</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">h₁₂</span> <span class="o">:</span> <span class="bp">|</span><span class="n">y</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">|</span> <span class="bp">≤</span> <span class="n">ε</span><span class="o">,</span> <span class="k">by</span> <span class="n">linarith</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">hx</span> <span class="n">h₁₂</span>
  <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="192352507"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192352507" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192352507">Kevin Buzzard (Mar 31 2020 at 07:22)</a>:</h4>
<p>Which version of mathlib are you using? I get an error</p>
<div class="codehilite"><pre><span></span>invalid definition, a declaration named &#39;closure&#39; has already been declared
</pre></div>


<p>on line 15, and <code>#check @closure</code> gives me</p>
<div class="codehilite"><pre><span></span>closure : Π {α : Type u_1} [_inst_1 : topological_space α], set α → set α
</pre></div>

<a name="192353801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192353801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192353801">Yury G. Kudryashov (Mar 31 2020 at 07:38)</a>:</h4>
<p>Yes, we have closure defined for any topological space, not just real numbers.</p>

<a name="192354975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192354975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192354975">Kevin Buzzard (Mar 31 2020 at 07:53)</a>:</h4>
<p>Changing <code>closure</code> to <code>closure'</code> throughout the snippet fixes it. </p>
<p><code>norm_add_le_of_le</code> is a theorem about normed groups. I don't know much about what structures are put on the real numbers, but if I write <code>have ZZZ := norm_add_le_of_le h₇ h₁₀,</code> just before your sorry then the error seems to indicate that nobody has put a normed group structure on the reals with the norm being abs, or perhaps you have not imported the file where this structure is defined.</p>

<a name="192355193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192355193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192355193">Kevin Buzzard (Mar 31 2020 at 07:55)</a>:</h4>
<p>What you need is <code>abs_add</code> I guess.</p>

<a name="192355388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192355388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192355388">Yury G. Kudryashov (Mar 31 2020 at 07:57)</a>:</h4>
<p>This structure is defined in <code>normed_space.basic</code></p>

<a name="192355399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192355399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192355399">Kevin Buzzard (Mar 31 2020 at 07:57)</a>:</h4>
<p>but I guess you can persuade <code>linarith</code> to do this:</p>
<div class="codehilite"><pre><span></span>    <span class="k">have</span> <span class="n">h₁₁</span> <span class="o">:</span> <span class="bp">|</span><span class="n">y</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">|</span> <span class="bp">≤</span> <span class="mi">2</span><span class="bp">*</span><span class="n">δ</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="n">y</span> <span class="bp">-</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="n">y</span> <span class="bp">-</span> <span class="n">y&#39;</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">y&#39;</span> <span class="bp">-</span> <span class="n">x</span><span class="o">),</span> <span class="k">by</span> <span class="n">ring</span><span class="o">),</span>
      <span class="n">linarith</span><span class="o">,</span>
</pre></div>

<a name="192355586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192355586" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192355586">Yury G. Kudryashov (Mar 31 2020 at 07:59)</a>:</h4>
<p>Actually it fails because for Lean <code>(a - b) + (b - c)</code> is not the same as <code>a - c</code></p>

<a name="192355798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192355798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192355798">Yury G. Kudryashov (Mar 31 2020 at 08:01)</a>:</h4>
<p>So, you need to either rewrite as <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> suggested, or use <code>dist</code> instead of <code>|a - b|</code>.</p>

<a name="192356191"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192356191" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192356191">Kevin Buzzard (Mar 31 2020 at 08:04)</a>:</h4>
<p>In terms of structure, I would not embark upon a big monolithic proof like this. Why is your result true? Here is a proof which only uses fundamental facts about closures. Firstly there is <code>closure_mono</code>, the fact that closure is monotonic, which is a fancy way of saying that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⊆</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\subseteq Y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>X</mi><mo stretchy="true">‾</mo></mover><mo>⊆</mo><mover accent="true"><mi>Y</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{X}\subseteq\overline{Y}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0193em;vertical-align:-0.13597em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>. Applying this to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">h_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> shows <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>X</mi><mo stretchy="true">‾</mo></mover><mo>⊆</mo><mover accent="true"><mi>Y</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{X}\subseteq\overline{Y}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0193em;vertical-align:-0.13597em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span> and applying it to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">h_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> shows <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>Y</mi><mo stretchy="true">‾</mo></mover><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\overline{Y}\subseteq</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.0193em;vertical-align:-0.13597em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span></span></span></span><code>closure(closure(X))</code>Secondly there is <code>closure_closure</code>, saying <code>closure (closure X)=closure X</code>. Applying these two facts shows inclusions in both ways so you're done. This means that the actual proof of <code>closure_squeeze</code> should be three lines long, deducing the result from these more fundamental results, whose proofs would obviously be where more of the work is. But you should try and make your proofs as modular as possible. Note that I used <code>closure_mono</code> twice in my argument above, and it would not surprise me if in some sense you prove it twice in your argument, meaning that your proof might be much longer than it should be.</p>

<a name="192359823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192359823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192359823">Kevin Doran (Mar 31 2020 at 08:43)</a>:</h4>
<p>Apologies, I did not include a namespace in my snippet. </p>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , thanks for the <code>rw</code> tip! Regarding the monolithic proof, my intention is to follow a textbook, and those closure properties you mention are later proved using this one.</p>

<a name="192359886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192359886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192359886">Kevin Doran (Mar 31 2020 at 08:44)</a>:</h4>
<p>Any thoughts on improving the section:</p>
<div class="codehilite"><pre><span></span>    <span class="c1">-- Q3. What is a better way to get a δ = ε/3? It takes...</span>
    <span class="k">have</span> <span class="n">h₄</span> <span class="o">:</span> <span class="bp">∃</span><span class="n">δ</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">,</span> <span class="n">δ</span> <span class="bp">=</span> <span class="n">ε</span><span class="bp">/</span><span class="mi">3</span><span class="o">,</span> <span class="k">from</span> <span class="n">exists_eq</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h₄</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">δ</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">hδ</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">=</span> <span class="n">ε</span><span class="bp">/</span><span class="mi">3</span><span class="o">,</span>
    <span class="c1">-- ... me 4 lines.</span>
</pre></div>

<a name="192360757"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192360757" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192360757">Kevin Buzzard (Mar 31 2020 at 08:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252241">Kevin Doran</span> <a href="#narrow/stream/113489-new-members/topic/cleaning.20up.20this.20tactic.20proof.20(regarding.20closures)/near/192359823" title="#narrow/stream/113489-new-members/topic/cleaning.20up.20this.20tactic.20proof.20(regarding.20closures)/near/192359823">said</a>:</p>
<blockquote>
<p>Regarding the monolithic proof, my intention is to follow a textbook, and those closure properties you mention are later proved using this one.</p>
</blockquote>
<p>Having spent some time reading mathlib, I would now definitely question whether mathematicians always know best when it comes to ordering of material. You might be right though, I have not thought about how to develop this sort of theory (I probably should, there has been some real number game action recently)</p>

<a name="192360836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192360836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192360836">Kevin Buzzard (Mar 31 2020 at 08:53)</a>:</h4>
<p>Chris Hughes pointed out to me that his 2nd year analysis lecturer proved the same result three times over the course of two lectures, as sublemmas or remarks in the middle of other proofs.</p>

<a name="192360928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192360928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192360928">Kevin Buzzard (Mar 31 2020 at 08:54)</a>:</h4>
<p><code>set δ := ε/3 with hδ,</code> is the way to do the delta thing perhaps.</p>

<a name="192361864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192361864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192361864">Kevin Doran (Mar 31 2020 at 09:03)</a>:</h4>
<p>I think, no matter which way you choose, at least one of them will require a delta-epsilon formulation, which is where most of my mess above comes from. </p>
<p>The other big eye sore is the double exist-elim:</p>
<div class="codehilite"><pre><span></span>    <span class="c1">-- Q5. Is there a better way to access the two proofs (hy&#39; and h₇)? It takes ...</span>
    <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h₆</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">y&#39;</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">temp</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">temp</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">hy&#39;</span> <span class="o">:</span> <span class="n">y&#39;</span> <span class="err">∈</span> <span class="n">Y</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">h₇</span> <span class="o">:</span> <span class="bp">|</span><span class="n">y</span> <span class="bp">-</span> <span class="n">y&#39;</span><span class="bp">|</span> <span class="bp">≤</span> <span class="n">δ</span><span class="o">,</span>
    <span class="c1">--- ... me 6 lines.</span>
</pre></div>


<p>This seems like such a common pattern (working with an proposition, ∃x ∈ X, &lt;something&gt;). Any thoughts on a better way?</p>

<a name="192362498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192362498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192362498">Kevin Buzzard (Mar 31 2020 at 09:08)</a>:</h4>
<p>Oh sorry -- I have only just noticed all the questions!</p>

<a name="192362675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192362675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192362675">Kevin Doran (Mar 31 2020 at 09:10)</a>:</h4>
<p>Also, I would love a real number game.</p>

<a name="192362695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192362695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192362695">Kevin Buzzard (Mar 31 2020 at 09:10)</a>:</h4>
<p>Q1 yeah I'd not bother unfolding. Q2 intro is much more common. Just above Q3: you can just do <code>intros eps heps</code>.</p>

<a name="192362815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192362815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192362815">Kevin Buzzard (Mar 31 2020 at 09:11)</a>:</h4>
<p>Q4 the proof is linarith. Maybe there is some result of the form a&gt;0 and b&gt;0 -&gt; a/b&gt;0 but then you'll still need to prove 3&gt;0 (which you can do with <code>norm_num</code>)</p>

<a name="192363013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192363013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192363013">Kevin Buzzard (Mar 31 2020 at 09:12)</a>:</h4>
<p>Q5 <code>    rcases h₆ with ⟨y', hy', h₇⟩,</code></p>

<a name="192363097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192363097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192363097">Kevin Buzzard (Mar 31 2020 at 09:13)</a>:</h4>
<p>Hopefully that's everything! <code>rcases</code> is a brilliant tactic for this sort of proof.</p>

<a name="192363199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192363199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192363199">Kevin Doran (Mar 31 2020 at 09:14)</a>:</h4>
<p>Thanks a million!</p>

<a name="192363478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192363478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192363478">Kevin Buzzard (Mar 31 2020 at 09:16)</a>:</h4>
<p>I think <code>closure_mono</code> is very simple to prove by the way. I think it's just a set-theoretic triviality</p>

<a name="192363517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192363517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192363517">Kevin Buzzard (Mar 31 2020 at 09:17)</a>:</h4>
<p>The same is true for closure_closure</p>

<a name="192363533"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192363533" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192363533">Kevin Buzzard (Mar 31 2020 at 09:17)</a>:</h4>
<p>It's just a 2epsilon proof</p>

<a name="192365038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192365038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192365038">Patrick Massot (Mar 31 2020 at 09:31)</a>:</h4>
<p>Can I vote twice for proving <code>closure_mono</code> first?</p>

<a name="192365231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192365231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192365231">Patrick Massot (Mar 31 2020 at 09:33)</a>:</h4>
<p>Everything Kevin wrote about distrusting lecture notes for this kind of things is crucial.</p>

<a name="192366556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192366556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192366556">Kevin Doran (Mar 31 2020 at 09:45)</a>:</h4>
<p>To try and argue the position of the author, <code>closure_mono</code> is fine to be proven first, no debate there. The main point of contention is between<code>closure_closure</code>, <code>closure_union</code> or the the above lemma; all follow easily from each other. So far, the author's presentation order has been illuminating.</p>

<a name="192366596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192366596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192366596">Patrick Massot (Mar 31 2020 at 09:46)</a>:</h4>
<p>I also think it's worth having a look at mathlib, even if the setup is hugely more general. <a href="https://github.com/leanprover-community/mathlib/blob/17632202cdf9682cea972e86437d32ac20c91b06/src/topology/basic.lean#L262-L319" title="https://github.com/leanprover-community/mathlib/blob/17632202cdf9682cea972e86437d32ac20c91b06/src/topology/basic.lean#L262-L319">This</a> is the sequence of lemmas you are interested in. You don't need to understand the proofs, only notice how shorts are the proofs because of the careful ordering of statements.</p>

<a name="192366737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192366737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192366737">Kevin Doran (Mar 31 2020 at 09:47)</a>:</h4>
<p>Oh, yea, that's a great spot to study. I went looking before, but I got a bit lost.</p>

<a name="192368057"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192368057" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192368057">Kevin Buzzard (Mar 31 2020 at 09:59)</a>:</h4>
<p><span class="user-mention" data-user-id="252241">@Kevin Doran</span> do you see how natural the proof below is?</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">closure&#39;_mono</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hXY</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">closure&#39;</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">closure&#39;</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="c1">--λ a haX ε hε, ⟨_, hXY haX, _⟩ #exit</span>
<span class="c1">--⟨(haX ε hε).1 _⟩</span>
<span class="k">begin</span>
  <span class="c1">-- Say a is in the closure of X. We want to show a is in the closure of Y.</span>
  <span class="c1">-- So say ε &gt; 0. We want to find y ∈ Y such that |a - y| ≤ ε.</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">haX</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
  <span class="c1">-- By definition of closure of X, there&#39;s x ∈ X with |a - x| ≤ ε.</span>
  <span class="n">rcases</span> <span class="n">haX</span> <span class="n">ε</span> <span class="n">hε</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">haX&#39;</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="c1">-- So let y be x.</span>
  <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
  <span class="c1">-- Remark:</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- x is in Y because it&#39;s in X and X ⊆ Y</span>
    <span class="n">exact</span> <span class="n">hXY</span> <span class="n">haX&#39;</span><span class="o">,</span> <span class="c1">-- hXY is actually a function!</span>
  <span class="o">},</span>
  <span class="c1">-- oh but now one of our assumptions is the conclusion</span>
  <span class="n">assumption</span>
<span class="kn">end</span>
</pre></div>

<a name="192368216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192368216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192368216">Kevin Buzzard (Mar 31 2020 at 10:00)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">closure&#39;_mono</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hXY</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">closure&#39;</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">closure&#39;</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">haX</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span> <span class="bp">⟨_</span><span class="o">,</span> <span class="bp">_⟩</span>
</pre></div>


<p>Can you write the proof in term mode?</p>

<a name="192368229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192368229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192368229">Kevin Buzzard (Mar 31 2020 at 10:00)</a>:</h4>
<p>The only tactics this proof uses are trivialities.</p>

<a name="192368384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192368384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192368384">Kevin Buzzard (Mar 31 2020 at 10:02)</a>:</h4>
<p>Monotonocity is a really natural thing to look for -- we are saying monotonicity is a morphism of posets.</p>

<a name="192368413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192368413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192368413">Kevin Buzzard (Mar 31 2020 at 10:02)</a>:</h4>
<p>The squeeze lemma you are trying to prove has a much uglier statement.</p>

<a name="192368453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192368453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192368453">Kevin Buzzard (Mar 31 2020 at 10:02)</a>:</h4>
<p>Formalising reveals an underlying elegance which humans often miss.</p>

<a name="192368633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192368633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192368633">Kevin Buzzard (Mar 31 2020 at 10:04)</a>:</h4>
<p>closure_closure is the statement that a morphism is idempotent. This is also a much more natural statement than the squeeze lemma.</p>

<a name="192368907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192368907" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192368907">Patrick Massot (Mar 31 2020 at 10:08)</a>:</h4>
<p>Why do you tag all your definitions as reducible?</p>

<a name="192368947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192368947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192368947">Patrick Massot (Mar 31 2020 at 10:08)</a>:</h4>
<p>This is very rarely a good idea, and should certainly not be used when you don't understand what it means.</p>

<a name="192369222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192369222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192369222">Kevin Doran (Mar 31 2020 at 10:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>,  that is far more elegant! </p>
<p>Also agreed that the squeeze statement is pretty ugly in itself.</p>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> , ah I forgot to take that out. I was just playing with the feature to see what it does.</p>

<a name="192369658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192369658" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192369658">Kevin Buzzard (Mar 31 2020 at 10:16)</a>:</h4>
<p>It is kind of annoying that <code>#print closure'_mono</code> gives a term</p>
<div class="codehilite"><pre><span></span>theorem closure&#39;_mono : ∀ {X Y : set ℝ}, X ⊆ Y → closure&#39; X ⊆ closure&#39; Y :=
λ {X Y : set ℝ} (hXY : X ⊆ Y),
  id
    (λ (a : ℝ) (haX : a ∈ closure&#39; X),
       id
         (λ (ε : ℝ) (hε : ε &gt; 0),
            Exists.dcases_on (haX ε hε)
              (λ (x : ℝ) (h : ∃ (H : x ∈ X), |a - x| ≤ ε),
                 Exists.dcases_on h
                   (λ (haX&#39; : x ∈ X) (h : |a - x| ≤ ε),
                      Exists.intro x (id (exists_prop.mpr ⟨hXY haX&#39;, h⟩))))))
</pre></div>


<p>in the pretty printer which does not then compile. I was finding it hard to eliminate the cases in term mode too.</p>

<a name="192369922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192369922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192369922">Patrick Massot (Mar 31 2020 at 10:19)</a>:</h4>
<p>In term mode the <code>rcases</code> becomes a <code>let</code>.</p>

<a name="192370015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192370015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192370015">Patrick Massot (Mar 31 2020 at 10:20)</a>:</h4>
<p>I'm only half paying attention, do you want me to post the proof term or is it an exercise for the new Kevin?</p>

<a name="192370403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192370403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192370403">Kevin Buzzard (Mar 31 2020 at 10:25)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">infix</span> <span class="bp">`</span><span class="n">is_adherent_to</span><span class="bp">`</span> <span class="o">:</span><span class="mi">55</span> <span class="o">:=</span> <span class="n">is_adherent</span>
</pre></div>


<p><del>I definitely think you should choose one or the other.</del> Oh I see it's the infix, but don't we want better notation? Is this what they say in French?</p>

<a name="192370711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192370711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192370711">Patrick Massot (Mar 31 2020 at 10:29)</a>:</h4>
<p>It does look like a literal translation from French.</p>

<a name="192370818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192370818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192370818">Patrick Massot (Mar 31 2020 at 10:30)</a>:</h4>
<p>In the beginning I was also defining a lot of infix notation to make the assumption look like proper sentences, but then I quickly realized this was unsustainable. I don't even do it in my teaching because this obfuscate <code>unfold</code> lines (that have to refer the the actual name, not the notation).</p>

<a name="192370842"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192370842" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192370842">Patrick Massot (Mar 31 2020 at 10:31)</a>:</h4>
<p>The proof term should be <code>assume a haX ε hε, let ⟨x, haX, h⟩ := haX ε hε in ⟨x, hXY haX, h⟩</code> by the way.</p>

<a name="192370925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192370925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192370925">Kevin Buzzard (Mar 31 2020 at 10:32)</a>:</h4>
<p>Is there a way of writing this without the <code>let</code>?</p>

<a name="192371003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192371003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192371003">Kevin Buzzard (Mar 31 2020 at 10:33)</a>:</h4>
<p>It did not occur to me to use <code>let</code>. I never normally use it, I think it obfuscates goals. When there are <code>let</code>s around, tactic mode proofs can start getting ugly goals.</p>

<a name="192408764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192408764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192408764">Kevin Buzzard (Mar 31 2020 at 15:50)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>
<span class="kn">import</span> <span class="n">analysis</span><span class="bp">.</span><span class="n">normed_space</span><span class="bp">.</span><span class="n">basic</span>

<span class="c1">-- Q0. Notation for absolute. Should I reuse this from somewhere in Lean or mathlib?</span>
<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`|`</span><span class="n">x</span><span class="bp">`|`</span> <span class="o">:=</span> <span class="n">abs</span> <span class="n">x</span>

<span class="n">def</span> <span class="n">is_adherent</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">∃</span><span class="n">y</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">|</span><span class="n">x</span> <span class="bp">-</span> <span class="n">y</span><span class="bp">|</span> <span class="bp">≤</span> <span class="n">ε</span>

<span class="kn">infix</span> <span class="bp">`</span><span class="n">is_adherent_to</span><span class="bp">`</span> <span class="o">:</span><span class="mi">55</span> <span class="o">:=</span> <span class="n">is_adherent</span>

<span class="n">def</span> <span class="n">closure&#39;</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">|</span> <span class="n">x</span> <span class="n">is_adherent_to</span> <span class="n">X</span> <span class="o">}</span>

<span class="c1">-- closure_mono term proof</span>

<span class="c">/-</span><span class="cm">- If $$X\subseteq Y$$ then $$\overline{X}\subseteq\overline{Y}$$ -/</span>
<span class="kn">theorem</span> <span class="n">closure&#39;_mono</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hXY</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">closure&#39;</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">closure&#39;</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">haX</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">haX&#39;</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">haX</span> <span class="n">ε</span> <span class="n">hε</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hXY</span> <span class="n">haX&#39;</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span>

<span class="c1">-- closure_mono tactic proof</span>
<span class="kn">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">hXY</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">closure&#39;</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">closure&#39;</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- Say a is in the closure of X. We want to show a is in the closure of Y.</span>
  <span class="c1">-- So say ε &gt; 0. We want to find y ∈ Y such that |a - y| ≤ ε.</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">haX</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
  <span class="c1">-- By definition of closure of X, there&#39;s x ∈ X with |a - x| ≤ ε.</span>
  <span class="n">rcases</span> <span class="n">haX</span> <span class="n">ε</span> <span class="n">hε</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">haX&#39;</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="c1">-- So let y be x.</span>
  <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
  <span class="c1">-- Remark:</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- x is in Y because it&#39;s in X and X ⊆ Y</span>
    <span class="n">exact</span> <span class="n">hXY</span> <span class="n">haX&#39;</span><span class="o">,</span> <span class="c1">-- hXY is actually a function!</span>
  <span class="o">},</span>
  <span class="c1">-- oh but now one of our assumptions is the conclusion</span>
  <span class="n">assumption</span>
<span class="kn">end</span>

<span class="c1">-- subset_closure term proof</span>

<span class="c">/-</span><span class="cm">- For all subsets $$X$$ of $$\mathbb{R}$$, we have $$X\subseteq\overline{X}$$ -/</span>
<span class="kn">lemma</span> <span class="n">subset_closure&#39;</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">closure&#39;</span> <span class="n">X</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">le_of_lt</span> <span class="o">(</span><span class="k">by</span> <span class="n">rwa</span> <span class="o">[</span><span class="n">sub_self</span><span class="o">,</span> <span class="n">abs_zero</span><span class="o">])</span><span class="bp">⟩</span>

<span class="c1">-- tactic proof</span>

<span class="kn">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">closure&#39;</span> <span class="n">X</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- Say x ∈ X and ε &gt; 0.</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">hx</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
  <span class="c1">-- We need to find y ∈ X with |x - y| ≤ ε. Just use x.</span>
  <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
  <span class="c1">-- Remark: x ∈ X</span>
  <span class="n">split</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hx</span><span class="o">,</span>
  <span class="c1">-- Note also that |x - x| is obviously zero</span>
  <span class="n">simp</span><span class="o">,</span>
  <span class="c1">-- and because ε &gt; 0 we&#39;re done</span>
  <span class="n">exact</span> <span class="n">le_of_lt</span> <span class="n">hε</span>
  <span class="c1">-- Note that that last bit would have been better if your definition of closure&#39;</span>
  <span class="c1">-- had used &lt; and not ≤</span>
<span class="kn">end</span>

<span class="c1">-- closure_closure</span>

<span class="c1">-- Note: for some reason this is not formalaised as `closure ∘ closure = closure`</span>
<span class="c1">-- I don&#39;t know why we have this convention</span>

<span class="c1">-- tactic mode proof</span>

<span class="c">/-</span><span class="cm">- The closure of $$\overline{X}$$ is $$\overline{X}$$ again -/</span>
<span class="kn">lemma</span> <span class="n">closure&#39;_closure&#39;</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">closure&#39;</span> <span class="o">(</span><span class="n">closure&#39;</span> <span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="n">closure&#39;</span> <span class="n">X</span> <span class="o">:=</span> <span class="c1">--</span>
<span class="k">begin</span>
  <span class="c1">-- We prove inclusions in both directions</span>
  <span class="n">ext</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="c1">--</span>
  <span class="o">{</span> <span class="c1">-- ⊆ : say $$a$$ is in the closure of $$\overline{X}$$.</span>
    <span class="n">intro</span> <span class="n">ha</span><span class="o">,</span>
    <span class="c1">-- We want to show it&#39;s in $$\overline{X}$$ so say ε &gt; 0, and we want x with |x-a| ≤ ε</span>
    <span class="n">intros</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
    <span class="c1">-- By definition of a, there&#39;s some elements $$b\in\overline{X}$$</span>
    <span class="c1">-- with |a - b| ≤ ε/2</span>
    <span class="n">rcases</span> <span class="n">ha</span> <span class="o">(</span><span class="n">ε</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="k">by</span> <span class="n">linarith</span><span class="o">)</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">b</span><span class="o">,</span> <span class="n">hb</span><span class="o">,</span> <span class="n">hab</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="c1">-- and by definition of b there&#39;s some x ∈ X with |b - x| ≤ ε/2</span>
    <span class="n">rcases</span> <span class="n">hb</span> <span class="o">(</span><span class="n">ε</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="k">by</span> <span class="n">linarith</span><span class="o">)</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="o">,</span> <span class="n">hbx</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="c1">-- Let&#39;s use this x</span>
    <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
    <span class="c1">-- Note it&#39;s obviously in X</span>
    <span class="n">split</span><span class="o">,</span> <span class="n">exact</span> <span class="n">hx</span><span class="o">,</span>
    <span class="c1">-- and now |a - x| = |(a - b) + (b - x)|</span>
    <span class="k">calc</span> <span class="bp">|</span><span class="n">a</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">|</span> <span class="bp">=</span> <span class="bp">|</span><span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">b</span> <span class="bp">-</span> <span class="n">x</span><span class="o">)</span><span class="bp">|</span> <span class="o">:</span> <span class="k">by</span> <span class="n">ring</span>
                   <span class="c1">-- ≤ ε/2 + ε/2 = ε</span>
    <span class="bp">...</span>          <span class="bp">≤</span> <span class="bp">|</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="bp">|</span> <span class="bp">+</span> <span class="bp">|</span><span class="n">b</span> <span class="bp">-</span> <span class="n">x</span><span class="bp">|</span>   <span class="o">:</span> <span class="k">by</span> <span class="n">apply</span> <span class="n">abs_add</span>
    <span class="bp">...</span>          <span class="bp">≤</span> <span class="n">ε</span> <span class="o">:</span> <span class="k">by</span> <span class="n">linarith</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- ⊇ : follows immediately from subset_closure&#39;</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">apply</span> <span class="n">subset_closure&#39;</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kn">end</span>

<span class="c1">-- closure_squeeze term mode proof</span>
<span class="kn">lemma</span> <span class="n">closure&#39;_squeeze</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">Y</span> <span class="err">⊆</span> <span class="n">closure&#39;</span><span class="o">(</span><span class="n">X</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">closure&#39;</span><span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="n">closure&#39;</span><span class="o">(</span><span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">antisymm</span> <span class="o">(</span><span class="n">closure&#39;_mono</span> <span class="n">h₁</span><span class="o">)</span> <span class="err">$</span> <span class="k">by</span> <span class="n">rw</span> <span class="err">←</span><span class="n">closure&#39;_closure&#39;</span> <span class="n">X</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">closure&#39;_mono</span> <span class="n">h₂</span>

<span class="c1">-- tactic mode proof</span>
<span class="kn">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">Y</span> <span class="err">⊆</span> <span class="n">closure&#39;</span><span class="o">(</span><span class="n">X</span><span class="o">))</span> <span class="o">:</span>
  <span class="n">closure&#39;</span><span class="o">(</span><span class="n">X</span><span class="o">)</span> <span class="bp">=</span> <span class="n">closure&#39;</span><span class="o">(</span><span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="c1">-- We prove inclusions in both directions</span>
  <span class="n">apply</span> <span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">antisymm</span><span class="o">,</span>
  <span class="o">{</span> <span class="c1">-- ⊆ is just closure&#39;_mono</span>
    <span class="n">apply</span> <span class="n">closure&#39;_mono</span> <span class="n">h₁</span><span class="o">},</span>
  <span class="o">{</span> <span class="c1">-- ⊇ -- first use closure&#39;_closure&#39;</span>
    <span class="n">rw</span> <span class="err">←</span><span class="n">closure&#39;_closure&#39;</span> <span class="n">X</span><span class="o">,</span>
    <span class="c1">-- and then it follows from closure&#39;_mono</span>
    <span class="n">apply</span> <span class="n">closure&#39;_mono</span> <span class="n">h₂</span><span class="o">},</span>
<span class="kn">end</span>
</pre></div>


<p><span class="user-mention" data-user-id="252241">@Kevin Doran</span></p>

<a name="192409166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192409166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192409166">Reid Barton (Mar 31 2020 at 15:53)</a>:</h4>
<p>I think "destructuring <code>let</code>" (with a pattern match on the left) doesn't actually translate to a <code>let</code> in the usual sense.</p>

<a name="192409263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192409263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192409263">Kevin Buzzard (Mar 31 2020 at 15:53)</a>:</h4>
<p>I think the more mathematically natural definition of adherent is</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">is_adherent</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">∃</span><span class="n">y</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">|</span><span class="n">x</span> <span class="bp">-</span> <span class="n">y</span><span class="bp">|</span> <span class="bp">&lt;</span> <span class="n">ε</span>
</pre></div>


<p>This is because eps &gt; 0 and not eps &gt;= 0.</p>

<a name="192409425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192409425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192409425">Kevin Buzzard (Mar 31 2020 at 15:54)</a>:</h4>
<p>I hadn't realised that one needed <code>let</code>. I was just trying to do <code>(haX ε hε).1</code> and it wouldn't work.</p>

<a name="192409571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192409571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192409571">Reid Barton (Mar 31 2020 at 15:55)</a>:</h4>
<p>Assuming this is referring to a Prop, there's no reason to avoid this kind of <code>let</code>. If you put <code>_</code> after <code>in</code> and put your cursor on it you'll see the context is the same as it would be in a tactic proof where you used <code>rcases</code>.</p>

<a name="192409708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192409708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192409708">Reid Barton (Mar 31 2020 at 15:56)</a>:</h4>
<p>Although if you used a "true" <code>let</code> I don't know what the context would look like, actually. But this kind of <code>let</code> must just be translated to an application of the recursor.</p>

<a name="192409739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192409739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192409739">Reid Barton (Mar 31 2020 at 15:57)</a>:</h4>
<p>(Maybe multiple applications of recursors.)</p>

<a name="192410023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192410023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192410023">Kevin Buzzard (Mar 31 2020 at 15:59)</a>:</h4>
<p>I hadn't realised this. Thanks!</p>

<a name="192611028"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192611028" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192611028">Kevin Doran (Apr 02 2020 at 01:07)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> , the example is beautiful, thanks. It's funny to look back now at my original  monolith.</p>

<a name="192620772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192620772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192620772">Kevin Doran (Apr 02 2020 at 04:50)</a>:</h4>
<p>I have a follow up question. I'm posting it in the existing thread due to the shared context of closures.</p>
<p>When proving a conjunction where both conjuncts share a common quantifier and assumption, can the quantifier and assumption be introduced before the proof splits?</p>
<p>Concrete example below: </p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>

<span class="kn">namespace</span> <span class="n">my_closure</span>

<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`|`</span><span class="n">x</span><span class="bp">`|`</span> <span class="o">:=</span> <span class="n">abs</span> <span class="n">x</span>

<span class="n">def</span> <span class="n">is_adherent</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="n">ε</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">∃</span><span class="n">y</span> <span class="err">∈</span> <span class="n">X</span><span class="o">,</span> <span class="bp">|</span><span class="n">x</span> <span class="bp">-</span> <span class="n">y</span><span class="bp">|</span> <span class="bp">&lt;</span> <span class="n">ε</span>

<span class="n">def</span> <span class="n">closure</span><span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">|</span> <span class="n">is_adherent</span> <span class="n">x</span> <span class="n">X</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">closure_inter_subset_inter_closure&#39;</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
<span class="n">closure</span> <span class="o">(</span><span class="n">X</span> <span class="err">∩</span> <span class="n">Y</span><span class="o">)</span> <span class="err">⊆</span> <span class="n">closure</span> <span class="n">X</span> <span class="err">∩</span> <span class="n">closure</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span>
    <span class="n">intros</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
    <span class="n">rcases</span> <span class="n">ha</span> <span class="n">ε</span> <span class="n">hε</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">xy</span><span class="o">,</span> <span class="n">hxy</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
    <span class="n">use</span> <span class="n">xy</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hxy</span> <span class="k">with</span> <span class="n">l</span> <span class="n">r</span><span class="o">,</span>
    <span class="n">split</span><span class="bp">;</span> <span class="n">assumption</span>
  <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">end</span> <span class="n">my_closure</span>
</pre></div>


<p>It want to know how to prove the above without a repeat—have something like a <code>intros a ha ε hε</code> at the begging, <em>then</em> split the conjunction.</p>

<a name="192624118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192624118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192624118">Kevin Buzzard (Apr 02 2020 at 06:09)</a>:</h4>
<p>I've seen people write things like <code>split; intro h</code> before but I never thought it was particularly good style</p>

<a name="192624125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192624125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192624125">Kevin Buzzard (Apr 02 2020 at 06:10)</a>:</h4>
<p>This way the intro gets applied to both strands of the proof</p>

<a name="192625350"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192625350" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192625350">Kevin Doran (Apr 02 2020 at 06:38)</a>:</h4>
<p>[In the right stream this time]</p>
<p>Ah, I see. They it could be taken to the extreme and have all tactics apply to both strands:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">closure_inter_subset_inter_closure</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
<span class="n">closure</span> <span class="o">(</span><span class="n">X</span> <span class="err">∩</span> <span class="n">Y</span><span class="o">)</span> <span class="err">⊆</span> <span class="n">closure</span> <span class="n">X</span> <span class="err">∩</span> <span class="n">closure</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">split</span><span class="bp">;</span>
  <span class="n">intros</span> <span class="n">ε</span> <span class="n">hε</span><span class="bp">;</span>
  <span class="n">rcases</span> <span class="n">ha</span> <span class="n">ε</span> <span class="n">hε</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">xy</span><span class="o">,</span> <span class="n">hxy</span><span class="o">,</span> <span class="n">h₁</span><span class="bp">⟩;</span>
  <span class="n">use</span> <span class="n">xy</span><span class="bp">;</span>
  <span class="n">cases</span> <span class="n">hxy</span><span class="bp">;</span>
  <span class="n">split</span><span class="bp">;</span>
  <span class="n">assumption</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>This too falls into the category of being questionable style? Are there other alternatives (other than repeat)?</p>

<a name="192625784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192625784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192625784">Kenny Lau (Apr 02 2020 at 06:46)</a>:</h4>
<p>if "style" means mathlib style:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">closure_mono</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span> <span class="n">closure</span> <span class="n">X</span> <span class="err">⊆</span> <span class="n">closure</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">a</span> <span class="n">ha</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span> <span class="k">let</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hpx</span><span class="o">,</span> <span class="n">hapε</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">ha</span> <span class="n">ε</span> <span class="n">hε</span> <span class="k">in</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H</span> <span class="n">hpx</span><span class="o">,</span> <span class="n">hapε</span><span class="bp">⟩</span>

<span class="kn">lemma</span> <span class="n">closure_inter_subset_inter_closure&#39;</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">closure</span> <span class="o">(</span><span class="n">X</span> <span class="err">∩</span> <span class="n">Y</span><span class="o">)</span> <span class="err">⊆</span> <span class="n">closure</span> <span class="n">X</span> <span class="err">∩</span> <span class="n">closure</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="n">set</span><span class="bp">.</span><span class="n">subset_inter</span>
  <span class="o">(</span><span class="n">closure_mono</span> <span class="err">$</span> <span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>
  <span class="o">(</span><span class="n">closure_mono</span> <span class="err">$</span> <span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="n">X</span> <span class="n">Y</span><span class="o">)</span>
</pre></div>

<a name="192625822"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192625822" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192625822">Kenny Lau (Apr 02 2020 at 06:47)</a>:</h4>
<p>and if you insist on using tactics, you can still have the lemma</p>

<a name="192629115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192629115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192629115">Kevin Doran (Apr 02 2020 at 07:30)</a>:</h4>
<p>That's pretty. I wish the proofs would come to mind like that, and not as hacks with epsilons.</p>

<a name="192630073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192630073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192630073">Kevin Buzzard (Apr 02 2020 at 07:44)</a>:</h4>
<p>You want to move away from the epsilons as soon as possible. This is the whole point of proving things such as <code>closure_mono</code>. There might be a few basic properties such as <code>closure_mono</code> which ultimately end up defining all the key features of your <code>closure</code> function. It's probably something like a Galois insertion or something -- some very abstract combinatorial definition which implies a whole bunch of properties which a mathematician might try and prove with epsilons.</p>

<a name="192630390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192630390" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192630390">Kevin Doran (Apr 02 2020 at 07:48)</a>:</h4>
<p>That's become very apparent to me.</p>

<a name="192630916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192630916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192630916">Reid Barton (Apr 02 2020 at 07:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="252241">Kevin Doran</span> <a href="#narrow/stream/113489-new-members/topic/cleaning.20up.20this.20tactic.20proof.20(regarding.20closures)/near/192625350" title="#narrow/stream/113489-new-members/topic/cleaning.20up.20this.20tactic.20proof.20(regarding.20closures)/near/192625350">said</a>:</p>
<blockquote>
<p>[In the right stream this time]<br>
This too falls into the category of being questionable style? Are there other alternatives (other than repeat)?</p>
</blockquote>
<p>After <code>split;</code>, use <code>{ }</code>.</p>

<a name="192631332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/cleaning%20up%20this%20tactic%20proof%20%28regarding%20closures%29/near/192631332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/12529cleaningupthistacticproofregardingclosures.html#192631332">Kevin Doran (Apr 02 2020 at 07:59)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span>, that's better.<br>
Posting the tweaked code for reference.</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">closure_inter_subset_inter_closure</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
<span class="n">closure</span> <span class="o">(</span><span class="n">X</span> <span class="err">∩</span> <span class="n">Y</span><span class="o">)</span> <span class="err">⊆</span> <span class="n">closure</span> <span class="n">X</span> <span class="err">∩</span> <span class="n">closure</span> <span class="n">Y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">ha</span><span class="o">,</span>
  <span class="n">split</span><span class="bp">;</span> <span class="o">{</span>
  <span class="n">intros</span> <span class="n">ε</span> <span class="n">hε</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">ha</span> <span class="n">ε</span> <span class="n">hε</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">xy</span><span class="o">,</span> <span class="n">hxy</span><span class="o">,</span> <span class="n">h₁</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">xy</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">hxy</span><span class="o">,</span>
  <span class="n">split</span><span class="bp">;</span>
  <span class="n">assumption</span><span class="o">,</span>
  <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


{% endraw %}

{% include archive_update.html %}