---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/79918notopic.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html">(no topic)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="123002439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123002439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123002439">Andrew Ashworth (Feb 26 2018 at 16:14)</a>:</h4>
<p>This message has no topic</p>

<a name="123002488"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123002488" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123002488">Andrew Ashworth (Feb 26 2018 at 16:14)</a>:</h4>
<p>yes, you need to reply to threads explicitly, but small questions need not have their own topic, it seems</p>

<a name="123002561"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123002561" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123002561">Andrew Ashworth (Feb 26 2018 at 16:16)</a>:</h4>
<p>previously people were doing @person | quote "..." and then their reply</p>

<a name="123002571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123002571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123002571">Andrew Ashworth (Feb 26 2018 at 16:16)</a>:</h4>
<p>this is definitely better for a larger chat room. which hopefully will happen since Lean is going to be super popular</p>

<a name="123002590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123002590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123002590">Sebastian Ullrich (Feb 26 2018 at 16:17)</a>:</h4>
<p>I mean, the Gitter one is already larger than I can care to follow</p>

<a name="123002682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123002682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123002682">Andrew Ashworth (Feb 26 2018 at 16:19)</a>:</h4>
<p>are you ferinko</p>

<a name="123002699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123002699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123002699">Simon Hudon (Feb 26 2018 at 16:19)</a>:</h4>
<p>I was going to ask that! It will be weird referring to people by name instead of handle</p>

<a name="123002750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123002750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123002750">Patrick Massot (Feb 26 2018 at 16:20)</a>:</h4>
<p>Hi everyone!</p>

<a name="123002751"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123002751" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123002751">Andrew Ashworth (Feb 26 2018 at 16:20)</a>:</h4>
<p>well, Moses isn't actually his name either, haha</p>

<a name="123002793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123002793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123002793">Andrew Ashworth (Feb 26 2018 at 16:21)</a>:</h4>
<p>well, this is just the new members room, I didn't want to pollute #general with off topic comments</p>

<a name="123002797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123002797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123002797">Moses Schönfinkel (Feb 26 2018 at 16:21)</a>:</h4>
<p>It is?</p>

<a name="123002867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123002867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123002867">Moses Schönfinkel (Feb 26 2018 at 16:23)</a>:</h4>
<p>Interesting. I was apparently using the "all messages" tab which somehow forwarded to New Members automatically.</p>

<a name="123005614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123005614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123005614">Kevin Buzzard (Feb 26 2018 at 17:37)</a>:</h4>
<p>Well this is very modern.</p>

<a name="123005621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123005621" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123005621">Kevin Buzzard (Feb 26 2018 at 17:37)</a>:</h4>
<p>I had trouble logging in with github, I had to go back a forth a while, but we got there in the end</p>

<a name="123005744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123005744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123005744">Sebastian Ullrich (Feb 26 2018 at 17:40)</a>:</h4>
<p>The design isn't exactly modern <span class="emoji emoji-1f606" title="laughing">:laughing:</span> . But other than that, I like it.</p>

<a name="123005767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123005767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123005767">Andrew Ashworth (Feb 26 2018 at 17:41)</a>:</h4>
<p>i wonder if there's an option to customize the css styling anywhere</p>

<a name="123008714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123008714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123008714">Sean Leather (Feb 26 2018 at 19:05)</a>:</h4>
<p>I also had trouble registering and signing in. Had to figure out which cookies to allow.</p>

<a name="123008724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123008724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123008724">Sean Leather (Feb 26 2018 at 19:05)</a>:</h4>
<p>What does the gray text mean?</p>

<a name="123008774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123008774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123008774">Sean Leather (Feb 26 2018 at 19:06)</a>:</h4>
<p>Oh, I think I see. It's a different channel?</p>

<a name="123008778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123008778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123008778">Andrew Ashworth (Feb 26 2018 at 19:06)</a>:</h4>
<p>everything on zulip is filtered by topic and stream</p>

<a name="123008794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123008794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123008794">Sean Leather (Feb 26 2018 at 19:07)</a>:</h4>
<p>Yeah, it's confusing to see different streams interleaved on one page.</p>

<a name="123008810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123008810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123008810">Simon Hudon (Feb 26 2018 at 19:07)</a>:</h4>
<p>If you click on a topic, you'll only see the messages that belong to that topic</p>

<a name="123008811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123008811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123008811">Andrew Ashworth (Feb 26 2018 at 19:08)</a>:</h4>
<p>probably want to deselect "all messages" at the top left of your screen then</p>

<a name="123008872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123008872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123008872">Andrew Ashworth (Feb 26 2018 at 19:09)</a>:</h4>
<p>zulip is what i think happened when a bulletin board and irc server had a lovechild</p>

<a name="123008884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123008884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123008884">Sean Leather (Feb 26 2018 at 19:09)</a>:</h4>
<p>It's the <a class="stream" data-stream-id="113489" href="/#narrow/stream/113489-new-members">#new members</a> view that I'm on. I don't yet know what topics I'm interested in, so I'm not sure which ones to look at.</p>

<a name="123008946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123008946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123008946">Sean Leather (Feb 26 2018 at 19:10)</a>:</h4>
<p>I don't see a way to merge topics. That would probably help.</p>

<a name="123008955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123008955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123008955">Andrew Ashworth (Feb 26 2018 at 19:10)</a>:</h4>
<p>if topics share something in common they should probably be filtered at the stream level</p>

<a name="123008970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123008970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123008970">Sean Leather (Feb 26 2018 at 19:11)</a>:</h4>
<p>Ah, so <a class="stream" data-stream-id="113489" href="/#narrow/stream/113489-new-members">#new members</a> is a “stream,” and it has multiple “topics.” Now the terminology is coming together in my head.</p>

<a name="123009044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123009044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123009044">Sean Leather (Feb 26 2018 at 19:13)</a>:</h4>
<p>And I'm too tired to fully comprehend anything else about Zulip right now. I'm sure I'll find lots of messages in the morning. Good night!</p>

<a name="123011348"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123011348" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123011348">Chris Hughes (Feb 26 2018 at 20:15)</a>:</h4>
<p>I like the generated profile pictures here.</p>

<a name="123011404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/123011404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#123011404">Patrick Massot (Feb 26 2018 at 20:16)</a>:</h4>
<p>You can still use the opportunity to brighten your previous profile picture before uploading</p>

<a name="132327674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132327674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132327674">JIANXIONG SUN (Aug 17 2018 at 21:20)</a>:</h4>
<p>Can someone help me with the Jacobian Identity, there are so many brackets, how can I easily  expand all the brackets ?</p>
<p>And how can I use a+b+c = (a+b)+c, the add_assoc can only prove a+b+c=a+(b+c)</p>
<div class="codehilite"><pre><span></span>structure vector (R : Type) :=
vec :: (x : R) (y : R) (z : R)


namespace vector

variables {R : Type} [comm_ring R]

def zero : vector R := vec 0 0 0

def add (a b : vector R) :=
vec (a.x + b.x) (a.y + b.y) (a.z + b.z)

def cross_prod (a b : vector R) :=
vec (a.y * b.z - a.z * b.y) (a.x * b.z - a.z * b.x) (a.x * b.y - a.y * b.x)

theorem jacobian : ∀ (a b c: vector R) ,
 add (cross_prod a (cross_prod b c)) (add (cross_prod b (cross_prod c a))  (cross_prod c (cross_prod a b))) = zero :=
begin
  intro a,
  intro b,
  intro c,
  unfold add,
  unfold cross_prod,
  unfold zero,
  dsimp,
  congr,
  simp,
  rw mul_add,
  rw add_comm,
  rw mul_add,
  rw add_comm,
  rw add_assoc,

end
end vector
</pre></div>

<a name="132327886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132327886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132327886">Patrick Massot (Aug 17 2018 at 21:24)</a>:</h4>
<p>Are you willing to use mathlib?</p>

<a name="132327905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132327905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132327905">Patrick Massot (Aug 17 2018 at 21:25)</a>:</h4>
<p>If yes then you can preface the file with <code>import tactic.ring</code>, and right after <code>unfold_zero</code>, write <code>ring, tauto</code> and be done</p>

<a name="132328071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132328071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132328071">JIANXIONG SUN (Aug 17 2018 at 21:29)</a>:</h4>
<p>It's a good method, but actually I want to show the steps of the proof :-)</p>

<a name="132328213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132328213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132328213">Chris Hughes (Aug 17 2018 at 21:32)</a>:</h4>
<p><code>a + b + c</code> is definitionally equal to <code>(a + b) + c</code>, the pretty printer doesn't display the brackets since they are unnecessary.</p>

<a name="132328249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132328249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132328249">Patrick Massot (Aug 17 2018 at 21:33)</a>:</h4>
<p>it's more than definitional equality (!) it's parsing</p>

<a name="132328299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132328299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132328299">Patrick Massot (Aug 17 2018 at 21:34)</a>:</h4>
<p>(deleted)</p>

<a name="132329271"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132329271" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132329271">Kenny Lau (Aug 17 2018 at 21:56)</a>:</h4>
<p>how do we call that type of equality?</p>

<a name="132329309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132329309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132329309">Patrick Massot (Aug 17 2018 at 21:57)</a>:</h4>
<p>it's what the parser parses</p>

<a name="132329353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132329353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132329353">Sebastian Ullrich (Aug 17 2018 at 21:58)</a>:</h4>
<p>Structural equality</p>

<a name="132329367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132329367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132329367">Patrick Massot (Aug 17 2018 at 21:58)</a>:</h4>
<p>yeah, sounds more impressive</p>

<a name="132329393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132329393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132329393">Kenny Lau (Aug 17 2018 at 21:59)</a>:</h4>
<p>why "structure"?</p>

<a name="132329437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132329437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132329437">Patrick Massot (Aug 17 2018 at 22:00)</a>:</h4>
<p>why not "ontological equality"?</p>

<a name="132329453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132329453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132329453">Chris Hughes (Aug 17 2018 at 22:00)</a>:</h4>
<p>How many degrees of equality are there?</p>

<a name="132329458"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132329458" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132329458">Sebastian Ullrich (Aug 17 2018 at 22:00)</a>:</h4>
<p>Because the terms' structure as a tree of constructors is the same. See "structural induction", which is induction over that tree.</p>

<a name="132329537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132329537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132329537">Chris Hughes (Aug 17 2018 at 22:03)</a>:</h4>
<p>What type of equality do terms need to be for <code>rw</code> to work? I think that's slightly weaker than structural equality since it unfold reducibles</p>

<a name="132418938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132418938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132418938">JIANXIONG SUN (Aug 19 2018 at 20:19)</a>:</h4>
<p>Why there is always excessive memory when I import something?Is it the problem of the computer <a href="/user_uploads/3121/A5DMKvrZ-TiBq78T4TN4rsi_/Capture.PNG" target="_blank" title="Capture.PNG">Capture.PNG</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/A5DMKvrZ-TiBq78T4TN4rsi_/Capture.PNG" target="_blank" title="Capture.PNG"><img src="/user_uploads/3121/A5DMKvrZ-TiBq78T4TN4rsi_/Capture.PNG"></a></div>

<a name="132419069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132419069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132419069">Patrick Massot (Aug 19 2018 at 20:23)</a>:</h4>
<p>Your installation of mathlib seems to have a problem</p>

<a name="132419071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132419071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132419071">Patrick Massot (Aug 19 2018 at 20:23)</a>:</h4>
<p>maybe you should try to rebuild it</p>

<a name="132419731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132419731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132419731">JIANXIONG SUN (Aug 19 2018 at 20:44)</a>:</h4>
<p>I tried it but it seems not work</p>

<a name="132420211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132420211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132420211">Simon Hudon (Aug 19 2018 at 21:03)</a>:</h4>
<p>After rebuilding, did you restart your Lean server?</p>

<a name="132484277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132484277" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132484277">JIANXIONG SUN (Aug 20 2018 at 22:16)</a>:</h4>
<p>How to switch the LHS and RHS of n equality?</p>
<div class="codehilite"><pre><span></span>variables {R : Type} [comm_ring R]
theorem mul : ∀ (a b c : R) , a * b * c = c * a * b :=
begin
intro a,
intro b,
intro c,
rw mul_comm,
apply mul_assoc,
end
</pre></div>


<p>I thought this can work but it seems that mul_assoc can only prove c<em>a</em>b=c<em>(a</em>b)</p>

<a name="132484521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132484521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132484521">Simon Hudon (Aug 20 2018 at 22:21)</a>:</h4>
<p>You can try <code>assoc_rw [mul_comm]</code></p>

<a name="132484868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132484868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132484868">JIANXIONG SUN (Aug 20 2018 at 22:29)</a>:</h4>
<p>You mean right after <code>intro c</code>?</p>

<a name="132484980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132484980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132484980">JIANXIONG SUN (Aug 20 2018 at 22:31)</a>:</h4>
<p>What's the meaning of the square bracket here?</p>

<a name="132484982"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132484982" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132484982">Simon Hudon (Aug 20 2018 at 22:31)</a>:</h4>
<p>Actually, in your situation, <code>ac_refl</code>, is even simpler: <code>by intros; ac_refl</code></p>

<a name="132485041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132485041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132485041">Simon Hudon (Aug 20 2018 at 22:32)</a>:</h4>
<blockquote>
<p>What's the meaning of the square bracket here?</p>
</blockquote>
<p>Like with <code>rw</code>, <code>assoc_rw</code> takes a list of expressions as an argument: <code>assoc_rw [rule1,rule2,rule3]</code></p>

<a name="132485227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132485227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132485227">JIANXIONG SUN (Aug 20 2018 at 22:37)</a>:</h4>
<p>It says that <code>`assoc_rw</code>is an unknown identifier, <a href="/user_uploads/3121/tTOzNZCncGvTa3Xailmb7NZZ/Capture.PNG" target="_blank" title="Capture.PNG">Capture.PNG</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/tTOzNZCncGvTa3Xailmb7NZZ/Capture.PNG" target="_blank" title="Capture.PNG"><img src="/user_uploads/3121/tTOzNZCncGvTa3Xailmb7NZZ/Capture.PNG"></a></div>

<a name="132485292"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132485292" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132485292">Simon Hudon (Aug 20 2018 at 22:38)</a>:</h4>
<p>Are you using <code>mathlib</code>?</p>

<a name="132485402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132485402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132485402">Mario Carneiro (Aug 20 2018 at 22:41)</a>:</h4>
<p>the non crazy overpowered solution is just to use <code>&lt;-</code>:</p>
<div class="codehilite"><pre><span></span>theorem mul (a b c : R) : a * b * c = c * a * b :=
by rw [mul_comm, ← mul_assoc]
</pre></div>

<a name="132485472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132485472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132485472">Mario Carneiro (Aug 20 2018 at 22:43)</a>:</h4>
<p><code>simp</code> will also do AC rewriting, so <code>by simp [mul_comm, mul_assoc]</code> also works without mathlib</p>

<a name="132485585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132485585" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132485585">JIANXIONG SUN (Aug 20 2018 at 22:45)</a>:</h4>
<p>I would try this tomorrow, thank you</p>

<a name="132486021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132486021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132486021">Simon Hudon (Aug 20 2018 at 22:55)</a>:</h4>
<p>Why do you say AC rewriting is overpowered?</p>

<a name="132486327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132486327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132486327">JIANXIONG SUN (Aug 20 2018 at 23:00)</a>:</h4>
<p>I have mathlib on the computer，maybe there some other problems</p>

<a name="132486499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132486499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132486499">Simon Hudon (Aug 20 2018 at 23:04)</a>:</h4>
<p>You need to import <code>tactic.rewrite</code>, sorry, I forgot to mention that</p>

<a name="132875137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132875137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132875137">Olli (Aug 27 2018 at 19:15)</a>:</h4>
<p>Would it be possible to get a hint for what to do here:<br>
<a href="https://gist.github.com/luxbock/981f990d263516589146ffeb3825e421" target="_blank" title="https://gist.github.com/luxbock/981f990d263516589146ffeb3825e421">https://gist.github.com/luxbock/981f990d263516589146ffeb3825e421</a></p>
<p>This is Chapter 3 exercise from the book. My hypothesis <code>h</code> is a lambda, and the only way I know how to make progress with it is by applying it to something, but I have nothing else to go by</p>

<a name="132875274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132875274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132875274">Simon Hudon (Aug 27 2018 at 19:18)</a>:</h4>
<p>You can use <code>and.intro (assume h', _) (assume h', _)</code></p>

<a name="132875279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132875279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132875279">Patrick Massot (Aug 27 2018 at 19:18)</a>:</h4>
<p>I have a hint: use tactic mode</p>

<a name="132875305"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132875305" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132875305">Olli (Aug 27 2018 at 19:19)</a>:</h4>
<p>I am trying to make it through without tactics, as I'm still trying to wrap my head around propositions as types, and tactics have yet to be introduced at this point</p>

<a name="132875385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132875385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132875385">Kevin Buzzard (Aug 27 2018 at 19:21)</a>:</h4>
<p>Patrick has a point though. I found it much easier to learn tactic mode first. Without it, the goal is an <code>and</code> statement and you can construct proofs of such statements with <code>and.intro</code> as Simon says. In general I guess this is the way to think about it. For each of these things (and, or, implies etc) you need to learn how to construct it (i.e. make it) and how to eliminate it (i.e. use it). <code>and.intro</code> is a constructor for <code>and</code>.</p>

<a name="132875461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132875461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132875461">Patrick Massot (Aug 27 2018 at 19:23)</a>:</h4>
<p>I'll tell you how a mathematician would do it. First install mathlib (of course). Then</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">p</span><span class="o">]</span> <span class="o">[</span><span class="n">decidable</span> <span class="n">q</span><span class="o">]</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">((</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">tauto</span>
</pre></div>

<a name="132875467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132875467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132875467">Patrick Massot (Aug 27 2018 at 19:23)</a>:</h4>
<p>Then move on to interesting maths</p>

<a name="132875515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132875515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132875515">Patrick Massot (Aug 27 2018 at 19:24)</a>:</h4>
<p>Of course the downside is you'll probably depend on people actually understanding terms</p>

<a name="132875517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132875517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132875517">Olli (Aug 27 2018 at 19:24)</a>:</h4>
<p>I did skim the tactics chapter and played around with it a little bit. My goal is to prove each statement in as many ways as possible to get familiar with all the features</p>

<a name="132875540"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132875540" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132875540">Olli (Aug 27 2018 at 19:25)</a>:</h4>
<p>I'm currently reading the book "How to Proove It" alongside trying to learn Lean, so I'm far from a mathematician who needs to use it for anything serious. It's more of an exercise in mind expansion for me</p>

<a name="132875625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132875625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132875625">Patrick Massot (Aug 27 2018 at 19:27)</a>:</h4>
<p>Let me emphasize: when I write "how a mathematician would do it", I really mean this, and not "how everybody should do it". I'm only providing one point of view. Other people will have other interesting points of view</p>

<a name="132875698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132875698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132875698">Olli (Aug 27 2018 at 19:28)</a>:</h4>
<p>Sure undestood :). I figure most people have a very different background from someone like myself, so I just wanted to give some context for the level I'm at</p>

<a name="132876585"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132876585" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132876585">Kevin Buzzard (Aug 27 2018 at 19:46)</a>:</h4>
<p>Well here's a tactic mode proof:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">Hp</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">H</span><span class="o">,</span>
      <span class="n">left</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">Hp</span>
    <span class="o">},</span>
    <span class="o">{</span> <span class="n">intro</span> <span class="n">Hq</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">H</span><span class="o">,</span>
      <span class="n">right</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">Hq</span>
    <span class="o">}</span>
  <span class="o">},</span>
  <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">H</span> <span class="k">with</span> <span class="n">Hpr</span> <span class="n">Hqr</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">Hpq</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">Hpq</span> <span class="k">with</span> <span class="n">Hp</span> <span class="n">Hq</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">Hpr</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">Hp</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">Hqr</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">Hq</span>
  <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>It's cool to step through it looking at the goals etc at each step.</p>

<a name="132876598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132876598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132876598">Olli (Aug 27 2018 at 19:46)</a>:</h4>
<p>finally got it via the term way, very satisfying once it clicks</p>

<a name="132876645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132876645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132876645">Olli (Aug 27 2018 at 19:47)</a>:</h4>
<p>I think I'll enjoy the tactics language as well, as I've found stack based languages fun to play with in the past</p>

<a name="132876753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132876753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132876753">Kevin Buzzard (Aug 27 2018 at 19:49)</a>:</h4>
<p>...and here's a term proof:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">h</span><span class="o">,</span><span class="bp">⟨λ</span> <span class="n">hp</span><span class="o">,</span><span class="n">h</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">hp</span><span class="o">,</span><span class="bp">λ</span> <span class="n">hq</span><span class="o">,</span> <span class="n">h</span> <span class="err">$</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">hq</span><span class="bp">⟩</span><span class="o">,</span><span class="bp">λ</span> <span class="n">h</span> <span class="n">hpq</span><span class="o">,</span><span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="n">hpq</span> <span class="n">h</span><span class="bp">.</span><span class="mi">1</span> <span class="n">h</span><span class="bp">.</span><span class="mi">2</span><span class="bp">⟩</span>
</pre></div>

<a name="132876864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132876864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132876864">Kevin Buzzard (Aug 27 2018 at 19:51)</a>:</h4>
<p>The <code>and.intro</code> is swallowed up with these <code>⟨⟩</code> brackets, but you can still see the <code>or</code> stuff.</p>

<a name="132876891"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132876891" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132876891">Olli (Aug 27 2018 at 19:51)</a>:</h4>
<p>yep, I can follow that. The one I wrote is a bit more verbose, but I see how they are the same thing</p>

<a name="132876950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132876950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132876950">Patrick Massot (Aug 27 2018 at 19:52)</a>:</h4>
<p>If you don't like decidability assumptions but still like automation, what about:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">((</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">→</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">split</span> <span class="bp">;</span> <span class="n">cc</span> <span class="o">},</span>
  <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">Hpr</span><span class="o">,</span> <span class="n">Hqr</span><span class="bp">⟩</span> <span class="o">(</span><span class="n">Hp</span> <span class="bp">|</span> <span class="n">Hq</span><span class="o">)</span> <span class="bp">;</span> <span class="n">cc</span>
<span class="kn">end</span>
</pre></div>

<a name="132876994"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132876994" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132876994">Patrick Massot (Aug 27 2018 at 19:53)</a>:</h4>
<p>Or you can replace the <code>cc</code>with Kevin's hand-crafted proofs</p>

<a name="132877004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132877004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132877004">Patrick Massot (Aug 27 2018 at 19:54)</a>:</h4>
<p>but at least use <code>rintro</code></p>

<a name="132877053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132877053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132877053">Patrick Massot (Aug 27 2018 at 19:54)</a>:</h4>
<p>Because unpacking stuff is not that interesting</p>

<a name="132877096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132877096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132877096">Patrick Massot (Aug 27 2018 at 19:55)</a>:</h4>
<p>and of course there are many many variations, including hybrid tactic/term proofs</p>

<a name="132878054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132878054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132878054">Bryan Gin-ge Chen (Aug 27 2018 at 20:13)</a>:</h4>
<p>When I hover over <code>rintro</code> in VS code I seem to get an error in the popup about interactive.param_desc. I don't really get it but maybe there's some missing description like in Kevin's post here <a href="#narrow/stream/113488-general/subject/lean.20golf/near/132604473" title="#narrow/stream/113488-general/subject/lean.20golf/near/132604473">https://leanprover.zulipchat.com/#narrow/stream/113488-general/subject/lean.20golf/near/132604473</a> . I'm guessing this is low priority and I shouldn't worry about this anyways.</p>
<p>Reading the <code>rintro</code> docstring made me want to play around with <code>rintro?</code>. However, appending a question mark to <code>rcases</code> in the above proof just resulted in an "unexpected token" error. Is there a better example I can try?</p>

<a name="132878128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132878128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132878128">Patrick Massot (Aug 27 2018 at 20:14)</a>:</h4>
<p>The small_nat thing was fixed by Mario today, but maybe not pushed yet</p>

<a name="132923537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132923537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132923537">Olli (Aug 28 2018 at 15:14)</a>:</h4>
<p>I could use another hint here as I can't seem to make progress:<br>
<a href="https://gist.github.com/luxbock/e8a4146ab822049da4d440adc8d7f01c" target="_blank" title="https://gist.github.com/luxbock/e8a4146ab822049da4d440adc8d7f01c">https://gist.github.com/luxbock/e8a4146ab822049da4d440adc8d7f01c</a></p>

<a name="132924310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132924310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132924310">Kevin Buzzard (Aug 28 2018 at 15:30)</a>:</h4>
<p>Oh but this is tricky! Here's a hint: prove not p. Or just use the law of the excluded middle :-)</p>

<a name="132924539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132924539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132924539">Kevin Buzzard (Aug 28 2018 at 15:35)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">easy</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hpinp</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span><span class="bp">.</span><span class="n">mp</span><span class="o">,</span>  <span class="c1">-- p → p → false</span>
  <span class="k">have</span> <span class="n">hnpip</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span> <span class="bp">→</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span><span class="bp">.</span><span class="n">mpr</span><span class="o">,</span> <span class="c1">-- p → false → p</span>
<span class="k">begin</span>
  <span class="n">cases</span> <span class="n">classical</span><span class="bp">.</span><span class="n">em</span> <span class="n">p</span> <span class="k">with</span> <span class="n">hp</span> <span class="n">hnp</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hpinp</span> <span class="n">hp</span> <span class="n">hp</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hnp</span> <span class="o">(</span><span class="n">hnpip</span> <span class="n">hnp</span><span class="o">),</span>
<span class="kn">end</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">axioms</span> <span class="n">easy</span> <span class="c1">-- more than none</span>
</pre></div>


<p>Sorry -- I'm a mathematician.</p>

<a name="132925477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132925477" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132925477">Bryan Gin-ge Chen (Aug 28 2018 at 15:50)</a>:</h4>
<p>There's a previous thread about this here (with proofs avoiding excluded middle) <a href="#narrow/stream/113488-general/subject/Logic.20.26.20Proof/near/127708058" title="#narrow/stream/113488-general/subject/Logic.20.26.20Proof/near/127708058">https://leanprover.zulipchat.com/#narrow/stream/113488-general/subject/Logic.20.26.20Proof/near/127708058</a></p>

<a name="132925990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132925990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132925990">Kevin Buzzard (Aug 28 2018 at 16:00)</a>:</h4>
<p>(deleted)</p>

<a name="132927437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132927437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132927437">Olli (Aug 28 2018 at 16:30)</a>:</h4>
<p>thanks, there are other exercises that are marked under classical reasoning but this one isn't one of them, I'll study up on the previous discussion</p>

<a name="132927685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132927685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132927685">Kevin Buzzard (Aug 28 2018 at 16:36)</a>:</h4>
<p>Or try my hint :-)</p>

<a name="132927985"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/132927985" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#132927985">Olli (Aug 28 2018 at 16:43)</a>:</h4>
<p>I got it now, but had to look up almost the full solution before getting it. very tricky indeed.</p>
<p>My plan is to solve all the exercises first using term level solutions that read as naturally as possible, then go and write a second pass removing all the syntax sugar, and then move on to the tactics chapter and re-write them all using those again</p>

<a name="133811893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133811893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133811893">Xita Meyers (Sep 12 2018 at 16:53)</a>:</h4>
<p>Hello, I currently have: </p>
<div class="codehilite"><pre><span></span>nine : 2 ∣ p / 2,
thing11 : 3 + 4 * (p / 4) = p
⊢ false
</pre></div>


<p>p is a prime. I'm stuck; does anyone have any hints on how to proceed?</p>

<a name="133813180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133813180" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133813180">Kenny Lau (Sep 12 2018 at 17:18)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">nine</span> <span class="o">:</span> <span class="mi">2</span> <span class="err">∣</span> <span class="n">p</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">thing11</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">+</span> <span class="mi">4</span> <span class="bp">*</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span> <span class="mi">4</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="err">←</span> <span class="n">thing11</span> <span class="n">at</span> <span class="n">nine</span><span class="o">,</span>
  <span class="n">change</span> <span class="mi">2</span> <span class="err">∣</span> <span class="o">(</span><span class="mi">3</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span> <span class="mi">4</span><span class="o">))</span> <span class="bp">/</span> <span class="mi">2</span> <span class="n">at</span> <span class="n">nine</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_mul_div_left</span><span class="o">,</span> <span class="err">←</span> <span class="n">nat</span><span class="bp">.</span><span class="n">dvd_add_iff_left</span><span class="o">]</span> <span class="n">at</span> <span class="n">nine</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">absurd</span> <span class="n">nine</span> <span class="n">dec_trivial</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">dvd_mul_right</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">dec_trivial</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="133813199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133813199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133813199">Kenny Lau (Sep 12 2018 at 17:19)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> somehow I find this very hard; can you help?</p>

<a name="133813915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133813915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133813915">Chris Hughes (Sep 12 2018 at 17:31)</a>:</h4>
<p>My best attempt is this</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">nine</span> <span class="o">:</span> <span class="mi">2</span> <span class="err">∣</span> <span class="n">p</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">thing11</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">+</span> <span class="mi">4</span> <span class="bp">*</span> <span class="o">(</span><span class="n">p</span> <span class="bp">/</span> <span class="mi">4</span><span class="o">)</span> <span class="bp">=</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span> <span class="n">thing11</span><span class="o">,</span> <span class="k">show</span> <span class="mi">4</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="mi">2</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_mul_right_div</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ_pos</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">nat</span><span class="bp">.</span><span class="n">dvd_iff_mod_eq_zero</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">add_mul_mod_self_left</span><span class="o">]</span> <span class="n">at</span> <span class="n">nine</span><span class="bp">;</span>
  <span class="n">contradiction</span>
</pre></div>

<a name="133814935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133814935" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133814935">Reid Barton (Sep 12 2018 at 17:48)</a>:</h4>
<p>The high level strategy here is to substitute thing11 into nine -- now you have just one hypothesis -- and then simplify it using properties of divisibility until you get something like 2 divides 3 which can be killed by dec_trivial</p>

<a name="133815370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133815370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133815370">Kenny Lau (Sep 12 2018 at 17:55)</a>:</h4>
<p>easier said than done</p>

<a name="133815424"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133815424" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133815424">Kenny Lau (Sep 12 2018 at 17:56)</a>:</h4>
<p>considering how we both substituted thing11 into nine on the first step and never touched thing11 afterwards</p>

<a name="133815777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133815777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133815777">Reid Barton (Sep 12 2018 at 18:02)</a>:</h4>
<p>Yes, the one hypothesis I meant was nine</p>

<a name="133836132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133836132" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133836132">Kevin Buzzard (Sep 12 2018 at 18:48)</a>:</h4>
<p>Why not do cases on p mod 4?</p>

<a name="133836549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133836549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133836549">Kevin Buzzard (Sep 12 2018 at 18:55)</a>:</h4>
<p>There are a bunch of missing (perhaps) lemmas which would make this easy.</p>

<a name="133836656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133836656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133836656">Kevin Buzzard (Sep 12 2018 at 18:57)</a>:</h4>
<p>I ran into one of these earlier today, I had <code>p/2  &lt; x &lt;= p-1 and I wanted to prove </code>-p/2 &lt;= x-p` or some such thing, it was harder than it should be but I felt that we could make this easier somehow.</p>

<a name="133836898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133836898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133836898">Kenny Lau (Sep 12 2018 at 19:01)</a>:</h4>
<blockquote>
<p>Why not do cases on p mod 4?</p>
</blockquote>
<p>because nobody knows that p mod 4 is given 2 | p/2</p>

<a name="133836913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133836913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133836913">Kenny Lau (Sep 12 2018 at 19:01)</a>:</h4>
<p>div and mod just don't interact in Lean</p>

<a name="133837079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133837079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133837079">Etienne Laurin (Sep 12 2018 at 19:03)</a>:</h4>
<p>In this example there is no need for cases, <code>have : p % 4 = 3, rw [nat_eq_sub_of_add_eq (nat.mod_add_div p 4), nat_eq_sub_of_add_eq thing11]</code></p>

<a name="133837367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133837367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133837367">Kenny Lau (Sep 12 2018 at 19:07)</a>:</h4>
<p>I'm talking about the 2|p/2 not giving us useful information regarding p%4</p>

<a name="133837491"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133837491" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133837491">Kevin Buzzard (Sep 12 2018 at 19:09)</a>:</h4>
<p>right.</p>

<a name="133837492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133837492" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133837492">Kevin Buzzard (Sep 12 2018 at 19:09)</a>:</h4>
<p><code>  have H : 3 = p % 4 := add_right_cancel (eq.trans thing11 (nat.mod_add_div p 4).symm),</code></p>

<a name="133837582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133837582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133837582">Chris Hughes (Sep 12 2018 at 19:10)</a>:</h4>
<blockquote>
<p>I'm talking about the 2|p/2 not giving us useful information regarding p%4</p>
</blockquote>
<p>my quadratic reciprocity PR contains this lemma, which can be used to deduce <code>(p % 4) / 2 = 0</code> from <code>nine</code> which is also a way to get a contradiction</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">mod_mul_right_div_self</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="err">%</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c</span><span class="o">)</span> <span class="bp">/</span> <span class="n">b</span> <span class="bp">=</span> <span class="o">(</span><span class="n">a</span> <span class="bp">/</span> <span class="n">b</span><span class="o">)</span> <span class="err">%</span> <span class="n">c</span>
</pre></div>

<a name="133837684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133837684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133837684">Kenny Lau (Sep 12 2018 at 19:12)</a>:</h4>
<p>my Lean doesn't have your QR PR</p>

<a name="133837720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133837720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133837720">Etienne Laurin (Sep 12 2018 at 19:13)</a>:</h4>
<p>This looks like it <br>
<a href="https://github.com/leanprover/mathlib/blob/e005c3983be832dba68972519873df3ce0a2a6bb/data/nat/basic.lean#L240-L244" target="_blank" title="https://github.com/leanprover/mathlib/blob/e005c3983be832dba68972519873df3ce0a2a6bb/data/nat/basic.lean#L240-L244">https://github.com/leanprover/mathlib/blob/e005c3983be832dba68972519873df3ce0a2a6bb/data/nat/basic.lean#L240-L244</a></p>

<a name="133837738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133837738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133837738">Kevin Buzzard (Sep 12 2018 at 19:13)</a>:</h4>
<p>How about <code>a | (b / c) -&gt; b % (a * c) &lt; a</code> modulo edge cases.</p>

<a name="133837885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133837885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133837885">Chris Hughes (Sep 12 2018 at 19:15)</a>:</h4>
<blockquote>
<p>How about <code>a | (b / c) -&gt; b % (a * c) &lt; a</code> modulo edge cases.</p>
</blockquote>
<p>The trouble with these lemmas is it's still hard to find the proof, because things like this aren't in the list of standard things in my head which I expect to be in the library.</p>

<a name="133837931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133837931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133837931">Kevin Buzzard (Sep 12 2018 at 19:16)</a>:</h4>
<p><code>(b / c) % a = n -&gt; a * n &lt;= b % (a * c)</code></p>

<a name="133837944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133837944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133837944">Kevin Buzzard (Sep 12 2018 at 19:16)</a>:</h4>
<p><code>(b / c) % a = n -&gt; b % (a * c) &lt; a * (n + 1)</code></p>

<a name="133837984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133837984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133837984">Kevin Buzzard (Sep 12 2018 at 19:17)</a>:</h4>
<p>or something</p>

<a name="133838073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133838073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133838073">Reid Barton (Sep 12 2018 at 19:19)</a>:</h4>
<p>A linear arithmetic solver should also be able to solve the original problem with suitable preprocessing</p>

<a name="133838130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133838130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133838130">Kevin Buzzard (Sep 12 2018 at 19:20)</a>:</h4>
<p><code>b % (a * c) = b % c + c * ((b / c) % a)</code>or something</p>

<a name="133838139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133838139" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133838139">Kevin Buzzard (Sep 12 2018 at 19:20)</a>:</h4>
<p>that well-known fact</p>

<a name="133838173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133838173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133838173">Kevin Buzzard (Sep 12 2018 at 19:21)</a>:</h4>
<p>Is there some standard name like <code>omega</code> or <code>sledgehammer</code> or something, for a linear arithmetic solver?</p>

<a name="133838233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133838233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133838233">Kevin Buzzard (Sep 12 2018 at 19:22)</a>:</h4>
<p>oh wow that well-known fact might even be true in the edge cases</p>

<a name="133838265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133838265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133838265">Chris Hughes (Sep 12 2018 at 19:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110032">@Reid Barton</span> Do you know if there are "standard" algorithms powerful enough to do that sort of thing?</p>

<a name="133838274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133838274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133838274">Patrick Massot (Sep 12 2018 at 19:23)</a>:</h4>
<p>We have Rob's linear arithmetic tactic</p>

<a name="133838294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133838294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133838294">Patrick Massot (Sep 12 2018 at 19:23)</a>:</h4>
<p>And maybe Seul will come back at some point</p>

<a name="133838345"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133838345" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133838345">Chris Hughes (Sep 12 2018 at 19:24)</a>:</h4>
<p>I don't think that handles mod and integer division</p>

<a name="133841102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133841102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133841102">Kevin Buzzard (Sep 12 2018 at 20:17)</a>:</h4>
<p>My attempt to write some div mod stuff is <code>div_mod_stuff.lean</code> in the cocalc repo</p>

<a name="133841106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133841106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133841106">Kevin Buzzard (Sep 12 2018 at 20:17)</a>:</h4>
<p>I have to clean the kitchen. I proved the well-known lemma</p>

<a name="133841111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133841111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133841111">Kevin Buzzard (Sep 12 2018 at 20:17)</a>:</h4>
<p><code>lemma well_known (a b c : ℕ) : b % (a * c) = b % c + c * ((b / c) % a) := [done]</code></p>

<a name="133841112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133841112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133841112">Kevin Buzzard (Sep 12 2018 at 20:17)</a>:</h4>
<p>I'm wondering if it makes the proof any easier</p>

<a name="133841180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133841180" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133841180">Kevin Buzzard (Sep 12 2018 at 20:18)</a>:</h4>
<div class="codehilite"><pre><span></span>nine : 2 ∣ p / 2,
thing11 : 3 + 4 * (p / 4) = p,  [used]
H : 3 = p % 2 + 2 * (p / 2 % 2)
⊢ false
</pre></div>

<a name="133841194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133841194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133841194">Kevin Buzzard (Sep 12 2018 at 20:18)</a>:</h4>
<p>that's after applying the lemma</p>

<a name="133843673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133843673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133843673">Reid Barton (Sep 12 2018 at 21:02)</a>:</h4>
<p>Chris the original statement can be expressed in Presburger arithmetic (natural numbers with only addition), which has a decidable theory -- that's what Seul Baek implemented in <code>cooper</code>, I believe.</p>

<a name="133860394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133860394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133860394">Johan Commelin (Sep 13 2018 at 03:52)</a>:</h4>
<p><span class="user-mention" data-user-id="122318">@Tobias Grosser</span> Is also working on Presburger arithmetic in Lean. He told me he would like to match up with someone who knows Lean/maths to get implement a version for mathlib.</p>

<a name="133877436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133877436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133877436">Xita Meyers (Sep 13 2018 at 11:26)</a>:</h4>
<p>An additional question-- something that I have no idea how to fix. I currently have </p>
<div class="codehilite"><pre><span></span>an9 : 1 + x ^ 2 ≡ 0 [MOD p]
⊢ 1 + x ^ 2 ≡ 0 [MOD p]
</pre></div>


<p>and <code> exact an9, </code> gives the error message:</p>
<div class="codehilite"><pre><span></span>invalid type ascription, term has type
  nat.modeq p (@has_add.add nat nat.has_add 1 (@has_pow.pow nat nat (@monoid.has_pow nat nat.monoid) x 2)) 0
but is expected to have type
  nat.modeq p (@has_add.add nat nat.has_add 1 (@has_pow.pow nat nat nat.has_pow x 2)) 0
</pre></div>


<p>In the middle of a complicated code, so I haven't made an MWE yet. Would this be easily fixable? (Before I try a different approach)</p>

<a name="133877609"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133877609" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133877609">Rob Lewis (Sep 13 2018 at 11:30)</a>:</h4>
<p>Does <code>simpa</code> or <code>simpa using an9</code> work? I think there's a simp lemma for rewriting pow on <code>nat</code>.</p>

<a name="133877681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133877681" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133877681">Xita Meyers (Sep 13 2018 at 11:31)</a>:</h4>
<p><code>simpa using an9,</code> works! Thanks!</p>

<a name="133877764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133877764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133877764">Chris Hughes (Sep 13 2018 at 11:32)</a>:</h4>
<p>(deleted)</p>

<a name="133880162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/133880162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#133880162">Tobias Grosser (Sep 13 2018 at 12:20)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> , yes I am interested in Presburger arithmetic.Still learning more about lean, but I am certainly interested to chat about this. In case sb is interested in collaborating, I am open to collaborative visits or internships @ETH.</p>

<a name="135937724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/135937724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#135937724">JIANXIONG SUN (Oct 16 2018 at 23:35)</a>:</h4>
<p>How can I represent square or cube in Lean such as x^2?</p>

<a name="135937808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/135937808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#135937808">Andrew Ashworth (Oct 16 2018 at 23:36)</a>:</h4>
<p>what error does lean give you when you write <code>x^2</code>?</p>

<a name="135938425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/135938425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#135938425">Kenny Lau (Oct 16 2018 at 23:47)</a>:</h4>
<p><code>import algebra.group_power</code></p>

<a name="158582769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/158582769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#158582769">Paula Neeley (Feb 15 2019 at 02:00)</a>:</h4>
<p>Hey guys,<br>
First timer, so please be nice :)<br>
I'm aiming to prove the example at the bottom of the long code snippet. I made the lemmas "foo" and "bar" to help. My theorem "bar" worked to prove the inductive step, but I don't understand the output that Lean gives me when I try to prove this lemma "bar" itself. The base case gives me the output:</p>
<div class="codehilite"><pre><span></span>2 goals
case list.nil
α : Type u_1,
s : list α,
a : α
⊢ length (s ++ [a]) = length (s ++ nil) + 1
</pre></div>


<p>Specifically, I am unsure what the [a] here means and how to work with it. Any insights would be appreciated.</p>
<div class="codehilite"><pre><span></span>section
open list

variable {α : Type*}
variables s t : list α
variable a : α

theorem length_nil : length (@nil α) = 0 := rfl

theorem foo (t : list α) : t ++ nil = t :=
begin
induction t with a t ih,
{refl},
rw [cons_append, ih],
end

theorem bar : length (s ++ a :: t) = length (s ++ t) + 1 :=
begin
induction t with a t ih,
sorry
end

#check foo
#check nil_append
#check cons_append
#check length_cons
#check length_nil

#eval [1, 2, 3] ++ [4, 5]
#eval length [1, 2, 3, 4, 5]

end

/-
Prove the following.
-/

section
open list

variable {α : Type*}
variables s t : list α
variable a : α

example : length (s ++ t) = length s + length t :=
begin
induction t with a t ih,
{rw [length_nil, foo], refl},
rw [length_cons, bar, ih], refl,
end

end
</pre></div>

<a name="158583275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/158583275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#158583275">Simon Hudon (Feb 15 2019 at 02:12)</a>:</h4>
<p><code>[a]</code> is the same as <code>a :: nil</code> (it's a special notation)</p>

<a name="158583362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/158583362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#158583362">Simon Hudon (Feb 15 2019 at 02:14)</a>:</h4>
<p>You should consider doing your induction on <code>s</code> instead of <code>t</code>. The reason is that <code>++</code> is defined by recursion on <code>s</code> : <code>x :: xs ++ ys = x :: (xs ++ ys)</code></p>

<a name="158583389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/158583389" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#158583389">Simon Hudon (Feb 15 2019 at 02:15)</a>:</h4>
<p>Also: welcome to Zulip Paula!</p>

<a name="158583402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/158583402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#158583402">Paula Neeley (Feb 15 2019 at 02:15)</a>:</h4>
<blockquote>
<p>You should consider doing your induction on <code>s</code> instead of <code>t</code>. The reason is that <code>++</code> is defined by recursion on <code>s</code> : <code>x :: xs ++ ys = x :: (xs ++ ys)</code></p>
</blockquote>
<p>Oh ok, I will try that! Thank you for your help!</p>

<a name="158598928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/158598928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#158598928">Kenny Lau (Feb 15 2019 at 08:32)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">list</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kn">variables</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span>
<span class="kn">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>

<span class="kn">theorem</span> <span class="n">length_nil</span> <span class="o">:</span> <span class="n">length</span> <span class="o">(</span><span class="bp">@</span><span class="n">nil</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">append_nil&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="n">t</span> <span class="bp">++</span> <span class="n">nil</span> <span class="bp">=</span> <span class="n">t</span>
<span class="bp">|</span> <span class="o">[]</span>       <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span><span class="bp">::</span><span class="n">tl</span><span class="o">)</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="o">((</span><span class="bp">::</span><span class="o">)</span><span class="n">hd</span><span class="o">)</span> <span class="o">(</span><span class="n">append_nil</span> <span class="n">tl</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">length_append&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="n">length</span> <span class="o">(</span><span class="n">s</span> <span class="bp">++</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">length</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">length</span> <span class="n">t</span>
<span class="bp">|</span> <span class="o">[]</span>       <span class="n">t</span> <span class="o">:=</span> <span class="o">(</span><span class="n">zero_add</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span><span class="bp">::</span><span class="n">tl</span><span class="o">)</span> <span class="n">t</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">length_cons</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_add</span><span class="o">,</span> <span class="err">←</span> <span class="n">length_append&#39;</span> <span class="n">tl</span> <span class="n">t</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span>

<span class="kn">theorem</span> <span class="n">length_append_cons</span> <span class="o">:</span> <span class="n">length</span> <span class="o">(</span><span class="n">s</span> <span class="bp">++</span> <span class="n">a</span> <span class="bp">::</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">length</span> <span class="o">(</span><span class="n">s</span> <span class="bp">++</span> <span class="n">t</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">length_append&#39;</span><span class="o">,</span> <span class="n">length_append&#39;</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">append_nil&#39;</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">nil_append</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">cons_append</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">length_cons</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">length_nil</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="bp">++</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="n">length</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>

<span class="kn">end</span> <span class="n">list</span>
</pre></div>

<a name="160868091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/160868091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#160868091">Robert Spencer (Mar 15 2019 at 12:00)</a>:</h4>
<p>(deleted)</p>

<a name="160868727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/160868727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#160868727">Tony Wang (Mar 15 2019 at 12:11)</a>:</h4>
<p>(deleted)</p>

<a name="160869044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/160869044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#160869044">Tony Wang (Mar 15 2019 at 12:17)</a>:</h4>
<p>Hello - I was just wondering for the bit where I have <code>rw succ_a_plus_b_equals_a_plus_succ_b</code> below, surely there's a better way to use the definition of <code>add</code>?</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">xnat</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">xnat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">xnat</span> <span class="bp">→</span> <span class="n">xnat</span>

<span class="kn">open</span> <span class="n">xnat</span>

<span class="n">def</span> <span class="n">add</span> <span class="o">:</span> <span class="n">xnat</span> <span class="bp">→</span> <span class="n">xnat</span> <span class="bp">→</span> <span class="n">xnat</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>

<span class="kn">notation</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">add</span> <span class="n">a</span> <span class="n">b</span>

<span class="kn">theorem</span> <span class="n">succ_a_plus_b_equals_a_plus_succ_b</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">xnat</span><span class="o">)</span> <span class="o">:</span> <span class="n">succ</span><span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">succ</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">add</span>

<span class="kn">theorem</span> <span class="n">succ_is_succ_zero_add</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">xnat</span><span class="o">)</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">zero</span> <span class="bp">+</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">induction</span> <span class="n">a</span> <span class="k">with</span> <span class="n">k</span> <span class="n">Hk</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">unfold</span> <span class="n">add</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">rw</span> <span class="n">Hk</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">succ_a_plus_b_equals_a_plus_succ_b</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">Hk</span>
    <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="160869148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/160869148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#160869148">Tony Wang (Mar 15 2019 at 12:18)</a>:</h4>
<p>Nvm I found it: <code>rw ←add</code> seems to work!</p>

<a name="160869187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/160869187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#160869187">Calle Sönne (Mar 15 2019 at 12:19)</a>:</h4>
<p>I have the following code:</p>
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">digit</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">floor</span><span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="n">b</span> <span class="err">^</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">-</span> <span class="n">floor</span><span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="n">b</span> <span class="err">^</span> <span class="n">n</span><span class="o">)</span><span class="bp">*</span><span class="n">b</span>

<span class="kn">lemma</span> <span class="n">digit_mul_base</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">digit</span> <span class="n">b</span> <span class="n">r</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">digit</span> <span class="n">b</span> <span class="o">(</span><span class="n">r</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rwa</span> <span class="o">[</span><span class="n">digit</span><span class="o">,</span> <span class="n">digit</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">],</span> <span class="n">conv</span>
  <span class="k">begin</span> <span class="n">congr</span><span class="o">,</span> <span class="n">skip</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">nat</span><span class="bp">.</span><span class="n">cast_pow</span><span class="o">,</span> <span class="err">←</span><span class="n">nat</span><span class="bp">.</span><span class="n">cast_mul</span><span class="o">,</span> <span class="err">←</span><span class="n">pow_succ</span> <span class="n">b</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)],</span>
  <span class="kn">end</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>This gives me an error with following tactic state:</p>
<div class="codehilite"><pre><span></span><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kn">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="n">b</span> <span class="bp">*</span> <span class="n">b</span> <span class="err">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">linear_ordered_ring</span> <span class="n">α</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">floor_ring</span> <span class="n">α</span><span class="o">,</span>
<span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">r</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span>
<span class="err">⊢</span> <span class="err">⌊</span><span class="n">r</span> <span class="bp">*</span> <span class="err">↑</span><span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">b</span> <span class="err">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="err">⌋</span> <span class="bp">-</span> <span class="err">⌊</span><span class="n">r</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">b</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">b</span> <span class="err">^</span> <span class="n">n</span><span class="err">⌋</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">b</span> <span class="bp">=</span> <span class="err">?</span><span class="n">m_1</span>
</pre></div>


<p>I cant seem to find the error, any help would be appreciated</p>

<a name="160869679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/160869679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#160869679">Tony Wang (Mar 15 2019 at 12:27)</a>:</h4>
<p>If I unfold a definition with more than one part, is it possible to specify which part I want to unfold?</p>

<a name="160869914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/160869914" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#160869914">Mario Carneiro (Mar 15 2019 at 12:30)</a>:</h4>
<p>you can use <code>conv</code> to focus on a subterm</p>

<a name="165591474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/165591474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#165591474">Mario Carneiro (May 14 2019 at 04:10)</a>:</h4>
<p>usually this is achieved by constructing the set in a way so that it's obvious that it's a finset. How is <code>isCanonicalPartition</code> defined?</p>

<a name="165591475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/165591475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#165591475">Johan Commelin (May 14 2019 at 04:10)</a>:</h4>
<p><span class="user-mention" data-user-id="118987">@Huyen Chau Nguyen</span> to format code on this chat (you can still edit your message) use</p>
<div class="codehilite"><pre><span></span>```lean
put your code here
```
</pre></div>


<p>That way it is formatted as a code block with syntax highlighting.</p>

<a name="167292319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167292319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167292319">hpxmd (Jun 04 2019 at 13:24)</a>:</h4>
<p>Hello, newb in functional languages here! Im stuck on excercise at "2.4. Introducing Definitions"</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm"> Above, we discussed the process of “currying” a function, that is, taking a function f (a, b) that takes an ordered pair as an argument, and recasting it as a function f&#39; a b that takes two arguments successively. As another exercise, we encourage you to complete the following definitions, which “curry” and “uncurry” a function.</span>
<span class="cm">def curry (α β γ : Type) (f : α × β → γ) : α → β → γ := sorry</span>
<span class="cm">def uncurry (α β γ : Type) (f : α → β → γ) : α × β → γ := sorry</span>
<span class="cm">-/</span>
<span class="n">def</span> <span class="n">curry</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="o">:=</span>
</pre></div>


<p>the closest solution i came up with is</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">curry</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span><span class="o">:</span> <span class="n">γ</span><span class="o">),</span> <span class="n">c</span>
</pre></div>


<p>returns error:</p>
<div class="codehilite"><pre><span></span><span class="bp">/</span><span class="n">home</span><span class="bp">/</span><span class="n">runner</span><span class="bp">/.</span><span class="n">code</span><span class="bp">.</span><span class="n">tio</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">56</span><span class="o">:</span> <span class="n">error</span><span class="o">:</span> <span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">γ</span><span class="o">),</span> <span class="n">c</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="bp">→</span> <span class="n">γ</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span>
</pre></div>


<p>i don't understand how i should return this λ itself. As is can't just leave it like "λ (a: α) (b: β) (c: γ)"</p>

<a name="167292425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167292425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167292425">Mario Carneiro (Jun 04 2019 at 13:25)</a>:</h4>
<p>you need to use <code>f</code> at some point</p>

<a name="167292828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167292828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167292828">hpxmd (Jun 04 2019 at 13:30)</a>:</h4>
<p>I tried for like whole day and a half. Im no mathematitian also. Should i just continue reading then?</p>

<a name="167292871"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167292871" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167292871">Marc Huisinga (Jun 04 2019 at 13:30)</a>:</h4>
<p>the type signature of curry states that given a value of type alpha and a value of type beta, you get a value of type gamma. <br>
the function you defined with your lambda however takes a value of type alpha, a value of type beta and a value of type gamma.<br>
you need to drop the gamma parameter and come up with a way to produce a value of type gamma from values of types alpha and beta, which will involve using f.</p>

<a name="167292909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167292909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167292909">Patrick Massot (Jun 04 2019 at 13:30)</a>:</h4>
<blockquote>
<p>you need to use <code>f</code> at some point</p>
</blockquote>
<p>See, the question was under-specified. No wonder the continuum hypothesis is undecidable.</p>

<a name="167293143"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167293143" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167293143">Patrick Massot (Jun 04 2019 at 13:32)</a>:</h4>
<p>Seriously, <span class="user-mention" data-user-id="224062">@hpxmd</span> you need to reread the last paragraph of <a href="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#simple-type-theory" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#simple-type-theory">https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html#simple-type-theory</a></p>

<a name="167293173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167293173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167293173">Johan Commelin (Jun 04 2019 at 13:33)</a>:</h4>
<blockquote>
<p>I tried for like whole day and a half. Im no mathematitian also. Should i just continue reading then?</p>
</blockquote>
<p>How many mathematicians do you think know what <code>curry</code> means? I bet that 99% think it is something you put on a sausage.</p>

<a name="167293178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167293178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167293178">Patrick Massot (Jun 04 2019 at 13:33)</a>:</h4>
<p>That's where the specification is explicitly given</p>

<a name="167293221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167293221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167293221">Patrick Massot (Jun 04 2019 at 13:33)</a>:</h4>
<p>Johan, I think you spend <em>way</em> too much time in Germany</p>

<a name="167293295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167293295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167293295">hpxmd (Jun 04 2019 at 13:34)</a>:</h4>
<p>Thanks Patrick, ill try that</p>

<a name="167309231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167309231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167309231">hpxmd (Jun 04 2019 at 16:02)</a>:</h4>
<p>So i had to read wiki to write it:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">curry</span> <span class="o">(</span><span class="n">α</span> <span class="n">β</span> <span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span><span class="o">,</span> <span class="bp">λ</span> <span class="n">b</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</pre></div>


<p>is this right?</p>

<a name="167309258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167309258" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167309258">Kevin Buzzard (Jun 04 2019 at 16:02)</a>:</h4>
<p>Yup!</p>

<a name="167309397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167309397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167309397">hpxmd (Jun 04 2019 at 16:04)</a>:</h4>
<p>then i guess i dont understand this lambda calculus thing</p>

<a name="167309403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167309403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167309403">hpxmd (Jun 04 2019 at 16:04)</a>:</h4>
<p>thank you</p>

<a name="167309612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167309612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167309612">Patrick Massot (Jun 04 2019 at 16:06)</a>:</h4>
<p>This has not much to do with lambda calculus</p>

<a name="167309673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167309673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167309673">Kevin Buzzard (Jun 04 2019 at 16:06)</a>:</h4>
<p>This is exactly completely basic lambda calculus, isn't it?</p>

<a name="167309761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167309761" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167309761">Patrick Massot (Jun 04 2019 at 16:07)</a>:</h4>
<p>No, it's about functions of two variable vs function of one variable with values in functions of one variable.</p>

<a name="167309813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167309813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167309813">Patrick Massot (Jun 04 2019 at 16:07)</a>:</h4>
<p>You could write the answer as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>↦</mo><mo>(</mo><mi>b</mi><mo>↦</mo><mi>f</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">a \mapsto (b \mapsto f (a,b))</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">a</span><span class="mrel">↦</span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mrel">↦</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> and you woudln't see any <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">λ</span></span></span></span></p>

<a name="167309929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167309929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167309929">Patrick Massot (Jun 04 2019 at 16:08)</a>:</h4>
<p>The point of lambda-calculus is not using a stupid notation instead of a legible one (reading: the one <em>we</em> are used to). It's about the reduction rules</p>

<a name="167316162"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167316162" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167316162">Marc Huisinga (Jun 04 2019 at 17:20)</a>:</h4>
<p>this topic made me curious: when getting started with lean (or a similar language), did the function application syntax without parens feel unnatural or even hard to read to any of you, compared to the syntax with parens?<br>
i'm asking because i've heard this complaint quite a lot over the years from people coming from traditional programming languages, and i've been wondering whether this initial feeling is common for everyone, or whether it's just because i've mostly talked to people that had gotten used to the syntax with parens over the years.</p>

<a name="167319865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167319865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167319865">Kevin Buzzard (Jun 04 2019 at 17:58)</a>:</h4>
<p>I was a mathematician for 25 years before I learnt any functional programming and yes, the lack of brackets looked super-weird to me. I still occasionally put them in by accident.</p>

<a name="167320016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167320016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167320016">Koundinya Vajjha (Jun 04 2019 at 18:00)</a>:</h4>
<p>Yes but use it long enough and you'll start hating brackets. :-)</p>

<a name="167320208"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167320208" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167320208">Patrick Massot (Jun 04 2019 at 18:02)</a>:</h4>
<p>I've caught myself not writing brackets on paper</p>

<a name="167325388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167325388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167325388">Sebastien Gouezel (Jun 04 2019 at 18:53)</a>:</h4>
<p>In dynamics it is very common to omit the brackets.</p>

<a name="167327636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167327636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167327636">Scott Morrison (Jun 04 2019 at 19:20)</a>:</h4>
<p>Meh. We should be writing function application as <code>x f</code> anyway. Losing the brackets is partial progress. :-)</p>

<a name="167341596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167341596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167341596">Andrew Ashworth (Jun 04 2019 at 22:42)</a>:</h4>
<p>Reverse Polish notation was the best thing in calculators. Maybe I ought to implement it in lean 4, hah.</p>

<a name="167341835"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/167341835" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#167341835">Andrew Ashworth (Jun 04 2019 at 22:46)</a>:</h4>
<p>Then you can stare at expressions like 15 7 1 1 + − ÷ 3 × 2 1 1 + + − and truly live the bracket free life</p>

<a name="168785596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/168785596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#168785596">Robert Solovay (Jun 23 2019 at 08:56)</a>:</h4>
<p>How do I enter the Greek letter lambda (symbol for  functional abstraction) in the Lean javascript window?</p>

<a name="168785599"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/168785599" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#168785599">Kevin Buzzard (Jun 23 2019 at 08:56)</a>:</h4>
<p><code>\lam</code></p>

<a name="168785605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/168785605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#168785605">Kevin Buzzard (Jun 23 2019 at 08:57)</a>:</h4>
<p><code>\la</code> apparently works too</p>

<a name="168785607"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/168785607" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#168785607">Robert Solovay (Jun 23 2019 at 08:57)</a>:</h4>
<p>Thanks.</p>

<a name="168785618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/168785618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#168785618">Kevin Buzzard (Jun 23 2019 at 08:57)</a>:</h4>
<p>Nice to see you here, by the way!</p>

<a name="168791239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/168791239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#168791239">Jesse Michael Han (Jun 23 2019 at 11:49)</a>:</h4>
<p>welcome!</p>

<a name="168969707"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/168969707" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#168969707">jachym simon (Jun 25 2019 at 19:35)</a>:</h4>
<p>Hi! <br>
I am trying to proof completeness theorem for Hilbert style classical propositional system. While working my way through I ran into this lemma below. The lemma is quite important, but i am not able to prove it. I can do that  for n and k particular numbers (1,2,3, ..),  but not for n and k general. Is there some way to prove it?</p>
<div class="codehilite"><pre><span></span>def eval := ℕ → bool
def g(n:ℕ)(f:eval): ℕ → bool := (λ m:ℕ, nat.lt_by_cases (λ h:m&lt;n, f m) (λ h, tt) (λ h, tt))

lemma Lemma1(n:ℕ)(f:eval): ∀ k:ℕ, k &lt; n → g n f k = f k :=
</pre></div>


<p>Thanks :)</p>

<a name="168970125"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/168970125" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#168970125">Kenny Lau (Jun 25 2019 at 19:40)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="kn">eval</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="n">def</span> <span class="n">g</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)(</span><span class="n">f</span><span class="o">:</span><span class="kn">eval</span><span class="o">):</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_by_cases</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">:</span><span class="n">m</span><span class="bp">&lt;</span><span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">tt</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">tt</span><span class="o">))</span>

<span class="kn">lemma</span> <span class="n">Lemma1</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)(</span><span class="n">f</span><span class="o">:</span><span class="kn">eval</span><span class="o">):</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">n</span> <span class="n">f</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">k</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">k</span> <span class="n">hk</span><span class="o">,</span> <span class="n">dif_pos</span> <span class="n">hk</span>
</pre></div>

<a name="168973733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/168973733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#168973733">jachym simon (Jun 25 2019 at 20:24)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="kn">eval</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="n">def</span> <span class="n">g</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)(</span><span class="n">f</span><span class="o">:</span><span class="kn">eval</span><span class="o">):</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_by_cases</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">:</span><span class="n">m</span><span class="bp">&lt;</span><span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">tt</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">tt</span><span class="o">))</span>

<span class="kn">lemma</span> <span class="n">Lemma1</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)(</span><span class="n">f</span><span class="o">:</span><span class="kn">eval</span><span class="o">):</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">n</span> <span class="n">f</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">k</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">k</span> <span class="n">hk</span><span class="o">,</span> <span class="n">dif_pos</span> <span class="n">hk</span>
</pre></div>


</blockquote>
<p>Thank you :)</p>

<a name="169005779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/169005779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#169005779">jachym simon (Jun 26 2019 at 07:19)</a>:</h4>
<p>HI again,<br>
i have  got one more connected question. How do i prove the two below? Thought it would be the same, but it does not seem to work. </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="kn">eval</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="n">def</span> <span class="n">g</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)(</span><span class="n">f</span><span class="o">:</span><span class="kn">eval</span><span class="o">):</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">m</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">lt_by_cases</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">:</span><span class="n">m</span><span class="bp">&lt;</span><span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">tt</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">tt</span><span class="o">))</span>

<span class="kn">lemma</span> <span class="n">Lemma2</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)(</span><span class="n">f</span><span class="o">:</span><span class="kn">eval</span><span class="o">):</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">n</span> <span class="n">f</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">tt</span>  <span class="o">:=</span>
<span class="kn">lemma</span> <span class="n">Lemma3</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">)(</span><span class="n">f</span><span class="o">:</span><span class="kn">eval</span><span class="o">):</span> <span class="bp">∀</span> <span class="n">k</span><span class="o">:</span><span class="bp">ℕ</span><span class="o">,</span> <span class="n">k</span> <span class="bp">&gt;</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">g</span> <span class="n">n</span> <span class="n">f</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">tt</span>  <span class="o">:=</span>
</pre></div>

<a name="169005987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/169005987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#169005987">Mario Carneiro (Jun 26 2019 at 07:23)</a>:</h4>
<p>It might be simpler to not use <code>lt_by_cases</code></p>

<a name="169005990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/169005990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#169005990">Mario Carneiro (Jun 26 2019 at 07:23)</a>:</h4>
<p>and just use <code>if</code></p>

<a name="169006136"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/169006136" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#169006136">Mario Carneiro (Jun 26 2019 at 07:26)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="kn">eval</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">bool</span>
<span class="n">def</span> <span class="n">g</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kn">eval</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="n">m</span> <span class="k">else</span> <span class="n">tt</span>

<span class="kn">lemma</span> <span class="n">Lemma2</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kn">eval</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">g</span> <span class="n">n</span> <span class="n">f</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span>
<span class="k">have</span> <span class="bp">¬</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="bp">λ</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">ne_of_lt</span> <span class="n">h&#39;</span> <span class="n">h</span><span class="o">,</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">g</span><span class="o">,</span> <span class="n">this</span><span class="o">]</span>

<span class="kn">lemma</span> <span class="n">Lemma3</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kn">eval</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">g</span> <span class="n">n</span> <span class="n">f</span> <span class="n">k</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span>
<span class="k">have</span> <span class="bp">¬</span> <span class="n">k</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">,</span> <span class="k">from</span> <span class="n">not_lt_of_gt</span> <span class="n">h</span><span class="o">,</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">g</span><span class="o">,</span> <span class="n">this</span><span class="o">]</span>
</pre></div>

<a name="174031793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/174031793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#174031793">EnjoysMath (Aug 24 2019 at 09:29)</a>:</h4>
<p>Yep, that was it.  It was just updating something in the background</p>

<a name="176214388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/176214388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#176214388">Juho Kupiainen (Sep 20 2019 at 17:37)</a>:</h4>
<p>How can I browse Lean's mathlib with VS code. Lean works in VS code, but when I open a file in mathlib (I cloned the code) it cannot resolve the imports. I did "leanpkg configure" and "leanpkg build" in the root directory of mathlib</p>

<a name="176216909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/176216909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#176216909">Bryan Gin-ge Chen (Sep 20 2019 at 18:06)</a>:</h4>
<p>Are you opening the entire mathlib directory in VS Code? Often these issues occur when you just try to open a random file from mathlib without having opened the directory as a workspace.</p>

<a name="176217470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/176217470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#176217470">Juho Kupiainen (Sep 20 2019 at 18:13)</a>:</h4>
<p>Opening the directory helped after I had created a new project according to the instruction on mathlib github page.</p>

<a name="178668713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/178668713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#178668713">Kevin Buzzard (Oct 21 2019 at 15:52)</a>:</h4>
<p>(deleted)</p>

<a name="179374989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/179374989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#179374989">Leonid Kimelfeld (Oct 29 2019 at 21:14)</a>:</h4>
<p>Hi.  Is Fundamental theorem of arithmetic (AKA unique factorization theorem) formalized in Lean ?</p>

<a name="179375411"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/179375411" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#179375411">Kevin Buzzard (Oct 29 2019 at 21:19)</a>:</h4>
<p>Yes.</p>

<a name="179375627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/179375627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#179375627">Kevin Buzzard (Oct 29 2019 at 21:22)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/6030ff0a9d2498b1389c7a3be9b3d938a351dac3/src/data/nat/prime.lean#L415" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/6030ff0a9d2498b1389c7a3be9b3d938a351dac3/src/data/nat/prime.lean#L415">https://github.com/leanprover-community/mathlib/blob/6030ff0a9d2498b1389c7a3be9b3d938a351dac3/src/data/nat/prime.lean#L415</a></p>

<a name="179376156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/179376156" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#179376156">Leonid Kimelfeld (Oct 29 2019 at 21:29)</a>:</h4>
<blockquote>
<p><a href="https://github.com/leanprover-community/mathlib/blob/6030ff0a9d2498b1389c7a3be9b3d938a351dac3/src/data/nat/prime.lean#L415" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/6030ff0a9d2498b1389c7a3be9b3d938a351dac3/src/data/nat/prime.lean#L415">https://github.com/leanprover-community/mathlib/blob/6030ff0a9d2498b1389c7a3be9b3d938a351dac3/src/data/nat/prime.lean#L415</a></p>
</blockquote>
<p>Thank you!</p>

<a name="179376351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/179376351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#179376351">Bryan Gin-ge Chen (Oct 29 2019 at 21:32)</a>:</h4>
<p>See also <a href="https://github.com/leanprover-community/mathlib/blob/140cc05004b98a50778771afe7333b5b919bb595/docs/100-theorems.md#80-the-fundamental-theorem-of-arithmetic" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/140cc05004b98a50778771afe7333b5b919bb595/docs/100-theorems.md#80-the-fundamental-theorem-of-arithmetic">the discussion on the "100 theorems" branch</a>, which includes some other highlights. <span class="user-mention" data-user-id="111080">@Floris van Doorn</span> Maybe this can be PR'd?</p>

<a name="179376714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/179376714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#179376714">Leonid Kimelfeld (Oct 29 2019 at 21:37)</a>:</h4>
<blockquote>
<p>See also <a href="https://github.com/leanprover-community/mathlib/blob/140cc05004b98a50778771afe7333b5b919bb595/docs/100-theorems.md#80-the-fundamental-theorem-of-arithmetic" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/140cc05004b98a50778771afe7333b5b919bb595/docs/100-theorems.md#80-the-fundamental-theorem-of-arithmetic">the discussion on the "100 theorems" branch</a>, which includes some other highlights. <span class="user-mention silent" data-user-id="111080">Floris van Doorn</span> Maybe this can be PR'd?</p>
</blockquote>
<p>Interesting!</p>

<a name="179760587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/179760587" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#179760587">Kevin Buzzard (Nov 03 2019 at 19:48)</a>:</h4>
<p>OK so I have function world (9 levels of manipulating sets and elements using intro, apply) and proposition world (9 levels of manipulating propositions and proofs using intro, apply) up at the beta link at <a href="http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game_beta/" target="_blank" title="http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game_beta/">http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game_beta/</a> if anyone is desperate for more levels.</p>

<a name="184760027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/184760027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#184760027">Kevin Buzzard (Jan 03 2020 at 19:21)</a>:</h4>
<p>(deleted)</p>

<a name="187848002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/187848002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#187848002">Rocky Kamen-Rubio (Feb 10 2020 at 19:11)</a>:</h4>
<p>I have a very long Prop that consists mostly of AND/OR statements and false equalities like 1 = 2. Is there a faster way to simplify it than going through it with cases, split, left/right? Is there a built-in function that can scan through a long Prop and replace false equalities with ff, and another than can recognize that A AND ff is equivalent to ff, or that A OR ff is equivalent to A?</p>

<a name="187848098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/187848098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#187848098">Chris Hughes (Feb 10 2020 at 19:12)</a>:</h4>
<p><code>norm_num</code> would probably solve that goal.</p>

<a name="187849336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/187849336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#187849336">Cerek Hillen (he) (W2'20) (Feb 10 2020 at 19:24)</a>:</h4>
<p>And for context, if I'm not mistaken, <code>norm_num</code> means the tactic <code>norm_num</code> provided by <a href="https://github.com/leanprover-community/mathlib/" target="_blank" title="https://github.com/leanprover-community/mathlib/">mathlib</a></p>

<a name="188423065"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188423065" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188423065">Rocky Kamen-Rubio (Feb 18 2020 at 04:30)</a>:</h4>
<p>I'm implementing matricies as types <code>fin m →  fin n →  nat </code> and want to sum all the elements in each row, and then sum all those values. Is there an easy way to do this using <code>finset.univ.sum</code>? I've been able to do it with 1D arrays of type <code>fin m →  nat</code> so I feel like there should be a clever lambda solution for the 2D case. I committed to this implementation before I realized mathlib has a matrix type, but it's implemented the same way, so it might not be worth the hassle of switching.</p>

<a name="188433115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188433115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188433115">Kevin Buzzard (Feb 18 2020 at 08:57)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">matrix_sum</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="err">$</span> <span class="n">M</span> <span class="n">i</span>
</pre></div>


<p>Of course if you find yourself asking five more questions like this, and for some of them the answer is "we did it already with matrices in mathlib", then you might want to take that as an indication that you should switch. Remember -- if you define it yourself, you've got to prove all the lemmas about it yourself.</p>

<a name="188433175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188433175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188433175">Kevin Buzzard (Feb 18 2020 at 08:58)</a>:</h4>
<p>PS I can't guarantee that I summed the elements in the rows rather than the columns -- this depends on your mental model.</p>

<a name="188462495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188462495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188462495">Rocky Kamen-Rubio (Feb 18 2020 at 15:54)</a>:</h4>
<p>Thank you! That's a good point that maybe this is a sign that I should switch to the mathlib representation. My other motivation for not switching was that eventually I want to start putting noncommutative elements (specifically entangled quantum states) into the matrix, so it would matter whether I'm ordering it by rows or columns. If we have <code>(M : fin m → fin n → ℕ )</code>, I guess I could also just transpose it and do <code>matrix_sum </code> on the transpose. This way we get both cases, and all I need is to show whether they're equal or not.</p>

<a name="188465633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188465633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188465633">Rocky Kamen-Rubio (Feb 18 2020 at 16:26)</a>:</h4>
<p>Ok I tried doing this and got to this point. I feel like again there's probably an easy tactic to finish this off that I'm not seeing. Maybe switching to mathlib's matrix representation would make this easier, but part of me still wants to hold out on switching because I'm not going to be multiplying or adding  these matrices, just summing their elements in specific ways, and I want as much control over that as possible.</p>
<div class="codehilite"><pre><span></span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="err">⊢</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">(</span><span class="n">board</span> <span class="n">i</span><span class="o">))</span> <span class="bp">=</span>
    <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="n">board</span> <span class="n">m</span> <span class="n">i</span><span class="o">))</span>
</pre></div>

<a name="188465682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188465682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188465682">Reid Barton (Feb 18 2020 at 16:27)</a>:</h4>
<p>This is "reverse the order of summation"?</p>

<a name="188465694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188465694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188465694">Kevin Buzzard (Feb 18 2020 at 16:27)</a>:</h4>
<p>Right</p>

<a name="188465745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188465745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188465745">Reid Barton (Feb 18 2020 at 16:27)</a>:</h4>
<p>It definitely won't be a tactic, it probably is a theorem that already exists.</p>

<a name="188465819"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188465819" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188465819">Reid Barton (Feb 18 2020 at 16:28)</a>:</h4>
<p>I think it's whatever the to_additive of <code>prod_product</code> is</p>

<a name="188465972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188465972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188465972">Reid Barton (Feb 18 2020 at 16:29)</a>:</h4>
<p>well, combined with more stuff. How can this not exist already?</p>

<a name="188465975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188465975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188465975">Kevin Buzzard (Feb 18 2020 at 16:29)</a>:</h4>
<p>aah, remember the old days before automation where you could just read off the additive name in the library...</p>

<a name="188466069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188466069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188466069">Kevin Buzzard (Feb 18 2020 at 16:30)</a>:</h4>
<p>Oh yeah so we're in exactly the same situation as in the other thread.</p>

<a name="188466072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188466072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188466072">Reid Barton (Feb 18 2020 at 16:30)</a>:</h4>
<p>oh, <code>prod_comm</code></p>

<a name="188466119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188466119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188466119">Reid Barton (Feb 18 2020 at 16:30)</a>:</h4>
<p>this should probably have a comment with things like "fubini" and maybe "prod_prod"</p>

<a name="188466164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188466164" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188466164">Kevin Buzzard (Feb 18 2020 at 16:31)</a>:</h4>
<p><a href="#narrow/stream/113489-new-members/topic/spheres/near/188451346" title="#narrow/stream/113489-new-members/topic/spheres/near/188451346">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/spheres/near/188451346</a> also ideally needs to switch from <code>finset.sum finset.univ (fin n)</code> to <code>finset.sum finset.range n</code></p>

<a name="188466293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188466293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188466293">Kevin Buzzard (Feb 18 2020 at 16:32)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">sum_univ_fin_eq_sum_range</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="188466328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188466328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188466328">Kevin Buzzard (Feb 18 2020 at 16:32)</a>:</h4>
<p>I don't like the look of induction on n</p>

<a name="188467516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188467516" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188467516">Kevin Buzzard (Feb 18 2020 at 16:44)</a>:</h4>
<p>What I'm saying is that <code>fin n</code> doesn't have type <code>finset ℕ</code></p>

<a name="188471000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188471000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188471000">Kevin Buzzard (Feb 18 2020 at 17:20)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">sum_univ_fin_eq_sum_range</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">set</span> <span class="n">F</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">with</span> <span class="n">hF</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">F</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hF</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">dite</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hi</span> <span class="o">:</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">),</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hi</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">),</span> <span class="mi">0</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">dif_pos</span> <span class="n">i</span><span class="bp">.</span><span class="n">is_lt</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">i</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">rw</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_image</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">congr&#39;</span><span class="o">,</span>
    <span class="c1">-- ⊢ finset.image (λ (x : fin n), x.val) finset.univ = finset.range n</span>
    <span class="n">ext</span> <span class="n">j</span><span class="o">,</span> <span class="c1">-- sigh</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_range</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_image</span><span class="o">],</span>
    <span class="n">split</span><span class="o">,</span>
      <span class="n">rintro</span> <span class="bp">⟨⟨</span><span class="n">j</span><span class="o">,</span><span class="n">hj</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hj</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hj</span><span class="o">,</span>
    <span class="n">use</span> <span class="bp">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">hj</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span> <span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_univ</span><span class="o">,</span> <span class="n">refl</span>
  <span class="o">},</span>
  <span class="n">intros</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">fin</span><span class="bp">.</span><span class="n">eq_of_veq</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="188477897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188477897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188477897">Rocky Kamen-Rubio (Feb 18 2020 at 18:33)</a>:</h4>
<p>Amazing, thank you! I'm having trouble getting this into a form that I can use to finish my goal state though. I understand conceptually why it works, but the usual tactics like <code>rw</code>  <code>apply</code> etc don't seem to be working here (even though mathematically it seems like that's what I'm doing). I've had a similar issue come up as well when I got to the following tactic and goals states. I feel like I'm missing something potentially simple and obvious.</p>
<div class="codehilite"><pre><span></span><span class="mi">1</span> <span class="n">goal</span>
<span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">strategyA</span> <span class="n">r</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">strategyB</span> <span class="n">c</span> <span class="n">r</span>
<span class="err">⊢</span> <span class="n">strategyB</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="n">strategyA</span> <span class="n">m</span> <span class="n">n</span>
</pre></div>

<a name="188477990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188477990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188477990">Kevin Buzzard (Feb 18 2020 at 18:34)</a>:</h4>
<p><code>ext</code></p>

<a name="188478041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188478041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188478041">Kevin Buzzard (Feb 18 2020 at 18:34)</a>:</h4>
<p>You need to check that two functions are equal iff they agree everywhere. In term mode this is <code>funext</code> and in tactic mode it's <code>ext i</code> (or perhaps <code>ext c r</code> in your case)</p>

<a name="188478099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188478099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188478099">Kevin Buzzard (Feb 18 2020 at 18:35)</a>:</h4>
<p>"Extensionality" is the general principle that two objects are equal if and only if they're made from equal things. I think it's one of those things which computer scientists sometimes make a fuss about, it might be an axiom or something.</p>

<a name="188478178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188478178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188478178">Kevin Buzzard (Feb 18 2020 at 18:36)</a>:</h4>
<p>It results from a lack of understanding of mathematical equality ;-)</p>

<a name="188479304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188479304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188479304">Rocky Kamen-Rubio (Feb 18 2020 at 18:48)</a>:</h4>
<p>Fascinating. So lean doesn't automatically know that two objects made of equal parts are equal? I guess that makes sense but something feels a little absurd about that... Like I'm telling lean that instead of this equality holding for every element of a set, I'm telling it that it holds for a general element of a set, and it recognizes that as an equality but not the former?</p>
<p>Either way, it worked for the more recent goal state I posted but it doesn't seem to be working for the "reverse order of summation" goal state. I'm getting the following error</p>
<p><a href="/user_uploads/3121/6PRB-IbCr_wcTevp4USNqaTe/Screen-Shot-2020-02-18-at-1.44.34-PM.png" target="_blank" title="Screen-Shot-2020-02-18-at-1.44.34-PM.png">Screen-Shot-2020-02-18-at-1.44.34-PM.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/3121/6PRB-IbCr_wcTevp4USNqaTe/Screen-Shot-2020-02-18-at-1.44.34-PM.png" target="_blank" title="Screen-Shot-2020-02-18-at-1.44.34-PM.png"><img src="/user_uploads/3121/6PRB-IbCr_wcTevp4USNqaTe/Screen-Shot-2020-02-18-at-1.44.34-PM.png"></a></div>

<a name="188479385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188479385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188479385">Bryan Gin-ge Chen (Feb 18 2020 at 18:49)</a>:</h4>
<p>There are a lot errors like that in the docstrings; I'm not sure what the precise cause is but they shouldn't affect the validity of the actual Lean code.</p>

<a name="188479508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188479508" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188479508">Patrick Massot (Feb 18 2020 at 18:51)</a>:</h4>
<p>Rocky: saying that two functions are equal if they take the same value when evaluated on the same input is absurd from a computer science point of view. For instance it completely disregard execution time or memory consumption for functions that can be actually run.</p>

<a name="188479517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188479517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188479517">Kevin Buzzard (Feb 18 2020 at 18:51)</a>:</h4>
<p>The error in the docstring is irrelevant, that's just some parser issue.</p>

<a name="188479656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188479656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188479656">Kevin Buzzard (Feb 18 2020 at 18:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">strategyA</span> <span class="n">r</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">strategyB</span> <span class="n">c</span> <span class="n">r</span><span class="o">)</span>
<span class="o">:</span> <span class="n">strategyB</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="n">strategyA</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">ext</span> <span class="n">c</span> <span class="n">r</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span>
<span class="kn">end</span>
</pre></div>


<p>Oh -- this is the one you can do? <code>ext</code> only works if the goal is of the form <code>f = g</code> where <code>f</code> and <code>g</code> are, say, functions or sets.</p>

<a name="188480326"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188480326" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188480326">Rocky Kamen-Rubio (Feb 18 2020 at 19:00)</a>:</h4>
<p>Yeah I got that one working fine. It's this one that's been difficult for me. Here's my attempt so far that gives me the error message I linked to in my previous post.</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">row_sum_eq_col_sum</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">row_sum</span> <span class="n">board</span> <span class="bp">=</span> <span class="n">col_sum</span> <span class="n">board</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">row_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">col_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">matrix_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">matrix_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleB</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleA</span><span class="o">,</span>
<span class="n">simp</span><span class="o">,</span>
<span class="n">ext</span> <span class="n">c</span> <span class="n">r</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>Edit: sorry, forgot I haven't linked to how row_sum or col_sum are defined. Might be easier just to look at my final tactic state. <a href="user_uploads/3121/ICOpPkjP80M7HYreUnjxRAHq/Screen-Shot-2020-02-18-at-2.03.20-PM.png" target="_blank" title="user_uploads/3121/ICOpPkjP80M7HYreUnjxRAHq/Screen-Shot-2020-02-18-at-2.03.20-PM.png">Screen-Shot-2020-02-18-at-2.03.20-PM.png</a></p>
<div class="message_inline_image"><a href="user_uploads/3121/ICOpPkjP80M7HYreUnjxRAHq/Screen-Shot-2020-02-18-at-2.03.20-PM.png" target="_blank" title="Screen-Shot-2020-02-18-at-2.03.20-PM.png"><img src="user_uploads/3121/ICOpPkjP80M7HYreUnjxRAHq/Screen-Shot-2020-02-18-at-2.03.20-PM.png"></a></div>

<a name="188480420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188480420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188480420">Rocky Kamen-Rubio (Feb 18 2020 at 19:01)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110031">Patrick Massot</span> <a href="#narrow/stream/113489-new-members/topic/(no.20topic)/near/188479508" title="#narrow/stream/113489-new-members/topic/(no.20topic)/near/188479508">said</a>:</p>
<blockquote>
<p>Rocky: saying that two functions are equal if they take the same value when evaluated on the same input is absurd from a computer science point of view. For instance it completely disregard execution time or memory consumption for functions that can be actually run.</p>
</blockquote>
<p>That's a good point - I hadn't though about functions different in memory use or runtime. I guess I still haven't developed a good intuition for how lean thinks about mathematical objects.</p>

<a name="188481027"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188481027" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188481027">Patrick Massot (Feb 18 2020 at 19:08)</a>:</h4>
<p>Lean supports both ways of thinking about function, without making a fuss. It simply records whether you used mathematics way or not.</p>

<a name="188481275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188481275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188481275">Kevin Buzzard (Feb 18 2020 at 19:11)</a>:</h4>
<p>you need to rewrite <code>h</code> a lot and then use <code>finset.sum_comm</code></p>

<a name="188481351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188481351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188481351">Kevin Buzzard (Feb 18 2020 at 19:12)</a>:</h4>
<p>Your goal is the equality of two natural numbers so you can't use <code>ext</code> here.</p>

<a name="188481404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188481404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188481404">Kevin Buzzard (Feb 18 2020 at 19:12)</a>:</h4>
<p>actually maybe just <code>finset.sum_comm</code> will work directly</p>

<a name="188481740"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188481740" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188481740">Kevin Buzzard (Feb 18 2020 at 19:16)</a>:</h4>
<p>BTW it's bad style to put <code>simp</code> in the middle of a proof; it should only be used to close a goal. There are ways to work around uses of <code>simp</code> in the middle of a proof.</p>

<a name="188879309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188879309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188879309">Rocky Kamen-Rubio (Feb 23 2020 at 18:47)</a>:</h4>
<p>I've been chewing on this for a few days and can't seem to figure out how to rewrite <code>h</code> in this case. Could I get a hint? :-)</p>

<a name="188879808"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188879808" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188879808">Bryan Gin-ge Chen (Feb 23 2020 at 19:01)</a>:</h4>
<p><span class="user-mention" data-user-id="260106">@Rocky Kamen-Rubio</span> I scrolled up a bit in the thread but I didn't see any self-contained code that I could copy / paste to try out. Could you provide that in a post or a link to a github gist?</p>

<a name="188880242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188880242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188880242">Rocky Kamen-Rubio (Feb 23 2020 at 19:11)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>  Here's the full proof in its current state. The part I'm struggling with is towards the end. Let me know if you have any questions since it's a bit long.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">init</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">nat</span><span class="bp">.</span><span class="n">parity</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">fintype</span>
<span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">big_operators</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>
<span class="kn">set_option</span> <span class="n">class</span><span class="bp">.</span><span class="n">instance_max_depth</span> <span class="mi">15000000</span>


<span class="bp">#</span><span class="kn">eval</span> <span class="mi">2</span> <span class="c1">--You can&#39;t put open_locale classical after an import statement for some reason so that&#39;s why this is here</span>

<span class="n">open_locale</span> <span class="n">classical</span>
<span class="n">def</span> <span class="n">board</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">strategyA</span>

<span class="n">def</span> <span class="n">consistent</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="o">(</span><span class="n">strategyA</span> <span class="n">r</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">strategyB</span> <span class="n">c</span> <span class="n">r</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sampleA</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">board</span>

<span class="n">def</span> <span class="n">sampleB</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="n">board</span> <span class="n">m</span> <span class="n">n</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">sampleA</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">sampleB</span>

<span class="kn">lemma</span> <span class="n">board_equiv_strategy</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">consistent</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">strategyA</span> <span class="bp">=</span> <span class="o">((</span><span class="n">sampleA</span> <span class="o">(</span><span class="n">board</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)))</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">strategyB</span> <span class="bp">=</span> <span class="o">(</span><span class="n">sampleB</span> <span class="o">(</span><span class="n">board</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">))))</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">split</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleA</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">board</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">board</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleB</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">consistent</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
<span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">each_row_sum_even</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">),</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">sampleA</span> <span class="n">board</span> <span class="n">r</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span>

<span class="n">def</span> <span class="n">each_col_sum_odd</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="bp">¬</span><span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">sampleB</span> <span class="n">board</span> <span class="n">c</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span>

<span class="n">def</span> <span class="n">even_strategy</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">,</span> <span class="o">((</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">strategyA</span> <span class="n">r</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span><span class="o">))</span>

<span class="n">def</span> <span class="n">odd_strategy</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">strategyB</span> <span class="n">c</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">even_strategy_implies_even_rows</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span>
<span class="o">:</span> <span class="o">((</span><span class="n">consistent</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">even_strategy</span> <span class="n">strategyA</span><span class="o">)</span> <span class="bp">→</span> <span class="n">each_row_sum_even</span> <span class="o">(</span><span class="n">board</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">even_strategy</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">each_row_sum_even</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleA</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">board</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="kn">end</span>

<span class="c1">--In order to talk about a board we need to assume the two strategies are consistent. Or else we need to define the board differently to allowfor this</span>
<span class="kn">lemma</span> <span class="n">odd_strategy_implies_odd_cols</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span>
<span class="o">:</span> <span class="o">((</span><span class="n">consistent</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">odd_strategy</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">→</span> <span class="n">each_col_sum_odd</span> <span class="o">(</span><span class="n">board</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h3</span> <span class="o">:=</span> <span class="n">board_equiv_strategy</span> <span class="n">strategyA</span> <span class="n">strategyB</span> <span class="n">h1</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h3</span> <span class="k">with</span> <span class="n">h4</span> <span class="n">h5</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">each_col_sum_odd</span><span class="o">,</span>
<span class="n">rw</span> <span class="err">←</span> <span class="n">h5</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">odd_strategy</span> <span class="n">at</span> <span class="n">h2</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">h2</span><span class="o">,</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">matrix_sum</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span>
<span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="err">$</span> <span class="n">M</span> <span class="n">i</span>

<span class="n">def</span> <span class="n">row_sum</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">matrix_sum</span> <span class="o">(</span><span class="n">sampleA</span> <span class="n">board</span><span class="o">)</span>

<span class="n">def</span> <span class="n">col_sum</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">matrix_sum</span> <span class="o">(</span><span class="n">sampleB</span> <span class="n">board</span><span class="o">)</span>

<span class="c1">--sometimes I get an error here that this theorem is using sorry. Doesn&#39;t look like it is to me, so idk what&#39;s going on</span>
<span class="kn">theorem</span> <span class="n">sum_univ_fin_eq_sum_range</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">finset</span><span class="bp">.</span><span class="n">sum</span> <span class="n">finset</span><span class="bp">.</span><span class="n">univ</span> <span class="n">f</span> <span class="bp">=</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">set</span> <span class="n">F</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">if</span> <span class="n">hi</span> <span class="o">:</span> <span class="n">i</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">with</span> <span class="n">hF</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">=</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="n">F</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">ext</span> <span class="n">i</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">hF</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">f</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">dite</span> <span class="o">(</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hi</span> <span class="o">:</span> <span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">),</span> <span class="n">f</span> <span class="bp">⟨</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span><span class="o">,</span> <span class="n">hi</span><span class="bp">⟩</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">hi</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">i</span><span class="bp">.</span><span class="n">val</span> <span class="bp">&lt;</span> <span class="n">n</span><span class="o">),</span> <span class="mi">0</span><span class="o">),</span>
    <span class="n">rw</span> <span class="n">dif_pos</span> <span class="n">i</span><span class="bp">.</span><span class="n">is_lt</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">i</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span>
  <span class="o">},</span>
  <span class="n">rw</span> <span class="n">H</span><span class="o">,</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">finset</span><span class="bp">.</span><span class="n">sum_image</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">congr&#39;</span><span class="o">,</span>
    <span class="c1">-- ⊢ finset.image (λ (x : fin n), x.val) finset.univ = finset.range n</span>
    <span class="n">ext</span> <span class="n">j</span><span class="o">,</span> <span class="c1">-- sigh</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">finset</span><span class="bp">.</span><span class="n">mem_range</span><span class="o">,</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_image</span><span class="o">],</span>
    <span class="n">split</span><span class="o">,</span>
      <span class="n">rintro</span> <span class="bp">⟨⟨</span><span class="n">j</span><span class="o">,</span><span class="n">hj</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hj</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hj</span><span class="o">,</span>
    <span class="n">use</span> <span class="bp">⟨</span><span class="n">j</span><span class="o">,</span> <span class="n">hj</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">split</span><span class="o">,</span> <span class="n">apply</span> <span class="n">finset</span><span class="bp">.</span><span class="n">mem_univ</span><span class="o">,</span> <span class="n">refl</span>
  <span class="o">},</span>
  <span class="n">intros</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">fin</span><span class="bp">.</span><span class="n">eq_of_veq</span><span class="o">,</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">row_sum_eq_col_sum</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">board</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">row_sum</span> <span class="n">board</span> <span class="bp">=</span> <span class="n">col_sum</span> <span class="n">board</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rw</span> <span class="n">row_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">col_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">matrix_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">matrix_sum</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleB</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">sampleA</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">sum_univ_fin_eq_sum_range</span><span class="o">,</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="c1">-- finset.sum_comm,</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">noStrategyMN2</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">¬</span> <span class="o">((</span><span class="n">consistent</span> <span class="n">strategyA</span> <span class="n">strategyB</span><span class="o">)</span> <span class="bp">∧</span>  <span class="o">(</span><span class="n">even_strategy</span> <span class="n">strategyA</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">odd_strategy</span> <span class="n">strategyB</span><span class="o">))</span>
<span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">c</span> <span class="n">y</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">y</span> <span class="k">with</span> <span class="n">even</span> <span class="n">odd</span><span class="o">,</span>
<span class="k">have</span> <span class="n">cEven</span> <span class="o">:=</span> <span class="n">even</span><span class="o">,</span>
<span class="k">have</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">even_strategy_implies_even_rows</span> <span class="n">strategyA</span> <span class="n">strategyB</span> <span class="o">(</span><span class="n">c</span> <span class="bp">∧</span> <span class="n">even</span><span class="o">),</span>  <span class="c1">--why is this not ok???????</span>
<span class="k">have</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">odd_strategy_implies_odd_cols</span> <span class="n">strategyA</span> <span class="n">strategyB</span> <span class="o">(</span><span class="n">c</span> <span class="bp">∧</span> <span class="n">even</span><span class="o">),</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="188881049"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188881049" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188881049">Kevin Buzzard (Feb 23 2020 at 19:32)</a>:</h4>
<p>Re: "sometimes I get an error here that this theorem is using sorry." I think this might be some kind of a bug in <code>use</code>. If you replace <code>use ⟨j, hj⟩,</code> near the end by <code>existsi (⟨j, hj⟩ : fin n),</code> is it any better?</p>

<a name="188881338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188881338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188881338">Kevin Buzzard (Feb 23 2020 at 19:38)</a>:</h4>
<p>The <code>rw h</code> fails (correctly), and to debug this you can try filling in some of the gaps. The more precise <code>rw h m (λ (i : fin m), finset.sum finset.univ (board i))</code> fails and here the error is much clearer -- <code>sum_univ_fin_eq_sum_range</code> (which IIRC I wrote) is about functions from <code>fin n</code> to the reals, and you have a function from <code>fin n</code> to the naturals. The correct thing to prove is for a map to an arbitrary additive commutative monoid or something -- something which includes both the naturals and the reals. You can replace the first few lines with</p>
<div class="codehilite"><pre><span></span>theorem sum_univ_fin_eq_sum_range {A : Type*} [add_comm_monoid A] (n : ℕ) (f : fin n → A) :
  finset.sum finset.univ f = (finset.range n).sum (λ i, if hi : i &lt; n then f ⟨i, hi⟩ else 0) :=
begin
  set F : ℕ → A := λ i, if hi : i &lt; n then f ⟨i, hi⟩ else 0 with hF,
</pre></div>

<a name="188881384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188881384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188881384">Kevin Buzzard (Feb 23 2020 at 19:39)</a>:</h4>
<p>but even after the rewrites there is work to do. At least this is a step forward.</p>

<a name="188881583"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188881583" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188881583">Kevin Buzzard (Feb 23 2020 at 19:44)</a>:</h4>
<p>oh no no what am I talking about? You don't use h at all, I've misremembered the idea. You can just finish the proof with <code>sum_comm</code>:</p>
<div class="codehilite"><pre><span></span>rw matrix_sum,
rw sampleB,
rw sampleA,
rw finset.sum_comm,
</pre></div>

<a name="188881724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188881724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188881724">Kevin Buzzard (Feb 23 2020 at 19:47)</a>:</h4>
<p>So that gets <code>row_sum_eq_col_sum</code> compiling and now there's just an error  at <code>c ∧ even</code> -- you ask why this is not OK, and this has an easy answer: <code>P ∧ Q</code> works for propositions, which means <em>true-false statements</em>. For example <code>x = 2 ∧ y &lt; 4</code> is fine. Now <code>x = 2</code> has type <code>Prop</code>. Your term <code>c</code> has type <code>consistent strategyA strategyB</code> (not <code>Prop</code> -- it's a <em>proof</em> not a <em>statement</em>) so <code>c ∧ ...</code> makes no sense.</p>

<a name="188882833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/%28no%20topic%29/near/188882833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/79918notopic.html#188882833">Rocky Kamen-Rubio (Feb 23 2020 at 20:17)</a>:</h4>
<ol>
<li>
<p>Yes, replacing <code>use (j,hj)</code> with <code>existsi ((j,hj) : fin n),</code> resolved the issue, thank you!</p>
</li>
<li>
<p>I had a feeling there was an easy way to do that in Lean.  I'm a little confused what the purpose of defining h was then? I remember <span class="user-mention" data-user-id="110038">@Kevin Buzzard</span>  and <span class="user-mention" data-user-id="110032">@Reid Barton</span> talking about how this proof wouldn't be possible with tactics, but maybe that was for a more general idea?</p>
</li>
<li>
<p>I defined <code>consistent</code> <code>even</code> and <code>odd</code>as <code>Prop</code>s though, not as theorems. Do I still need to treat them differently?</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">consistent</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">strategyB</span><span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="o">:=</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="o">(</span><span class="n">strategyA</span> <span class="n">r</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">strategyB</span> <span class="n">c</span> <span class="n">r</span><span class="o">)</span>

<span class="n">def</span> <span class="n">even_strategy</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyA</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">r</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">m</span><span class="o">,</span> <span class="o">((</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">strategyA</span> <span class="n">r</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span><span class="o">))</span>

<span class="n">def</span> <span class="n">odd_strategy</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">}</span> <span class="o">(</span><span class="n">strategyB</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">fin</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">∀</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">),</span> <span class="bp">¬</span> <span class="o">(</span><span class="n">finset</span><span class="bp">.</span><span class="n">univ</span><span class="bp">.</span><span class="n">sum</span> <span class="o">(</span><span class="n">strategyB</span> <span class="n">c</span><span class="o">))</span><span class="bp">.</span><span class="n">even</span><span class="o">)</span>
</pre></div>


{% endraw %}

{% include archive_update.html %}