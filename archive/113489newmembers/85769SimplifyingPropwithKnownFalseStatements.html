---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html">Simplifying Prop with Known False Statements</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="188963082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188963082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188963082">Rocky Kamen-Rubio (Feb 24 2020 at 20:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188885872" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188885872">said</a>:</p>
<blockquote>
<p>You defined <code>consistent</code> as a Prop, and <code>and</code> expects a Prop. So why did you give it a <em>proof</em> and not a Prop? You gave it a term of type P, not P itself.</p>
</blockquote>
<p>Ok, I think I'm getting this. It's working fine with the modification. Thank you!</p>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188886296" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188886296">said</a>:</p>
<blockquote>
<p>PS your <code>import init</code> is bad -- remove it. Your <code>set_option class.instance_max_depth 15000000</code> is also bad -- remove it. I think the reasons were already explained above but you don't want either of these two lines.</p>
</blockquote>
<p>You're right. I had forgotten to take those out since they weren't actively stopping my code from compiling... Thanks for the reminder!</p>

<a name="188963797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188963797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188963797">Rocky Kamen-Rubio (Feb 24 2020 at 20:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260106">Rocky Kamen-Rubio</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188462495" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188462495">said</a>:</p>
<blockquote>
<p>Thank you! That's a good point that maybe this is a sign that I should switch to the mathlib representation. My other motivation for not switching was that eventually I want to start putting noncommutative elements (specifically entangled quantum states) into the matrix, so it would matter whether I'm ordering it by rows or columns. If we have <code>(M : fin m → fin n → ℕ )</code>, I guess I could also just transpose it and do <code>matrix_sum </code> on the transpose. This way we get both cases, and all I need is to show whether they're equal or not.</p>
</blockquote>
<p>I'm now wanting to repeat this procedure but with matrices in each column instead of integers, and taking the matrix product of all the matrices in each row. <code>finset.univ.prod</code> (understandably) doesn't use <code>matrix.mul</code> automatically when its input is a matrix. Is there a way to feed it an arbitrary function (à la MapReduce) , or should I be thinking about this differently? I could see a benefit to implementing this matrix data structure differently, maybe as a 2D linked list, to facilitate recursive matrix multiplication of its elements over a given row or column, but I feel like that shouldn't be necessary.</p>

<a name="188967088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188967088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188967088">Kevin Buzzard (Feb 24 2020 at 21:19)</a>:</h4>
<p><code>finset.univ.prod</code> should work fine. If the function is taking values in anything which Lean knows is a monoid then it will use the monoid multiplication....oh wait. It's not commutative. Then yes you're right, you'll have to use something like <code>list.prod</code></p>

<a name="188993063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188993063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188993063">Rocky Kamen-Rubio (Feb 25 2020 at 05:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188967088" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188967088">said</a>:</p>
<blockquote>
<p><code>finset.univ.prod</code> should work fine. If the function is taking values in anything which Lean knows is a monoid then it will use the monoid multiplication....oh wait. It's not commutative. Then yes you're right, you'll have to use something like <code>list.prod</code></p>
</blockquote>
<p><code>list.prod</code> works, thank you! That's a shame though because now I'm going to have to choose between keeping my matrix type or using this easier product method (unless there's a snazzy way to get the rows and columns from a matrix as a list instead of as vectors, but it seems like that's not possible). I tried implementing this recursive algorithm on my matrix in the meantime too, but keep getting that the recursive call is an "unknown identifier". Is there an import statement or something I'm missing that tells Lean it's ok to use variables that haven't been fully defined yet?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">row_product</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">mat</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">ℤ</span> <span class="o">))</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">row_product_helper</span> <span class="n">mat</span> <span class="n">r</span> <span class="mi">1</span>

<span class="n">def</span> <span class="n">row_product_helper</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">mat</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">ℤ</span> <span class="o">))</span> <span class="o">(</span><span class="n">r</span> <span class="n">c</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">ℤ</span> <span class="o">:=</span>
<span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="k">then</span> <span class="n">mat</span> <span class="n">r</span> <span class="n">c</span> <span class="k">else</span> <span class="n">matrix</span><span class="bp">.</span><span class="n">mul</span> <span class="o">(</span><span class="n">mat</span> <span class="n">r</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">row_product_helper</span> <span class="n">mat</span> <span class="n">r</span> <span class="o">(</span><span class="n">c</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span>
</pre></div>


{% endraw %}

{% include archive_update.html %}