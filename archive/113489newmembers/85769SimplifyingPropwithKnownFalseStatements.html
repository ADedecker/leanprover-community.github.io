---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html">Simplifying Prop with Known False Statements</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="188963082"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188963082" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188963082">Rocky Kamen-Rubio (Feb 24 2020 at 20:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188885872" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188885872">said</a>:</p>
<blockquote>
<p>You defined <code>consistent</code> as a Prop, and <code>and</code> expects a Prop. So why did you give it a <em>proof</em> and not a Prop? You gave it a term of type P, not P itself.</p>
</blockquote>
<p>Ok, I think I'm getting this. It's working fine with the modification. Thank you!</p>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188886296" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188886296">said</a>:</p>
<blockquote>
<p>PS your <code>import init</code> is bad -- remove it. Your <code>set_option class.instance_max_depth 15000000</code> is also bad -- remove it. I think the reasons were already explained above but you don't want either of these two lines.</p>
</blockquote>
<p>You're right. I had forgotten to take those out since they weren't actively stopping my code from compiling... Thanks for the reminder!</p>

<a name="188963797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188963797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188963797">Rocky Kamen-Rubio (Feb 24 2020 at 20:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="260106">Rocky Kamen-Rubio</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188462495" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188462495">said</a>:</p>
<blockquote>
<p>Thank you! That's a good point that maybe this is a sign that I should switch to the mathlib representation. My other motivation for not switching was that eventually I want to start putting noncommutative elements (specifically entangled quantum states) into the matrix, so it would matter whether I'm ordering it by rows or columns. If we have <code>(M : fin m → fin n → ℕ )</code>, I guess I could also just transpose it and do <code>matrix_sum </code> on the transpose. This way we get both cases, and all I need is to show whether they're equal or not.</p>
</blockquote>
<p>I'm now wanting to repeat this procedure but with matrices in each column instead of integers, and taking the matrix product of all the matrices in each row. <code>finset.univ.prod</code> (understandably) doesn't use <code>matrix.mul</code> automatically when its input is a matrix. Is there a way to feed it an arbitrary function (à la MapReduce) , or should I be thinking about this differently? I could see a benefit to implementing this matrix data structure differently, maybe as a 2D linked list, to facilitate recursive matrix multiplication of its elements over a given row or column, but I feel like that shouldn't be necessary.</p>

<a name="188967088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188967088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188967088">Kevin Buzzard (Feb 24 2020 at 21:19)</a>:</h4>
<p><code>finset.univ.prod</code> should work fine. If the function is taking values in anything which Lean knows is a monoid then it will use the monoid multiplication....oh wait. It's not commutative. Then yes you're right, you'll have to use something like <code>list.prod</code></p>

<a name="188993063"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/188993063" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#188993063">Rocky Kamen-Rubio (Feb 25 2020 at 05:33)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188967088" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/188967088">said</a>:</p>
<blockquote>
<p><code>finset.univ.prod</code> should work fine. If the function is taking values in anything which Lean knows is a monoid then it will use the monoid multiplication....oh wait. It's not commutative. Then yes you're right, you'll have to use something like <code>list.prod</code></p>
</blockquote>
<p><code>list.prod</code> works, thank you! That's a shame though because now I'm going to have to choose between keeping my matrix type or using this easier product method (unless there's a snazzy way to get the rows and columns from a matrix as a list instead of as vectors, but it seems like that's not possible). I tried implementing this recursive algorithm on my matrix in the meantime too, but keep getting that the recursive call is an "unknown identifier". Is there an import statement or something I'm missing that tells Lean it's ok to use variables that haven't been fully defined yet?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">row_product</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">mat</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">ℤ</span> <span class="o">))</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="n">row_product_helper</span> <span class="n">mat</span> <span class="n">r</span> <span class="mi">1</span>

<span class="n">def</span> <span class="n">row_product_helper</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">mat</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">ℤ</span> <span class="o">))</span> <span class="o">(</span><span class="n">r</span> <span class="n">c</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">matrix</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="o">(</span><span class="n">fin</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">ℤ</span> <span class="o">:=</span>
<span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="k">then</span> <span class="n">mat</span> <span class="n">r</span> <span class="n">c</span> <span class="k">else</span> <span class="n">matrix</span><span class="bp">.</span><span class="n">mul</span> <span class="o">(</span><span class="n">mat</span> <span class="n">r</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">row_product_helper</span> <span class="n">mat</span> <span class="n">r</span> <span class="o">(</span><span class="n">c</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span>
</pre></div>

<a name="189003202"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189003202" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189003202">Kevin Buzzard (Feb 25 2020 at 09:27)</a>:</h4>
<blockquote>
<p>(unless there's a snazzy way to get the rows and columns from a matrix as a list instead of as vectors, but it seems like that's not possible). </p>
</blockquote>
<p>I don't really know what you mean. Anything is possible. Just write the function.</p>
<blockquote>
<p>I tried implementing this recursive algorithm on my matrix in the meantime too, but keep getting that the recursive call is an "unknown identifier". Is there an import statement or something I'm missing</p>
</blockquote>
<p>I can't help you unless you post complete fully working code.</p>

<a name="189003309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189003309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189003309">Mario Carneiro (Feb 25 2020 at 09:28)</a>:</h4>
<p>You have to use the equation compiler if you want to write a recursive function like that, i.e.</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">type</span>
<span class="bp">|</span> <span class="n">case1</span> <span class="o">:=</span> <span class="n">bla</span>
<span class="bp">|</span> <span class="n">case2</span> <span class="o">:=</span> <span class="n">foo</span> <span class="n">bar</span>
</pre></div>

<a name="189003449"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189003449" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189003449">Kevin Buzzard (Feb 25 2020 at 09:31)</a>:</h4>
<p>Is the issue simply that <code>row_product_helper</code> is defined after you use it in <code>row_product</code>? No import will help you there, you have to define things before you use them.</p>

<a name="189012124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189012124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189012124">Kevin Buzzard (Feb 25 2020 at 11:43)</a>:</h4>
<p>PS I found <a href="http://learnyouahaskell.com/" target="_blank" title="http://learnyouahaskell.com/">learn you a haskell</a> really helpful when I was trying to figure out what functional languages looked like in general.</p>

<a name="189057294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189057294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189057294">Rocky Kamen-Rubio (Feb 25 2020 at 20:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003202" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003202">said</a>:</p>
<blockquote>
<blockquote>
<p>(unless there's a snazzy way to get the rows and columns from a matrix as a list instead of as vectors, but it seems like that's not possible). </p>
</blockquote>
<p>I don't really know what you mean. Anything is possible. Just write the function.</p>
</blockquote>
<p>Looking at the documentation for <code>row</code> it looks like it returns a vector not a list. You're right though that I could just convert it to a list and then product. Maybe this is an indication that a more functional approach would be preferred/more in line with how Lean is built?</p>
<blockquote>
<blockquote>
<p>I tried implementing this recursive algorithm on my matrix in the meantime too, but keep getting that the recursive call is an "unknown identifier". Is there an import statement or something I'm missing</p>
</blockquote>
<p>I can't help you unless you post complete fully working code.</p>
</blockquote>
<p>I posted the code I have below the text. Is it not visible to you? Do you mean that I need to include all my import statements as well?</p>

<a name="189057456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189057456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189057456">Rocky Kamen-Rubio (Feb 25 2020 at 20:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003449" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003449">said</a>:</p>
<blockquote>
<p>Is the issue simply that <code>row_product_helper</code> is defined after you use it in <code>row_product</code>? No import will help you there, you have to define things before you use them.</p>
</blockquote>
<p>Even reversing the order of the two definitions, the recursive call in <code>row_product_helper</code> gives me an error. I'll check out learn you a haskell and see if that gives me more clarity. Thank you!</p>

<a name="189057510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189057510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189057510">Kevin Buzzard (Feb 25 2020 at 20:26)</a>:</h4>
<p>I cut and pasted the code you posted and it didn't work. Yes, include everything which makes it work!</p>

<a name="189057549"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189057549" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189057549">Rocky Kamen-Rubio (Feb 25 2020 at 20:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003309" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189003309">said</a>:</p>
<blockquote>
<p>You have to use the equation compiler if you want to write a recursive function like that, i.e.</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">type</span>
<span class="bp">|</span> <span class="n">case1</span> <span class="o">:=</span> <span class="n">bla</span>
<span class="bp">|</span> <span class="n">case2</span> <span class="o">:=</span> <span class="n">foo</span> <span class="n">bar</span>
</pre></div>


</blockquote>
<p>Interesting. I'll try rewriting my function like this and see if it helps. Thank you!</p>

<a name="189057995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189057995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189057995">Rocky Kamen-Rubio (Feb 25 2020 at 20:30)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189057510" title="#narrow/stream/113489-new-members/topic/Simplifying.20Prop.20with.20Known.20False.20Statements/near/189057510">said</a>:</p>
<blockquote>
<p>I cut and pasted the code you posted and it didn't work. Yes, include everything which makes it work!</p>
</blockquote>
<p>I added the import statements. I'll be sure to include them in future posts.</p>

<a name="189062310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189062310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189062310">Kevin Buzzard (Feb 25 2020 at 21:17)</a>:</h4>
<p>Your code doesn't work because you use <code>row_product_helper</code> before you define it. And if you switch the order of <code>row_product_helper</code> and <code>row_product</code> it doesn't work because <code>mat r c</code> doesn't make sense because <code>r</code> has type <code>nat</code> and not type <code>fin m</code>.  But even if you fix that it won't work because you can't use <code>row_product_helper</code> in the definition of <code>row_product_helper</code>, that doesn't make sense in functional programming.</p>

<a name="189064024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Simplifying%20Prop%20with%20Known%20False%20Statements/near/189064024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/85769SimplifyingPropwithKnownFalseStatements.html#189064024">Kevin Buzzard (Feb 25 2020 at 21:39)</a>:</h4>
<p>I now understand Mario's reply (I'm much less good than some other people at "guessing what the user meant"). You can use the definition of X when defining X, as long as you only run X on strictly "smaller" things. Here's a less abstract example:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">Fib</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">Fib</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">Fib</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>


<p>You might want to read about how the equation compiler works in <a href="https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html">Theorem Proving In Lean</a>, although depending on what you know you might have to read a bunch of earlier chapters first.</p>


{% endraw %}

{% include archive_update.html %}