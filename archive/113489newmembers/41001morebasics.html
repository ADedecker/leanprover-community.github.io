---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/41001morebasics.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html">more basics</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="186021159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186021159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186021159">Iocta (Jan 19 2020 at 02:14)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">classical</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kn">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kn">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span><span class="n">x</span> <span class="o">:</span><span class="n">α</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span><span class="o">,</span> <span class="bp">_</span>
</pre></div>

<a name="186021212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186021212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186021212">Iocta (Jan 19 2020 at 02:16)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>  continuing</p>

<a name="186021223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186021223" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186021223">Bryan Gin-ge Chen (Jan 19 2020 at 02:17)</a>:</h4>
<p>(<a href="#narrow/stream/113489-new-members/topic/basics/near/186020919" title="#narrow/stream/113489-new-members/topic/basics/near/186020919">link to my past reply in the other thread</a>)</p>
<p>Since <code>α</code> lives in <code>Type</code>, you have to use something like <code>exists.classical_rec_on</code> from mathlib's <code>logic.basic</code>. Also, the example becomes <code>noncomputable</code> because it uses the <code>choice</code> axiom.</p>

<a name="186021243"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186021243" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186021243">Iocta (Jan 19 2020 at 02:18)</a>:</h4>
<p>Hmm, maybe this isn't what I need then. I'm doing this one from the exercises</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">classical</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kn">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kn">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">r</span> <span class="o">:=</span>
<span class="n">iff</span><span class="bp">.</span><span class="n">intro</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
<span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span>

<span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a&#39;</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">a&#39;</span><span class="o">)</span> <span class="n">h&#39;</span><span class="bp">.</span><span class="n">left</span><span class="o">)))</span>
<span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a&#39;</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">h&#39;</span><span class="bp">.</span><span class="n">right</span><span class="o">)))</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
<span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="k">have</span> <span class="n">ex</span><span class="o">:</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span><span class="bp">.</span><span class="n">left</span><span class="o">,</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span><span class="o">)</span>
</pre></div>

<a name="186021325"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186021325" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186021325">Iocta (Jan 19 2020 at 02:21)</a>:</h4>
<p>Is  the hole I need to fill here equivalent to the one in the smaller snippet?</p>

<a name="186021479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186021479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186021479">Iocta (Jan 19 2020 at 02:28)</a>:</h4>
<p>or maybe I'm just going about this the wrong way..</p>

<a name="186021578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186021578" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186021578">Bryan Gin-ge Chen (Jan 19 2020 at 02:31)</a>:</h4>
<p>This one can be done without <code>classical</code>. This should hopefully get you on the right track:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">r</span> <span class="o">:=</span>
<span class="n">iff</span><span class="bp">.</span><span class="n">intro</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">and</span><span class="bp">.</span><span class="n">intro</span>
    <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a&#39;</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">a&#39;</span><span class="o">)</span> <span class="n">h&#39;</span><span class="bp">.</span><span class="n">left</span><span class="o">))</span>
    <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a&#39;</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">h&#39;</span><span class="bp">.</span><span class="n">right</span><span class="o">))</span>
<span class="o">)</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="bp">_</span><span class="o">))</span>
</pre></div>

<a name="186021800"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186021800" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186021800">Iocta (Jan 19 2020 at 02:38)</a>:</h4>
<p>Got it, thanks.</p>

<a name="186653006"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186653006" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186653006">Iocta (Jan 27 2020 at 04:47)</a>:</h4>
<p>I'm trying to figure out how to use <code>exists.elim</code>, so I wanted to put an underscore in that <code>(\lambda z, _)</code> and have it tell me what type <code>z</code> has. How can I make it tell me?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∨</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">iff</span><span class="bp">.</span><span class="n">intro</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
<span class="o">(</span><span class="k">have</span> <span class="n">foo</span><span class="o">:</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="bp">_</span><span class="o">),</span>
<span class="bp">_</span><span class="o">)</span>
<span class="o">)</span>
<span class="bp">_</span>
</pre></div>

<a name="186654064"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186654064" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186654064">Kenny Lau (Jan 27 2020 at 05:19)</a>:</h4>
<p>well what is the type of <code>p</code>?</p>

<a name="186654070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186654070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186654070">Kenny Lau (Jan 27 2020 at 05:20)</a>:</h4>
<p>also you should be able to see the type of <code>z</code> in the underscore after it?</p>

<a name="186656010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186656010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186656010">Iocta (Jan 27 2020 at 06:16)</a>:</h4>
<blockquote>
<p>also you should be able to see the type of z in the underscore after it?</p>
</blockquote>
<p>That's what I expected, but it doesn't appear</p>

<a name="186656164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186656164" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186656164">Mario Carneiro (Jan 27 2020 at 06:21)</a>:</h4>
<p>When I put that in lean, there is an error over "exists" saying it can't synthesize <code>|- Prop</code>, but I can still hover over <code>z</code> to see <code>z : α</code></p>

<a name="186656224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186656224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186656224">Mario Carneiro (Jan 27 2020 at 06:22)</a>:</h4>
<p>You can't use <code>exists.elim</code> unless lean knows what you are trying to prove (the <code>_</code> in <code>foo: _</code>)</p>

<a name="186656241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186656241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186656241">Mario Carneiro (Jan 27 2020 at 06:23)</a>:</h4>
<p>If I remove the <code>have</code> and just use</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∨</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">iff</span><span class="bp">.</span><span class="n">intro</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
<span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="bp">_</span><span class="o">))</span>
<span class="o">)</span>
<span class="bp">_</span>
</pre></div>


<p>then the underscores are highlighted as you would expect</p>

<a name="186656476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186656476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186656476">Iocta (Jan 27 2020 at 06:31)</a>:</h4>
<p>ah putting the cursor over <code>z</code> does display its type</p>

<a name="186656569"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186656569" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186656569">Iocta (Jan 27 2020 at 06:33)</a>:</h4>
<p>I didn't see it originally because there's a fair amount of latency before it appears</p>

<a name="186656634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186656634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186656634">Iocta (Jan 27 2020 at 06:35)</a>:</h4>
<p>dunno if that's an intentional delay in  <code>lean-mode</code> to make it less distracting or it's just slow</p>

<a name="186656745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186656745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186656745">Mario Carneiro (Jan 27 2020 at 06:38)</a>:</h4>
<p>I would guess it's a mix of intentional latency by vscode and lean latency. Hovers that are too aggressive can really get in your way</p>

<a name="186656754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186656754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186656754">Mario Carneiro (Jan 27 2020 at 06:38)</a>:</h4>
<p>there is a setting for hover delay in preferences</p>

<a name="186656820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186656820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186656820">Iocta (Jan 27 2020 at 06:40)</a>:</h4>
<p>i'm using emacs,  it just appears in the bottom bar rather than hovering</p>

<a name="186659494"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186659494" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186659494">Iocta (Jan 27 2020 at 07:43)</a>:</h4>
<p>How can I fill the holes? </p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kn">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>
<span class="kn">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∨</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="n">q</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">iff</span><span class="bp">.</span><span class="n">intro</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">h1</span><span class="o">,</span>
  <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h1</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">a&#39;</span> <span class="n">hpq</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="n">hpq</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">pa</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">a&#39;</span> <span class="n">pa</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">pq</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">a&#39;</span> <span class="n">pq</span><span class="o">))))</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">h2</span><span class="o">,</span> <span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">a</span>
  <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h2</span>
    <span class="o">(</span><span class="bp">λ</span><span class="n">z</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">z</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">s&#39;</span><span class="o">,</span> <span class="bp">_</span><span class="o">)))</span>
    <span class="o">(</span><span class="bp">λ</span><span class="n">z</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="bp">_</span><span class="o">)))</span>
</pre></div>

<a name="186661314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186661314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186661314">Kevin Buzzard (Jan 27 2020 at 08:23)</a>:</h4>
<p>Neither of them look true to me so you can't fill them in.</p>

<a name="186662657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186662657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186662657">Mario Carneiro (Jan 27 2020 at 08:51)</a>:</h4>
<p>the bad move was <code>exists.intro a</code>. The variable <code>a</code> is not necessary and has nothing to do with the <code>x</code> that satisfies the assumption</p>

<a name="186724126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186724126" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186724126">Iocta (Jan 27 2020 at 20:49)</a>:</h4>
<p>Ok got it.</p>

<a name="186724287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186724287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186724287">Iocta (Jan 27 2020 at 20:50)</a>:</h4>
<p>Might be nice if it would warn me I was spending time trying to fill something that wasn't fillable, if it could tell</p>

<a name="186729050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186729050" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186729050">Kevin Buzzard (Jan 27 2020 at 21:40)</a>:</h4>
<p>I am pretty sure that such a thing is undecidable!</p>

<a name="186861142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186861142" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186861142">Iocta (Jan 29 2020 at 07:08)</a>:</h4>
<p>Am I on the right track?</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">classical</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">iff</span><span class="bp">.</span><span class="n">intro</span>
<span class="o">(</span><span class="k">assume</span> <span class="n">p_all_x</span> <span class="n">exists_npx</span><span class="o">,</span>
  <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span>
    <span class="n">exists_npx</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">hnpa</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hpa</span><span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span>  <span class="n">p_all_x</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">absurd</span> <span class="n">hpa</span> <span class="n">hnpa</span> <span class="o">))</span>
<span class="o">(</span><span class="k">assume</span> <span class="n">exists_npx</span> <span class="n">a</span><span class="o">,</span>
  <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span>  <span class="o">(</span><span class="n">p</span> <span class="n">a</span><span class="o">))</span>
  <span class="n">id</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">hnpa</span><span class="o">,</span> <span class="bp">_</span><span class="o">))</span>
</pre></div>

<a name="186861463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186861463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186861463">Kevin Buzzard (Jan 29 2020 at 07:14)</a>:</h4>
<p>Well you're not using tactic mode so you're already at a big disadvantage</p>

<a name="186861496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186861496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186861496">Kevin Buzzard (Jan 29 2020 at 07:15)</a>:</h4>
<p>I'm not at lean right now but if you post the local context at the underscore (the assumptions and goal) it should be easy to see whether or not the hole is fillable</p>

<a name="186861593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186861593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186861593">Iocta (Jan 29 2020 at 07:18)</a>:</h4>
<div class="codehilite"><pre><span></span> <span class="mi">04</span><span class="n">e</span><span class="bp">.</span><span class="n">lean</span>    <span class="mi">60</span>  <span class="mi">12</span> <span class="n">error</span>           <span class="n">don&#39;t</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
 <span class="kn">context</span><span class="o">:</span>
 <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
 <span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
 <span class="n">exists_npx</span> <span class="o">:</span> <span class="bp">¬∃</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">x</span><span class="o">,</span>
 <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
 <span class="n">hnpa</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span> <span class="n">a</span>
 <span class="err">⊢</span> <span class="n">p</span> <span class="n">a</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
</pre></div>

<a name="186861647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186861647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186861647">Johan Commelin (Jan 29 2020 at 07:19)</a>:</h4>
<p>How would you prove it in maths?</p>

<a name="186862052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186862052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186862052">Kevin Buzzard (Jan 29 2020 at 07:27)</a>:</h4>
<p>Yeah -- the hole is fillable but as Johan says you need to know where you're going.</p>

<a name="186862129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186862129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186862129">Kevin Buzzard (Jan 29 2020 at 07:29)</a>:</h4>
<p>and it would be a little easier to fill it in tactic mode. Are you using Lean in a funny way? I'd be tempted to just type "begin end" in place of that underscore. Are you not using Lean "live"?</p>

<a name="186862307"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186862307" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186862307">Iocta (Jan 29 2020 at 07:33)</a>:</h4>
<p>I have emacs running lean-mode with flycheck, not sure if that's normal</p>

<a name="186862400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186862400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186862400">Iocta (Jan 29 2020 at 07:35)</a>:</h4>
<p>I haven't seen begin or end yet. been going through the tutorial. currently at <a href="https://leanprover.github.io/theorem_proving_in_lean/quantifiers_and_equality.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/quantifiers_and_equality.html">https://leanprover.github.io/theorem_proving_in_lean/quantifiers_and_equality.html</a></p>

<a name="186862567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186862567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186862567">Johan Commelin (Jan 29 2020 at 07:38)</a>:</h4>
<p><span class="user-mention" data-user-id="253355">@Iocta</span> Honest question: are you a computer scientist or a mathematician? This seems to matter a lot for which style is best when learning Lean.</p>

<a name="186862579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186862579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186862579">Johan Commelin (Jan 29 2020 at 07:39)</a>:</h4>
<p>You are currently learning in CS mode. But there are also tutorials that approach Lean in math mode.</p>

<a name="186862648"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186862648" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186862648">Johan Commelin (Jan 29 2020 at 07:40)</a>:</h4>
<p>E.g. <a href="http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/" target="_blank" title="http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/">http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/</a></p>

<a name="186862901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186862901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186862901">Iocta (Jan 29 2020 at 07:46)</a>:</h4>
<p>Oh interesting, I hadn't seen that, will take a look.</p>

<a name="186864477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/186864477" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#186864477">Kevin Buzzard (Jan 29 2020 at 08:19)</a>:</h4>
<blockquote>
<p>I haven't seen begin or end yet. been going through the tutorial. currently at <a href="https://leanprover.github.io/theorem_proving_in_lean/quantifiers_and_equality.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/quantifiers_and_equality.html">https://leanprover.github.io/theorem_proving_in_lean/quantifiers_and_equality.html</a></p>
</blockquote>
<p>You are just one chapter away from Nirvana :-)</p>

<a name="187612487"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/187612487" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#187612487">Iocta (Feb 07 2020 at 04:22)</a>:</h4>
<p>I'm returning to this problem. I got one step forward(?) but not seeing how to proceed. </p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kn">variable</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>


<span class="kn">theorem</span> <span class="n">contrapositive</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span><span class="n">q</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span> <span class="n">hnq</span> <span class="n">hp</span><span class="o">,</span> <span class="n">hnq</span> <span class="o">(</span><span class="n">h</span> <span class="n">hp</span><span class="o">)</span>


<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">iff</span><span class="bp">.</span><span class="n">intro</span>
<span class="o">(</span><span class="k">assume</span> <span class="n">p_all_x</span> <span class="n">exists_npx</span><span class="o">,</span>
  <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span>
    <span class="n">exists_npx</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">hnpa</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hpa</span><span class="o">:</span> <span class="n">p</span> <span class="n">a</span><span class="o">,</span> <span class="k">from</span>  <span class="n">p_all_x</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">absurd</span> <span class="n">hpa</span> <span class="n">hnpa</span> <span class="o">))</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">cont</span><span class="o">:</span> <span class="bp">¬∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">→</span> <span class="bp">∃</span><span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">from</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">z</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">z</span> <span class="o">(</span><span class="bp">_</span><span class="o">)</span> <span class="bp">_</span><span class="o">)),</span>
  <span class="n">contrapositive</span> <span class="n">cont</span>
<span class="o">)</span>
</pre></div>

<a name="187612596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/187612596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#187612596">Iocta (Feb 07 2020 at 04:25)</a>:</h4>
<p>In math I'm not sure I've dug beneath the level of "when negating, just flip the quantifiers" so maybe some strategy there is what I'm missing</p>

<a name="187612915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/187612915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#187612915">Yury G. Kudryashov (Feb 07 2020 at 04:34)</a>:</h4>
<p>You can't prove <code>¬ (∃ x, ¬ p x) → (∀ x, p x)</code> without using classical reasoning. Your term proves <code>¬ (∃ x, ¬ p x) → ¬¬(∀ x, p x)</code>.</p>

<a name="187741047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/187741047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#187741047">Daniel Keys (Feb 09 2020 at 02:34)</a>:</h4>
<p><span class="user-mention" data-user-id="253355">@Iocta</span> Here is a lengthy solution to that problem. I also had some issues with one of the directions, but ended up with two solutions after I was helped. The <code>L_2</code> one using tactic mode is the one that I thought of in the first place but didn't know how to implement. The<code>L_1</code>can be found within the topics in this chat room. You'll need to <code>open classical</code>.</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kn">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>

<span class="kn">theorem</span> <span class="n">T05R</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intro</span> <span class="n">hall</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">hexi</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">hexi</span> <span class="k">with</span> <span class="n">w</span> <span class="n">hw</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">hw</span> <span class="o">(</span><span class="n">hall</span> <span class="n">w</span><span class="o">)</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">T05L_1</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="k">assume</span> <span class="n">hnExnpx</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">),</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="o">(</span><span class="n">p</span> <span class="n">x</span><span class="o">))</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">hpx</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span> <span class="n">hpx</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="n">hnpx</span> <span class="o">:</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">hnExnpx</span> <span class="o">(</span><span class="n">exists</span><span class="bp">.</span><span class="n">intro</span> <span class="n">x</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hpx</span> <span class="o">:</span> <span class="n">p</span> <span class="n">x</span><span class="o">,</span> <span class="n">hnpx</span> <span class="n">hpx</span><span class="o">))))))</span>

<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">classical</span><span class="bp">.</span><span class="n">prop_decidable</span>
<span class="kn">theorem</span> <span class="n">T05L_2</span> <span class="o">:</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">intros</span> <span class="n">h</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">by_contradiction</span> <span class="n">H</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">existsi</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H</span>
<span class="kn">end</span>
<span class="kn">theorem</span> <span class="n">T05</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">x</span><span class="o">,</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">¬</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">x</span><span class="o">,</span> <span class="bp">¬</span> <span class="n">p</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">exact</span> <span class="n">iff</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="n">T05R</span> <span class="n">α</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">T05L_2</span> <span class="n">α</span> <span class="n">p</span> <span class="n">a</span><span class="o">)</span>
<span class="kn">end</span>
</pre></div>

<a name="188380848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188380848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188380848">Dan Stanescu (Feb 17 2020 at 14:14)</a>:</h4>
<p>Newbie question: is there a built-in way to change a goal of the form <code>a ≠ b</code> to <code>a = b -&gt; false</code>? I tried doing <code>by_contradiction</code> on it, but it changes instead to <code>¬a ≠ b</code>. I can get what I want by something like:</p>
<div class="codehilite"><pre><span></span>theorem zNEo1 : (0 ≠ 1) = ¬ (0 = 1) := rfl
theorem zNEo2 : ¬ (0 = 1) → (0 ≠ 1) :=
begin
    intro h,
    rw zNEo1,
    exact h,
end
</pre></div>


<p>but I feel there should be a better way.</p>

<a name="188380987"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188380987" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188380987">Patrick Massot (Feb 17 2020 at 14:16)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">zNEo2</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≠</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">change</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">→</span> <span class="n">false</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>Is this what you want?</p>

<a name="188382765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188382765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188382765">Dan Stanescu (Feb 17 2020 at 14:38)</a>:</h4>
<p>Yes, apparently this takes care of it. Didn't encounter <code>change</code> before. Thank you!</p>

<a name="188382836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188382836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188382836">Chris Hughes (Feb 17 2020 at 14:39)</a>:</h4>
<p>It might also be useful to just <code>intro h</code>, and it automatically unfolds <code>\ne</code></p>

<a name="188382839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188382839" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188382839">Patrick Massot (Feb 17 2020 at 14:39)</a>:</h4>
<p>It changes the goal to anything which is the same by definition (in a very precise sense).</p>

<a name="188383343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188383343" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188383343">Dan Stanescu (Feb 17 2020 at 14:45)</a>:</h4>
<p>I thought I tried <code>intro</code>, but apparently not. So <code>0 ≠ 1</code> is indeed defined as <code>0 = 1 → false</code> then?</p>

<a name="188383353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188383353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188383353">Patrick Massot (Feb 17 2020 at 14:45)</a>:</h4>
<p>Yes.</p>

<a name="188383445"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188383445" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188383445">Patrick Massot (Feb 17 2020 at 14:46)</a>:</h4>
<p>Are you using VScode?</p>

<a name="188383468"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188383468" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188383468">Dan Stanescu (Feb 17 2020 at 14:46)</a>:</h4>
<p>Yes.</p>

<a name="188383578"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188383578" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188383578">Patrick Massot (Feb 17 2020 at 14:48)</a>:</h4>
<p>You can right-click on the <code>≠</code> symbol, choose "Go to definition" to get to <a href="https://github.com/leanprover/lean/blob/master/library/init/logic.lean#L97-L98" target="_blank" title="https://github.com/leanprover/lean/blob/master/library/init/logic.lean#L97-L98">https://github.com/leanprover/lean/blob/master/library/init/logic.lean#L97-L98</a> then do the same on the negation symbol to go to <a href="https://github.com/leanprover/lean/blob/master/library/init/core.lean#L142-L143" target="_blank" title="https://github.com/leanprover/lean/blob/master/library/init/core.lean#L142-L143">https://github.com/leanprover/lean/blob/master/library/init/core.lean#L142-L143</a></p>

<a name="188383686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188383686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188383686">Patrick Massot (Feb 17 2020 at 14:49)</a>:</h4>
<p>This may look like a hard way of learning (sounds like: code is the documentation). But this is actually part of why proof assistants are so cool compared to traditional textbooks: you can always ask and get the answer.</p>

<a name="188385352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188385352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188385352">Dan Stanescu (Feb 17 2020 at 15:08)</a>:</h4>
<p>That is great advice. I didn't know about right-click, I only knew to hover the mouse over symbols to get how to type them.</p>

<a name="188385719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188385719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188385719">Dan Stanescu (Feb 17 2020 at 15:13)</a>:</h4>
<p>Actually one more question along the same lines. The manual talks about double negation elimination after the excluded middle <code>em</code>, but is there a way to have Lean replace <code>¬ ¬ P</code> by <code>P</code> without writing our own tool?</p>

<a name="188386870"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188386870" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188386870">Dan Stanescu (Feb 17 2020 at 15:27)</a>:</h4>
<p>Just realized I can probably  <code>change</code> it again. <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>

<a name="188386903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188386903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188386903">Chris Hughes (Feb 17 2020 at 15:27)</a>:</h4>
<p>You can't just <code>change</code> it because they're not equal by definition. There is a lemma <code>classical.not_not</code> you could use to rewrite it.</p>

<a name="188386996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188386996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188386996">Dan Stanescu (Feb 17 2020 at 15:28)</a>:</h4>
<p>Great! Thanks again!</p>

<a name="188387327"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/188387327" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#188387327">Patrick Massot (Feb 17 2020 at 15:33)</a>:</h4>
<p><code>push_neg</code> should do that for you as well.</p>

<a name="189044184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189044184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189044184">Daniel Keys (Feb 25 2020 at 18:03)</a>:</h4>
<p>Can someone explain why I can evaluate the truth value of the 'divide' but not the 'belongs' proposition below? Is there a way to evaluate <code>tt</code> or <code>ff</code> for the latter?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>

<span class="n">def</span> <span class="n">A1</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">}</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="mi">1</span> <span class="err">∈</span> <span class="n">A1</span><span class="o">)</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="o">(</span><span class="mi">1</span> <span class="err">∈</span> <span class="n">A1</span><span class="o">)</span>
<span class="c1">-- #reduce to_bool (1 ∈ A1) fails</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="mi">2</span> <span class="err">∣</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">))</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">to_bool</span> <span class="o">(</span><span class="mi">2</span> <span class="err">∣</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">))</span>
</pre></div>

<a name="189048531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189048531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189048531">Daniel Keys (Feb 25 2020 at 18:48)</a>:</h4>
<p>Or is this a bug?</p>

<a name="189048534"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189048534" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189048534">Bryan Gin-ge Chen (Feb 25 2020 at 18:48)</a>:</h4>
<p>Hmm, I can't reproduce this. With no imports, with both Lean 3.4.2 and Lean 3.5.1, it's the last line which fails with </p>
<div class="codehilite"><pre><span></span>failed to synthesize type class instance for
⊢ decidable (2 ∣ 0)
</pre></div>


<p>With a recent mathlib imported (e.g. with <code>import data.int.basic</code> at the start of the file), I get no errors at all.</p>
<p>Can you say more about what version of Lean you're using / if you're importing some version of mathlib?</p>

<a name="189048573"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189048573" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189048573">Bryan Gin-ge Chen (Feb 25 2020 at 18:49)</a>:</h4>
<p>Oh, sorry, I misunderstood. You commented out the line that fails. Let me try again.</p>

<a name="189048677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189048677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189048677">Daniel Keys (Feb 25 2020 at 18:50)</a>:</h4>
<p>I only <code>import set</code>, the <code>divides</code> works with just that. I edited to include the import.</p>

<a name="189048737"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189048737" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189048737">Bryan Gin-ge Chen (Feb 25 2020 at 18:51)</a>:</h4>
<p>Well, it's not a bug. The error is</p>
<div class="codehilite"><pre><span></span>failed to synthesize type class instance for
⊢ decidable (1 ∈ A1)
</pre></div>


<p>which makes sense, since general set membership is not decidable.</p>

<a name="189048935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189048935" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189048935">Daniel Keys (Feb 25 2020 at 18:54)</a>:</h4>
<p>Is there something I can do about actually evaluating it? The <code>#reduce</code> does show a <code>Prop</code> which should evaluate to <code>tt</code>.</p>

<a name="189048939"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189048939" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189048939">Bryan Gin-ge Chen (Feb 25 2020 at 18:54)</a>:</h4>
<p>For explicit finite sets like this, you might want to use <code>finset</code>s instead:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>

<span class="n">def</span> <span class="n">F1</span> <span class="o">:</span> <span class="n">finset</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">}</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">to_bool</span> <span class="o">(</span><span class="mi">1</span> <span class="err">∈</span> <span class="n">F1</span><span class="o">)</span> <span class="c1">-- tt</span>
</pre></div>

<a name="189049048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189049048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189049048">Daniel Keys (Feb 25 2020 at 18:55)</a>:</h4>
<p>OK, thanks! That works!</p>

<a name="189049148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189049148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189049148">Kevin Buzzard (Feb 25 2020 at 18:56)</a>:</h4>
<p>There's a difference between "I know how to prove this in this one case" and "Lean has an algorithm which will solve all questions of this type", that's what's going on</p>

<a name="189049360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189049360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189049360">Bryan Gin-ge Chen (Feb 25 2020 at 18:58)</a>:</h4>
<p>There is a question here that I don't know how to answer. How would you tell Lean to reduce the argument <code>(1 ∈ A1)</code> before attempting to apply <code>to_bool</code> to it? Somehow, Lean can reduce <code>(1 ∈ A1)</code> to <code>(1 = 3 ∨ 1 = 2 ∨ 1 = 1 ∨ false)</code> and <code>#reduce to_bool (1 = 3 ∨ 1 = 2 ∨ 1 = 1 ∨ false)</code> returns <code>tt</code>, as expected.</p>

<a name="189049368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189049368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189049368">Daniel Keys (Feb 25 2020 at 18:58)</a>:</h4>
<p>What is interesting is that the <code>#reduce</code> alone seems to show the same output for both <code>finset</code> and <code>set</code>. Like <code>1 = 3 ∨ 1 = 2 ∨ 1 = 1 ∨ false</code> for both.</p>

<a name="189049501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189049501" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189049501">Daniel Keys (Feb 25 2020 at 19:00)</a>:</h4>
<p>Obviously I was typing at the same time as Bryan Gin-ge Chen.</p>

<a name="189049745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189049745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189049745">Bryan Gin-ge Chen (Feb 25 2020 at 19:02)</a>:</h4>
<p>You might find it interesting to include <code>set_option pp.all true</code> at the start of the file and then look at <code>#print A1</code> and <code>#print F1</code> to see how their internals differ.</p>

<a name="189049950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189049950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189049950">Kevin Buzzard (Feb 25 2020 at 19:04)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">A3</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">a</span> <span class="err">^</span> <span class="mi">3</span> <span class="bp">=</span> <span class="n">b</span> <span class="err">^</span> <span class="mi">3</span> <span class="bp">+</span> <span class="n">c</span> <span class="err">^</span> <span class="mi">3</span><span class="o">}</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">to_bool</span> <span class="o">(</span><span class="mi">42</span> <span class="err">∈</span> <span class="n">A3</span><span class="o">)</span>
</pre></div>


<p>Here's an illustration of the original set problem. Until a few months ago, it was not known whether 42 was in this set or not.</p>

<a name="189050103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189050103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189050103">Kevin Buzzard (Feb 25 2020 at 19:06)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">def</span> <span class="n">A3</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="n">n</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">a</span> <span class="err">^</span> <span class="mi">3</span> <span class="bp">=</span> <span class="n">b</span> <span class="err">^</span> <span class="mi">3</span> <span class="bp">+</span> <span class="n">c</span> <span class="err">^</span> <span class="mi">3</span><span class="o">}</span>

<span class="kn">example</span> <span class="o">:</span> <span class="mi">42</span> <span class="err">∈</span> <span class="n">A3</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">use</span> <span class="mi">80538738812075974</span><span class="o">,</span>
  <span class="n">use</span> <span class="mi">80435758145817515</span><span class="o">,</span>
  <span class="n">use</span> <span class="mi">12602123297335631</span><span class="o">,</span>
  <span class="n">norm_num</span>
<span class="kn">end</span>
</pre></div>

<a name="189050544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189050544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189050544">Kevin Buzzard (Feb 25 2020 at 19:11)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">def</span> <span class="n">A1</span> <span class="o">:</span> <span class="n">set</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">:</span> <span class="n">decidable</span> <span class="o">(</span><span class="n">n</span> <span class="err">∈</span> <span class="n">A1</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">A1</span><span class="bp">;</span> <span class="n">simp</span><span class="bp">;</span> <span class="n">apply_instance</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">to_bool</span> <span class="o">(</span><span class="mi">1</span> <span class="err">∈</span> <span class="n">A1</span><span class="o">)</span> <span class="c1">-- tt</span>
</pre></div>

<a name="189050565"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189050565" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189050565">Daniel Keys (Feb 25 2020 at 19:11)</a>:</h4>
<p>This result is very recent indeed, Kevin. </p>
<p>I saw the difference in <code>finset</code> versus <code>set</code>. Although I can't read through all of it, <code>finset</code> has several places with <code>decidable</code>. I guess that makes for the different result.</p>

<a name="189050647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189050647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189050647">Daniel Keys (Feb 25 2020 at 19:12)</a>:</h4>
<p>Thank you both!</p>

<a name="189050825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189050825" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189050825">Bryan Gin-ge Chen (Feb 25 2020 at 19:14)</a>:</h4>
<p>It may be more enlightening to look at how <code>finset</code>s are implemented as compared to <code>set</code>s. In short, <code>finset</code>s are backed by explicit <code>list</code>s modulo ordering and a proof that each element occurs once, whereas <code>set</code>s are simply abstract functions to <code>Prop</code>.</p>

<a name="189050908"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189050908" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189050908">Daniel Keys (Feb 25 2020 at 19:15)</a>:</h4>
<p>Yes, indeed - this makes it clear.</p>

<a name="189050970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189050970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189050970">Kevin Buzzard (Feb 25 2020 at 19:16)</a>:</h4>
<div class="codehilite"><pre><span></span>finset.decidable_mem : Π {α : Type u_1} [h : decidable_eq α] (a : α) (s : finset α), decidable (a ∈ s)
</pre></div>


<p>Note that you still need decidable equality on your type, it's not just finiteness. The naturals have decidable equality.</p>

<a name="189051073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189051073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189051073">Kevin Buzzard (Feb 25 2020 at 19:17)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">finset</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">A1</span> <span class="o">:</span> <span class="n">finset</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">to_bool</span> <span class="o">((</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="err">∈</span> <span class="n">A1</span><span class="o">)</span> <span class="c1">-- fails</span>
</pre></div>


<p>The reals don't.</p>

<a name="189422894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189422894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189422894">Iocta (Mar 01 2020 at 07:06)</a>:</h4>
<p>Thanks.</p>

<a name="189422903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189422903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189422903">Iocta (Mar 01 2020 at 07:06)</a>:</h4>
<p>When applying <code>simp</code>, is there a way to find out what it did?</p>

<a name="189423078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189423078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189423078">Bryan Gin-ge Chen (Mar 01 2020 at 07:13)</a>:</h4>
<p>Yes, to a certain extent. See the options described <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/simp.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/simp.md">here</a>.</p>

<a name="189423126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189423126" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189423126">Bryan Gin-ge Chen (Mar 01 2020 at 07:14)</a>:</h4>
<p>There's also <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md#squeeze_simp--squeeze_simpa" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/tactics.md#squeeze_simp--squeeze_simpa"><code>squeeze_simp</code></a> if you import mathlib's tactics.</p>

<a name="189423309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189423309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189423309">Iocta (Mar 01 2020 at 07:21)</a>:</h4>
<p>aha</p>

<a name="189436592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189436592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189436592">Reid Barton (Mar 01 2020 at 15:16)</a>:</h4>
<p>I usually use <code>set_option trace.simplify.rewrite true</code> instead, that shows you only what <code>simp</code> actually did (at least approximately, I remember there being some weird caveats). The <code>trace.simplify</code> output is everything <code>simp</code> tried (which is to say, everything) even if it didn't work.</p>

<a name="189436601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189436601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189436601">Reid Barton (Mar 01 2020 at 15:16)</a>:</h4>
<p>Oh I see that's also documented a bit further down.</p>

<a name="189446290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189446290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189446290">Daniel Keys (Mar 01 2020 at 20:23)</a>:</h4>
<p>For a general <code>a :ℝ</code>, do we have anything that can be used to produce <code>0 ≤ a ^ 2</code>?  I've been trying with <code>norm_num</code>, but it doesn't work for all <code>a</code>.</p>

<a name="189446466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189446466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189446466">Alex J. Best (Mar 01 2020 at 20:28)</a>:</h4>
<p><code>pow_two_nonneg</code>  in <code>algebra/group_power.lean</code></p>

<a name="189446476"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189446476" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189446476">Daniel Keys (Mar 01 2020 at 20:29)</a>:</h4>
<p>Thanks! That is what I was after, but didn't know where to find it.</p>

<a name="189446584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189446584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189446584">Alex J. Best (Mar 01 2020 at 20:32)</a>:</h4>
<p>Yeah I had to guess the name and then search for it in the vscode menu, which requires a little experience, but in this case it is a mathlib convention that squaring is always called <code>pow_two</code> and that <code>0 ≤ </code>is called <code>nonneg</code>.</p>

<a name="189447008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189447008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189447008">Kevin Buzzard (Mar 01 2020 at 20:45)</a>:</h4>
<p>You could probably find this with <code>library_search</code></p>

<a name="189447265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189447265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189447265">Daniel Keys (Mar 01 2020 at 20:52)</a>:</h4>
<p>Didn't use <code>library_search</code> yet. Not sure how to use it. Don't you need to know something to start with, like <code>pow_two</code> for example?</p>

<a name="189447414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189447414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189447414">Alex J. Best (Mar 01 2020 at 20:56)</a>:</h4>
<p>Kevin is right you don't need to know anything for this really:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">real</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">≤</span> <span class="n">a</span><span class="err">^</span><span class="mi">2</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">library_search</span>
</pre></div>

<a name="189447416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189447416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189447416">Alex J. Best (Mar 01 2020 at 20:56)</a>:</h4>
<p>and library_search tells you exactly the same lemma name</p>

<a name="189447459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189447459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189447459">Daniel Keys (Mar 01 2020 at 20:58)</a>:</h4>
<p>I see! Great, thanks!</p>

<a name="189447480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189447480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189447480">Daniel Keys (Mar 01 2020 at 20:59)</a>:</h4>
<p>This will help a lot, it was very frustrating sometimes as I was searching through lots of files for almost everything.</p>

<a name="189939956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189939956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189939956">Iocta (Mar 06 2020 at 22:14)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c1">-- With simp</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">r</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">iff</span><span class="bp">.</span><span class="n">intro</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">simp</span> <span class="bp">*</span>
<span class="kn">end</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">simp</span> <span class="bp">*</span>
<span class="kn">end</span>
</pre></div>


<div class="codehilite"><pre><span></span> <span class="mi">05</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">lean</span>    <span class="mi">87</span>   <span class="mi">1</span> <span class="n">info</span>            <span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify</span><span class="bp">.</span><span class="n">rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span><span class="o">]:</span> <span class="n">p</span> <span class="bp">==&gt;</span> <span class="n">true</span>
 <span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify</span><span class="bp">.</span><span class="n">rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span><span class="o">]:</span> <span class="n">q</span> <span class="bp">==&gt;</span> <span class="n">true</span>
 <span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify</span><span class="bp">.</span><span class="n">rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span><span class="o">]:</span> <span class="n">r</span> <span class="bp">==&gt;</span> <span class="n">true</span>
 <span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify</span><span class="bp">.</span><span class="n">rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">and_self</span><span class="o">]:</span> <span class="n">true</span> <span class="bp">∧</span> <span class="n">true</span> <span class="bp">==&gt;</span> <span class="n">true</span>
 <span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify</span><span class="bp">.</span><span class="n">rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">and_self</span><span class="o">]:</span> <span class="n">true</span> <span class="bp">∧</span> <span class="n">true</span> <span class="bp">==&gt;</span> <span class="n">true</span>
 <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
 <span class="mi">05</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">lean</span>    <span class="mi">91</span>   <span class="mi">1</span> <span class="n">info</span>            <span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify</span><span class="bp">.</span><span class="n">rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span><span class="o">]:</span> <span class="n">p</span> <span class="bp">==&gt;</span> <span class="n">true</span>
 <span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify</span><span class="bp">.</span><span class="n">rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span><span class="o">]:</span> <span class="n">q</span> <span class="bp">==&gt;</span> <span class="n">true</span>
 <span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify</span><span class="bp">.</span><span class="n">rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">and_self</span><span class="o">]:</span> <span class="n">true</span> <span class="bp">∧</span> <span class="n">true</span> <span class="bp">==&gt;</span> <span class="n">true</span>
 <span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify</span><span class="bp">.</span><span class="n">rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">h</span><span class="o">]:</span> <span class="n">r</span> <span class="bp">==&gt;</span> <span class="n">true</span>
 <span class="mi">0</span><span class="bp">.</span> <span class="o">[</span><span class="n">simplify</span><span class="bp">.</span><span class="n">rewrite</span><span class="o">]</span> <span class="o">[</span><span class="n">and_self</span><span class="o">]:</span> <span class="n">true</span> <span class="bp">∧</span> <span class="n">true</span> <span class="bp">==&gt;</span> <span class="n">true</span>
 <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
</pre></div>


<p>How do I translate what <code>trace</code> is saying into code?</p>

<a name="189940104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189940104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189940104">Johan Commelin (Mar 06 2020 at 22:16)</a>:</h4>
<p>Use <code>squeeze_simp</code>?</p>

<a name="189940115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189940115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189940115">Johan Commelin (Mar 06 2020 at 22:17)</a>:</h4>
<p>It will turn it into code for you.</p>

<a name="189993194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189993194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189993194">Iocta (Mar 08 2020 at 00:52)</a>:</h4>
<p><code>squeeze_simp</code> doesn't seem to reduce the options much here. </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">r</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">iff</span><span class="bp">.</span><span class="n">intro</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">squeeze_simp</span> <span class="bp">*</span><span class="o">,</span> <span class="c1">-- Try this: simp only [*, and_self]</span>
<span class="kn">end</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">simp</span> <span class="bp">*</span>
<span class="kn">end</span>
</pre></div>


<p>How do I turn the output of <code>set_option trace.simplify.rewrite true</code> (in the example above) manually? I'm not sure what it's trying to tell me. How do I rewrite <code>[h] : q ==&gt; true</code>?</p>

<a name="189993472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189993472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189993472">Reid Barton (Mar 08 2020 at 01:03)</a>:</h4>
<p>This example is kind of too simple and relies more on internal behavior of simp than on lemmas.</p>

<a name="189993515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189993515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189993515">Reid Barton (Mar 08 2020 at 01:04)</a>:</h4>
<p>But you could start with <code>rw h.1.2</code></p>

<a name="189993517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189993517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189993517">Reid Barton (Mar 08 2020 at 01:04)</a>:</h4>
<p>Wait no</p>

<a name="189993518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189993518" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189993518">Kevin Buzzard (Mar 08 2020 at 01:04)</a>:</h4>
<p>cases h</p>

<a name="189993525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189993525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189993525">Reid Barton (Mar 08 2020 at 01:05)</a>:</h4>
<p>You need whatever lemma it is that says if <code>h : p</code>, then <code>p = true</code></p>

<a name="189993531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189993531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189993531">Kevin Buzzard (Mar 08 2020 at 01:05)</a>:</h4>
<p>just use cases and split</p>

<a name="189993532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189993532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189993532">Reid Barton (Mar 08 2020 at 01:05)</a>:</h4>
<p>This rewriting strategy is not a natural way to prove this particular example</p>

<a name="189993572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189993572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189993572">Kevin Buzzard (Mar 08 2020 at 01:06)</a>:</h4>
<p>high-powered tactics like <code>simp</code> and <code>rw</code> are not really needed for basic logic questions like this, just use the basic tactics.</p>

<a name="189994883"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189994883" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189994883">Iocta (Mar 08 2020 at 01:54)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="bp">∧</span> <span class="n">r</span> <span class="bp">↔</span> <span class="n">p</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">iff</span><span class="bp">.</span><span class="n">intro</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">hpq</span> <span class="n">hr</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hpq</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">apply</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span><span class="o">},</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">assumption</span><span class="o">},</span>
<span class="kn">end</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">hp</span> <span class="n">hqr</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hqr</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">apply</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span><span class="o">},</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">assumption</span><span class="o">},</span>
<span class="kn">end</span>
</pre></div>


<p>works. What would I do with <code>split</code> here?</p>

<a name="189994895"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189994895" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189994895">Kevin Buzzard (Mar 08 2020 at 01:55)</a>:</h4>
<p><code>split</code> stops you having to do <code>repeat</code></p>

<a name="189994898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189994898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189994898">Kevin Buzzard (Mar 08 2020 at 01:55)</a>:</h4>
<p>it splits an and goal into two goals</p>

<a name="189995439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/189995439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#189995439">Iocta (Mar 08 2020 at 02:17)</a>:</h4>
<p>Not quite seeing how to use it here. What's the function I want to apply to both branches?</p>

<a name="190003083"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190003083" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190003083">Iocta (Mar 08 2020 at 07:02)</a>:</h4>
<p>There must be a shorter way to write this?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">q</span> <span class="bp">→</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">h</span> <span class="n">hpq</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">hnp</span> <span class="n">hnq</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hpq</span> <span class="k">with</span> <span class="n">hp</span> <span class="n">hq</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">hnp</span> <span class="n">hp</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">hpq</span> <span class="k">with</span> <span class="n">hp</span> <span class="n">hq</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">hnq</span> <span class="n">hq</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="190003198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190003198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190003198">Kenny Lau (Mar 08 2020 at 07:07)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">logic</span><span class="bp">.</span><span class="n">basic</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">tauto</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">q</span> <span class="bp">→</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">not_and_of_not_or_not</span>
<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">q</span> <span class="bp">→</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">mt</span> <span class="n">and</span><span class="bp">.</span><span class="n">left</span><span class="o">)</span> <span class="o">(</span><span class="n">mt</span> <span class="n">and</span><span class="bp">.</span><span class="n">right</span><span class="o">)</span>
<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">q</span> <span class="bp">→</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">tauto</span>
</pre></div>

<a name="190003247"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190003247" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190003247">Iocta (Mar 08 2020 at 07:08)</a>:</h4>
<p>neat</p>

<a name="190033214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190033214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190033214">Iocta (Mar 08 2020 at 23:57)</a>:</h4>
<p>Am I down the wrong path?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="n">q</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span> <span class="k">with</span> <span class="n">hp</span> <span class="n">hnp</span><span class="o">,</span>
<span class="n">cases</span> <span class="o">(</span><span class="n">em</span> <span class="n">q</span><span class="o">)</span> <span class="k">with</span> <span class="n">hq</span> <span class="n">hnq</span><span class="o">,</span>
<span class="n">constructor</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">hp</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">hq&#39;</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">hp&#39;</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">hq</span><span class="o">,</span>
<span class="n">constructor</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">hp</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">hnq</span><span class="o">,</span>
<span class="n">cases</span> <span class="o">(</span><span class="n">em</span> <span class="n">q</span><span class="o">)</span> <span class="k">with</span> <span class="n">hq</span> <span class="n">hnq</span><span class="o">,</span>
<span class="n">constructor</span><span class="o">,</span>
<span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="190033268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190033268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190033268">Iocta (Mar 08 2020 at 23:58)</a>:</h4>
<div class="codehilite"><pre><span></span> <span class="kn">example</span><span class="err">…</span>   <span class="mi">335</span>   <span class="mi">1</span> <span class="n">error</span>           <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">there</span> <span class="n">are</span> <span class="n">unsolved</span> <span class="n">goals</span>
 <span class="n">state</span><span class="o">:</span>
 <span class="mi">2</span> <span class="n">goals</span>
 <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
 <span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">),</span>
 <span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span><span class="o">,</span>
 <span class="n">hq</span> <span class="o">:</span> <span class="n">q</span>
 <span class="err">⊢</span> <span class="bp">¬</span><span class="n">q</span>

 <span class="n">case</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span>
 <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
 <span class="n">h</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">),</span>
 <span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span><span class="o">,</span>
 <span class="n">hnq</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">q</span>
 <span class="err">⊢</span> <span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="n">q</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
</pre></div>

<a name="190033523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190033523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190033523">Kevin Buzzard (Mar 09 2020 at 00:06)</a>:</h4>
<p>You know <code>not X</code> is by definition <code>X -&gt; false</code>? So in the first goal you can <code>intro hq2</code> and then <code>revert h</code>! When your hypotheses can be used to get a contradiction as yours can, in both cases) then <code>exfalso</code> is sometimes a useful tactic; it replaces the goal by <code>false</code>.</p>

<a name="190034193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190034193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190034193">Iocta (Mar 09 2020 at 00:28)</a>:</h4>
<p>thanks</p>

<a name="190035643"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190035643" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190035643">Iocta (Mar 09 2020 at 01:21)</a>:</h4>
<div class="codehilite"><pre><span></span> <span class="mi">05</span><span class="bp">.</span><span class="mi">01</span><span class="bp">.</span><span class="n">b</span><span class="bp">.</span><span class="err">…</span>    <span class="mi">15</span>   <span class="mi">3</span> <span class="n">error</span>           <span class="n">solve1</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">focused</span> <span class="n">goal</span> <span class="n">has</span> <span class="n">not</span> <span class="n">been</span> <span class="n">solved</span>
 <span class="n">state</span><span class="o">:</span>
 <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
 <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">,</span>
 <span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">p</span> <span class="n">x</span> <span class="bp">∧</span> <span class="n">q</span> <span class="n">x</span><span class="o">,</span>
 <span class="n">x</span> <span class="o">:</span> <span class="n">α</span>
 <span class="err">⊢</span> <span class="n">p</span> <span class="n">x</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
</pre></div>


<p>In tactic mode: What's the equivalent of <code>intro h</code> here? I want to get inside of the <code>\forall</code>.</p>

<a name="190035696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190035696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190035696">Iocta (Mar 09 2020 at 01:22)</a>:</h4>
<p>(or is that not idiomatic?)</p>

<a name="190036029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190036029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190036029">Mario Carneiro (Mar 09 2020 at 01:35)</a>:</h4>
<p>It is generally easier to work forward at this point; <code>have h2 := h x</code> will give you a proof of <code>p x ∧ q x</code></p>

<a name="190036970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190036970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190036970">Iocta (Mar 09 2020 at 02:05)</a>:</h4>
<p>ok</p>

<a name="190040960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190040960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190040960">Reid Barton (Mar 09 2020 at 04:32)</a>:</h4>
<p>(what would you expect the tactic state to look like after intro h?)</p>

<a name="190103016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190103016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190103016">Iocta (Mar 09 2020 at 18:40)</a>:</h4>
<p>I guess <code>intro</code> isn't really the right word. What Mario said does what I wanted.</p>

<a name="190105752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190105752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190105752">Iocta (Mar 09 2020 at 19:05)</a>:</h4>
<p>How can I avoid repeating <code>assumption</code>?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">∨</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∨</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∨</span> <span class="n">r</span> <span class="bp">∨</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">split</span><span class="bp">;</span> <span class="n">try</span> <span class="o">{</span><span class="n">split</span><span class="o">}</span><span class="bp">;</span> <span class="o">{</span><span class="n">left</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span> <span class="bp">&lt;|&gt;</span> <span class="o">{</span><span class="n">right</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span> <span class="bp">&lt;|&gt;</span> <span class="o">{</span><span class="n">right</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span><span class="o">}</span>
</pre></div>

<a name="190107074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190107074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190107074">Johan Commelin (Mar 09 2020 at 19:19)</a>:</h4>
<p><span class="user-mention" data-user-id="253355">@Iocta</span>  I'm not sure if there is much you can do.</p>

<a name="190107115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190107115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190107115">Johan Commelin (Mar 09 2020 at 19:20)</a>:</h4>
<p>But if you want to golf this, then certainly <code>by tauto</code> is a lot shorter...</p>

<a name="190107527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190107527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190107527">Iocta (Mar 09 2020 at 19:23)</a>:</h4>
<p>Alright</p>

<a name="190107845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190107845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190107845">Johan Commelin (Mar 09 2020 at 19:26)</a>:</h4>
<p>I mean... I don't know if you wanted such a logic hammer...</p>

<a name="190135419"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190135419" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190135419">Mario Carneiro (Mar 10 2020 at 01:33)</a>:</h4>
<p>It's actually not a bad example of an introductory level tactic</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>
<span class="n">meta</span> <span class="n">def</span> <span class="n">leftright</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">itactic</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">t</span> <span class="bp">&lt;|&gt;</span> <span class="o">(</span><span class="n">tactic</span><span class="bp">.</span><span class="n">left</span> <span class="bp">&gt;&gt;</span> <span class="n">leftright</span><span class="o">)</span> <span class="bp">&lt;|&gt;</span> <span class="o">(</span><span class="n">tactic</span><span class="bp">.</span><span class="n">right</span> <span class="bp">&gt;&gt;</span> <span class="n">leftright</span><span class="o">)</span>
<span class="kn">end</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">∨</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∨</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∨</span> <span class="n">r</span> <span class="bp">∨</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">repeat</span> <span class="o">{</span><span class="n">split</span><span class="o">}</span><span class="bp">;</span> <span class="n">leftright</span> <span class="o">{</span><span class="n">assumption</span><span class="o">}</span>
</pre></div>

<a name="190135490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190135490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190135490">Mario Carneiro (Mar 10 2020 at 01:35)</a>:</h4>
<p>There is a completely different style of proof represented by</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span>
<span class="o">(</span><span class="n">p</span> <span class="bp">∨</span> <span class="n">q</span> <span class="bp">∨</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∨</span> <span class="n">p</span> <span class="bp">∨</span> <span class="n">r</span><span class="o">)</span> <span class="bp">∧</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∨</span> <span class="n">r</span> <span class="bp">∨</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hp</span><span class="o">]</span>
</pre></div>


<p>Here the idea is that you use rewrite rules <code>p ==&gt; true</code>, plus <code>true \/ a ==&gt; true</code>, <code>a \/ true ==&gt; true</code> and <code>true /\ true ==&gt; true</code> to simplify the entire goal to <code>true</code></p>

<a name="190141947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190141947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190141947">Iocta (Mar 10 2020 at 04:40)</a>:</h4>
<p>Ah cool</p>

<a name="190240817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190240817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190240817">Iocta (Mar 11 2020 at 00:38)</a>:</h4>
<p>How to fix this?</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">squeeze</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kn">inductive</span> <span class="n">natural</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">natural</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">natural</span> <span class="bp">→</span> <span class="n">natural</span>


<span class="kn">open</span> <span class="n">natural</span>


<span class="n">def</span> <span class="n">add</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">natural</span><span class="o">)</span> <span class="o">:</span> <span class="n">natural</span> <span class="o">:=</span>
<span class="n">natural</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="n">m</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">add_m_n</span><span class="o">,</span> <span class="n">succ</span> <span class="n">add_m_n</span><span class="o">)</span>

<span class="n">def</span> <span class="n">mul</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">natural</span><span class="o">)</span> <span class="o">:</span> <span class="n">natural</span> <span class="o">:=</span>
<span class="n">natural</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="n">zero</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">mul_m_n</span><span class="o">,</span> <span class="n">add</span> <span class="n">mul_m_n</span> <span class="n">m</span><span class="o">)</span>


<span class="n">def</span> <span class="n">pred</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">natural</span><span class="o">)</span> <span class="o">:</span> <span class="n">natural</span> <span class="o">:=</span>
<span class="n">natural</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="n">zero</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">pred_n</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span>

<span class="n">def</span> <span class="n">sub</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">natural</span><span class="o">)</span> <span class="o">:</span> <span class="n">natural</span> <span class="o">:=</span>
<span class="n">natural</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">n</span> <span class="n">m</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">sub_m_n</span><span class="o">,</span> <span class="n">pred</span> <span class="n">sub_m_n</span><span class="o">)</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="bp">&lt;*&gt;</span> <span class="bp">`</span> <span class="o">:=</span> <span class="n">mul</span>

<span class="kn">theorem</span> <span class="n">mul_dist_add</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="n">natural</span> <span class="o">)</span> <span class="o">:</span> <span class="n">k</span> <span class="bp">&lt;*&gt;</span>  <span class="n">add</span> <span class="n">m</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">k</span> <span class="bp">&lt;*&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kn">theorem</span> <span class="n">mul_assoc</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="n">natural</span> <span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span> <span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span> <span class="o">)</span> <span class="bp">=</span> <span class="o">(</span> <span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span> <span class="o">)</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span> <span class="o">:=</span>
<span class="n">natural</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">k</span>
<span class="o">(</span><span class="k">show</span> <span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="n">zero</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="bp">&lt;*&gt;</span> <span class="n">zero</span><span class="o">,</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">)</span>
<span class="o">(</span><span class="k">assume</span> <span class="n">k</span><span class="o">,</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">ih</span><span class="o">:</span>  <span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span> <span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span> <span class="o">)</span> <span class="bp">=</span> <span class="o">(</span> <span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span> <span class="o">)</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span><span class="o">,</span>
    <span class="k">show</span>  <span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span> <span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">succ</span> <span class="n">k</span><span class="o">)</span> <span class="o">)</span> <span class="bp">=</span> <span class="o">(</span> <span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span> <span class="o">)</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">succ</span> <span class="n">k</span><span class="o">),</span>
    <span class="k">from</span> <span class="k">calc</span>
      <span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span> <span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">succ</span> <span class="n">k</span><span class="o">)</span> <span class="o">)</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">add</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="n">n</span> <span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">refl</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span><span class="o">))</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span><span class="o">)</span>  <span class="o">:</span> <span class="k">by</span> <span class="n">apply</span> <span class="n">mul_dist_add</span>
      <span class="bp">...</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">((</span><span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">apply</span> <span class="n">ih</span>

  <span class="o">))</span>

<span class="kn">end</span> <span class="n">hidden</span>
</pre></div>


<div class="codehilite"><pre><span></span> <span class="mi">06</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">lean</span>    <span class="mi">40</span>  <span class="mi">50</span> <span class="n">error</span>           <span class="n">invalid</span> <span class="n">apply</span> <span class="n">tactic</span><span class="o">,</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">unify</span>
   <span class="n">add</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span><span class="o">))</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span><span class="o">)</span>
 <span class="k">with</span>
   <span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span>
 <span class="n">state</span><span class="o">:</span>
 <span class="n">m</span> <span class="n">n</span> <span class="n">k</span> <span class="n">k</span> <span class="o">:</span> <span class="n">natural</span><span class="o">,</span>
 <span class="n">ih</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span>
 <span class="err">⊢</span> <span class="n">add</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span><span class="o">))</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">add</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
</pre></div>

<a name="190240956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190240956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190240956">Reid Barton (Mar 11 2020 at 00:41)</a>:</h4>
<p>The easy way is <code>by rw ih</code></p>

<a name="190240957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190240957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190240957">Reid Barton (Mar 11 2020 at 00:41)</a>:</h4>
<p>there's also a harder way</p>

<a name="190241285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190241285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190241285">Iocta (Mar 11 2020 at 00:47)</a>:</h4>
<p>How do I do the harder way? I tried using <code>trace</code> to see what <code>simp *</code> was doing but it wasn't all that helpful</p>

<a name="190241299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190241299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190241299">Reid Barton (Mar 11 2020 at 00:47)</a>:</h4>
<p>Using <code>congr_arg</code> somehow</p>

<a name="190241347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190241347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190241347">Reid Barton (Mar 11 2020 at 00:48)</a>:</h4>
<p>maybe <code>congr_arg (\lam x, add x (m &lt;*&gt; n)) ih</code></p>

<a name="190241351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190241351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190241351">Reid Barton (Mar 11 2020 at 00:48)</a>:</h4>
<p>anyways, this is where <code>rw</code> starts to become indispensable</p>

<a name="190241574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190241574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190241574">Iocta (Mar 11 2020 at 00:53)</a>:</h4>
<p>ok that works</p>

<a name="190241638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190241638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190241638">Mario Carneiro (Mar 11 2020 at 00:54)</a>:</h4>
<p>You can probably use <code>\t</code> for this</p>

<a name="190241675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190241675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190241675">Mario Carneiro (Mar 11 2020 at 00:55)</a>:</h4>
<p><code>ih ▸ rfl</code> works</p>

<a name="190242008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190242008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190242008">Mario Carneiro (Mar 11 2020 at 01:02)</a>:</h4>
<p>The unnecessarily compressed proof:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">mul_assoc</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">m</span> <span class="bp">&lt;*&gt;</span> <span class="n">n</span><span class="o">)</span> <span class="bp">&lt;*&gt;</span> <span class="n">k</span> <span class="o">:=</span>
<span class="n">natural</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">k</span> <span class="n">rfl</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">k</span> <span class="n">ih</span><span class="o">,</span>
<span class="o">(</span><span class="n">mul_dist_add</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">ih</span><span class="bp">.</span><span class="n">symm</span> <span class="bp">▸</span> <span class="n">rfl</span><span class="o">)</span>
</pre></div>

<a name="190242128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190242128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190242128">Iocta (Mar 11 2020 at 01:04)</a>:</h4>
<p>What's the difference between <code>exact</code> and <code>apply</code>? Example: <code>exact (eq.subst ih rfl)</code> but <code>apply (eq.subst ih rfl)</code> doesn't.</p>

<a name="190242173"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190242173" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190242173">Mario Carneiro (Mar 11 2020 at 01:05)</a>:</h4>
<p><code>apply f</code> means <code>refine f</code> or <code>refine f _</code> or <code>refine f _ _</code> or ... depending on the type of <code>f</code>. Sometimes it can't guess right, and more importantly for your example, it can't communicate the expected type of <code>f</code> when elaborating it because it doesn't know yet</p>

<a name="190242184"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190242184" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190242184">Mario Carneiro (Mar 11 2020 at 01:05)</a>:</h4>
<p>On the other hand <code>eq.subst</code> requires that the expected type be known</p>

<a name="190242349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190242349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190242349">Iocta (Mar 11 2020 at 01:08)</a>:</h4>
<p>ah ok</p>

<a name="190321189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190321189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190321189">Iocta (Mar 11 2020 at 19:24)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">zero_add</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">natural</span><span class="o">)</span> <span class="o">:</span> <span class="n">add</span> <span class="n">n</span> <span class="n">zero</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="n">natural</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">n</span>
<span class="o">(</span><span class="k">by</span> <span class="n">refl</span><span class="o">)</span>
<span class="o">(</span><span class="k">assume</span> <span class="n">m</span><span class="o">:</span> <span class="n">natural</span><span class="o">,</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">ih</span> <span class="o">:</span> <span class="n">add</span> <span class="n">m</span> <span class="n">zero</span> <span class="bp">=</span> <span class="n">m</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">add</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">zero</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">m</span><span class="o">,</span>
  <span class="k">from</span> <span class="k">calc</span>
    <span class="n">add</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">zero</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">zero</span><span class="o">)</span> <span class="o">:</span> <span class="k">by</span> <span class="n">refl</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">m</span> <span class="o">:</span> <span class="k">by</span> <span class="n">simp</span> <span class="bp">*</span> <span class="n">at</span> <span class="bp">*</span><span class="o">))</span>
</pre></div>


<div class="codehilite"><pre><span></span> <span class="mi">06</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">lean</span>    <span class="mi">31</span>   <span class="mi">1</span> <span class="n">error</span>           <span class="s2">&quot;eliminator&quot;</span> <span class="n">elaborator</span> <span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
   <span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">natural</span><span class="o">)</span> <span class="o">(</span><span class="n">ih</span> <span class="o">:</span> <span class="n">add</span> <span class="n">m</span> <span class="n">zero</span> <span class="bp">=</span> <span class="n">m</span><span class="o">),</span>
     <span class="k">show</span> <span class="n">add</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">zero</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">m</span><span class="o">,</span> <span class="k">from</span>
       <span class="n">eq</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">add</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">zero</span><span class="o">))</span>
         <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">mpr</span>
            <span class="o">(</span><span class="n">id</span>
               <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">trans</span>
                  <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">trans</span>
                     <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">a_1</span> <span class="o">:</span> <span class="n">natural</span><span class="o">)</span> <span class="o">(</span><span class="n">e_1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a_1</span><span class="o">)</span> <span class="o">(</span><span class="n">a_2</span> <span class="n">a_3</span> <span class="o">:</span> <span class="n">natural</span><span class="o">)</span> <span class="o">(</span><span class="n">e_2</span> <span class="o">:</span> <span class="n">a_2</span> <span class="bp">=</span> <span class="n">a_3</span><span class="o">),</span>
                         <span class="n">congr</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">eq</span> <span class="n">e_1</span><span class="o">)</span> <span class="n">e_2</span><span class="o">)</span>
                        <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">zero</span><span class="o">))</span>
                        <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span>
                        <span class="o">((</span><span class="bp">λ</span> <span class="o">(</span><span class="n">a</span> <span class="n">a_1</span> <span class="o">:</span> <span class="n">natural</span><span class="o">)</span> <span class="o">(</span><span class="n">e_1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a_1</span><span class="o">),</span> <span class="n">congr_arg</span> <span class="n">succ</span> <span class="n">e_1</span><span class="o">)</span> <span class="o">(</span><span class="n">add</span> <span class="n">m</span> <span class="n">zero</span><span class="o">)</span> <span class="n">m</span> <span class="n">ih</span><span class="o">)</span>
                        <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span>
                        <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span>
                        <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)))</span>
                     <span class="n">succ</span><span class="bp">.</span><span class="n">inj_eq</span><span class="o">)</span>
                  <span class="o">(</span><span class="n">propext</span> <span class="o">(</span><span class="n">eq_self_iff_true</span> <span class="n">m</span><span class="o">))))</span>
            <span class="n">trivial</span><span class="o">)</span>
 <span class="n">has</span> <span class="n">type</span>
   <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">natural</span><span class="o">),</span> <span class="n">add</span> <span class="n">m</span> <span class="n">zero</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">add</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)</span> <span class="n">zero</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">m</span>
 <span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
   <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">natural</span><span class="o">),</span> <span class="n">add</span> <span class="o">(</span><span class="n">succ</span> <span class="n">a</span><span class="o">)</span> <span class="n">zero</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">a</span>
</pre></div>

<a name="190321207"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190321207" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190321207">Iocta (Mar 11 2020 at 19:25)</a>:</h4>
<p>How to fix this?</p>

<a name="190321338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190321338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190321338">Iocta (Mar 11 2020 at 19:26)</a>:</h4>
<p>I think it's saying "you're trying to depend on <code>ih</code> but I'm not providing it"</p>

<a name="190321352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190321352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190321352">Mario Carneiro (Mar 11 2020 at 19:26)</a>:</h4>
<p>use <code>rec_on</code> not <code>cases_on</code></p>

<a name="190321383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190321383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190321383">Iocta (Mar 11 2020 at 19:26)</a>:</h4>
<p>oh. that was easy :-)</p>

<a name="190321594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190321594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190321594">Iocta (Mar 11 2020 at 19:29)</a>:</h4>
<p>is it a good idea to introduce that <code>m</code> to avoid confusing that variable with the enclosing <code>n</code>, or should I just use <code>n</code> again?</p>

<a name="190321706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190321706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190321706">Iocta (Mar 11 2020 at 19:30)</a>:</h4>
<p>(really just asking what the convention is)</p>

<a name="190322670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190322670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190322670">Iocta (Mar 11 2020 at 19:40)</a>:</h4>
<p>aha, the code I can find looks to pretty uniformly reuse <code>n</code></p>

<a name="190325021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190325021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190325021">Reid Barton (Mar 11 2020 at 20:02)</a>:</h4>
<p>Yes, this seems to be the normal convention</p>

<a name="190348279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190348279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190348279">Iocta (Mar 12 2020 at 00:57)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="kn">inductive</span> <span class="n">list</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">{}</span> <span class="o">:</span> <span class="n">list</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="bp">→</span> <span class="n">list</span>

<span class="kn">namespace</span> <span class="n">list</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>

<span class="kn">notation</span> <span class="n">h</span> <span class="bp">::</span> <span class="n">t</span>  <span class="o">:=</span> <span class="n">cons</span> <span class="n">h</span> <span class="n">t</span>

<span class="n">def</span> <span class="n">append</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span>
<span class="n">list</span><span class="bp">.</span><span class="n">rec</span> <span class="n">t</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="n">l</span> <span class="n">u</span><span class="o">,</span> <span class="n">x</span><span class="bp">::</span><span class="n">u</span><span class="o">)</span> <span class="n">s</span>

<span class="kn">notation</span> <span class="n">s</span> <span class="bp">++</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">append</span> <span class="n">s</span> <span class="n">t</span>

<span class="kn">theorem</span> <span class="n">nil_append</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nil</span> <span class="bp">++</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">cons_append</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span><span class="bp">::</span><span class="n">s</span> <span class="bp">++</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">::</span><span class="o">(</span><span class="n">s</span> <span class="bp">++</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">append_nil</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">++</span> <span class="n">nil</span> <span class="bp">=</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">list</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">t</span>
<span class="n">rfl</span>
<span class="o">(</span><span class="k">assume</span> <span class="n">t</span><span class="o">,</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">ih</span><span class="o">:</span> <span class="n">t</span> <span class="bp">++</span> <span class="n">nil</span> <span class="bp">=</span> <span class="n">t</span><span class="o">,</span> <span class="n">sorry</span> <span class="o">))</span>


<span class="kn">end</span> <span class="n">list</span>

<span class="kn">end</span> <span class="n">hidden</span>
</pre></div>


<div class="codehilite"><pre><span></span> <span class="mi">06</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">lean</span>    <span class="mi">29</span>  <span class="mi">17</span> <span class="n">error</span>           <span class="n">none</span> <span class="n">of</span> <span class="n">the</span> <span class="n">overloads</span> <span class="n">are</span> <span class="n">applicable</span>
 <span class="n">error</span> <span class="n">for</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">list</span><span class="bp">.</span><span class="n">append</span>
 <span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
   <span class="n">append</span> <span class="n">t</span>
 <span class="n">term</span>
   <span class="n">t</span>
 <span class="n">has</span> <span class="n">type</span>
   <span class="n">α</span>
 <span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
   <span class="n">list</span> <span class="err">?</span><span class="n">m_1</span>

 <span class="n">error</span> <span class="n">for</span> <span class="n">has_append</span><span class="bp">.</span><span class="n">append</span>
 <span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
 <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
 <span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span>
 <span class="n">t</span> <span class="o">:</span> <span class="n">α</span>
 <span class="err">⊢</span> <span class="n">has_append</span> <span class="n">α</span>
</pre></div>

<a name="190348331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190348331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190348331">Iocta (Mar 12 2020 at 00:58)</a>:</h4>
<p>I'm guessing I'm doing the namespacing wrong?</p>

<a name="190349362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190349362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190349362">Reid Barton (Mar 12 2020 at 01:23)</a>:</h4>
<p>I think your code is just wrong</p>

<a name="190349422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190349422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190349422">Reid Barton (Mar 12 2020 at 01:25)</a>:</h4>
<p>in the inductive case, what happened to the element that is the first argument to <code>cons</code>? You aren't taking enough arguments</p>

<a name="190350616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190350616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190350616">Mario Carneiro (Mar 12 2020 at 01:55)</a>:</h4>
<p>I think the issue is that the <code>++</code> notation is conflicting with the one from core (which uses the <code>has_append</code> typeclass)</p>

<a name="190350706"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190350706" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190350706">Mario Carneiro (Mar 12 2020 at 01:57)</a>:</h4>
<p>oh, reid is right, there is another argument to <code>list.rec_on</code>. The setup should look like this:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">append_nil</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">++</span> <span class="n">nil</span> <span class="bp">=</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">list</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">t</span>
<span class="n">rfl</span>
<span class="o">(</span><span class="k">assume</span> <span class="n">a</span> <span class="n">t</span><span class="o">,</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">ih</span><span class="o">:</span> <span class="n">t</span> <span class="bp">++</span> <span class="n">nil</span> <span class="bp">=</span> <span class="n">t</span><span class="o">,</span>
    <span class="k">show</span> <span class="o">(</span><span class="n">a</span> <span class="bp">::</span> <span class="n">t</span><span class="o">)</span> <span class="bp">++</span> <span class="n">nil</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">::</span> <span class="n">t</span><span class="o">,</span> <span class="k">from</span>
    <span class="n">sorry</span> <span class="o">))</span>
</pre></div>

<a name="190357205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190357205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190357205">Iocta (Mar 12 2020 at 05:07)</a>:</h4>
<p>Oh, I see</p>

<a name="190438775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190438775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190438775">Iocta (Mar 12 2020 at 20:11)</a>:</h4>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html">https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html</a></p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">length</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">},</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">α</span><span class="o">,</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span> <span class="n">list</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">s</span> <span class="mi">0</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">a</span> <span class="n">s</span> <span class="n">len</span><span class="o">,</span> <span class="n">len</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span>
</pre></div>


<p>How do I state a theorem "length nil = 0"?</p>

<a name="190438968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190438968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190438968">Iocta (Mar 12 2020 at 20:13)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">length</span>  <span class="n">nil</span>  <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>


<div class="codehilite"><pre><span></span> <span class="mi">06</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">lean</span>    <span class="mi">55</span>  <span class="mi">19</span> <span class="n">error</span>           <span class="n">don&#39;t</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
 <span class="kn">context</span><span class="o">:</span>
 <span class="err">⊢</span> <span class="kt">Type</span> <span class="err">?</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
</pre></div>

<a name="190439437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190439437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190439437">Patrick Massot (Mar 12 2020 at 20:16)</a>:</h4>
<p>Lean complains it doesn't know the type of nil.</p>

<a name="190439471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190439471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190439471">Patrick Massot (Mar 12 2020 at 20:16)</a>:</h4>
<p>Because there is no way it can reconstruct  α from your statement.</p>

<a name="190439570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190439570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190439570">Patrick Massot (Mar 12 2020 at 20:17)</a>:</h4>
<p>Good news is: one the statement will type-check, the proof will be pretty short.</p>

<a name="190439617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190439617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190439617">Reid Barton (Mar 12 2020 at 20:17)</a>:</h4>
<p>There's no implicit generalization like in Haskell and some other languages. You have to write something like <code>example (a : Type) : length (nil : list a) = 0</code></p>

<a name="190439770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190439770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190439770">Iocta (Mar 12 2020 at 20:19)</a>:</h4>
<p>aha, that works</p>

<a name="190439897"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190439897" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190439897">Patrick Massot (Mar 12 2020 at 20:20)</a>:</h4>
<p>Because Reid gave away the statement, you are allowed only three characters to write the proof.</p>

<a name="190440286"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190440286" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190440286">Iocta (Mar 12 2020 at 20:22)</a>:</h4>
<p>yeah, got it</p>

<a name="190445612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190445612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190445612">Iocta (Mar 12 2020 at 21:09)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">reverse</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">},</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">α</span><span class="o">,</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span><span class="o">,</span>
    <span class="n">list</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">s</span>
    <span class="n">nil</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">reversed</span><span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">),</span>
      <span class="n">append</span> <span class="n">reversed</span> <span class="o">(</span><span class="n">x</span><span class="bp">::</span><span class="n">nil</span><span class="o">)</span>  <span class="o">)))</span>
</pre></div>


<div class="codehilite"><pre><span></span> <span class="mi">06</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">lean</span>    <span class="mi">90</span>   <span class="mi">7</span> <span class="n">error</span>           <span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
   <span class="n">append</span> <span class="n">reversed</span>
 <span class="n">term</span>
   <span class="n">reversed</span>
 <span class="n">has</span> <span class="n">type</span>
   <span class="n">list</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
 <span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
   <span class="n">list</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">...</span>
   <span class="n">type</span> <span class="n">mismatch</span><span class="o">,</span> <span class="n">term</span>
     <span class="err">?</span><span class="n">m_2</span> <span class="bp">++</span> <span class="err">?</span><span class="n">m_3</span>
   <span class="n">has</span> <span class="n">type</span>
     <span class="n">list</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">:</span> <span class="kt">Type</span>
   <span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
     <span class="n">list</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
</pre></div>

<a name="190445761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190445761" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190445761">Iocta (Mar 12 2020 at 21:11)</a>:</h4>
<p>I can just delete the <code>u</code> and it works, but what is the difference between <code>u</code> and no <code>u</code>?</p>

<a name="190445855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190445855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190445855">Iocta (Mar 12 2020 at 21:12)</a>:</h4>
<p>because the <code>def length : Π {α : Type u}, list α → nat :=</code> one does have a <code>u</code></p>

<a name="190446275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190446275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190446275">Reid Barton (Mar 12 2020 at 21:16)</a>:</h4>
<p>Somewhere you must have <code>Type</code> with no <code>u</code></p>

<a name="190446466"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190446466" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190446466">Iocta (Mar 12 2020 at 21:18)</a>:</h4>
<p>yeah I do</p>

<a name="190561710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190561710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190561710">Iocta (Mar 13 2020 at 22:26)</a>:</h4>
<p>I'm not getting the picture here. "Define an inductive data type consisting of terms built up from the following constructors..." <a href="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html">https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html</a></p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kn">universe</span> <span class="n">u</span>
<span class="kn">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>


<span class="kn">inductive</span> <span class="n">expr</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">const</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="n">plus</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span>  <span class="o">:</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="n">times</span> <span class="o">(</span><span class="n">s</span> <span class="n">t</span><span class="o">:</span> <span class="n">expr</span><span class="o">)</span>  <span class="o">:</span> <span class="n">expr</span>

<span class="kn">namespace</span> <span class="n">expr</span>
<span class="n">def</span> <span class="kn">eval</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">expr</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
<span class="n">case</span> <span class="n">const</span> <span class="o">:</span> <span class="o">{</span><span class="n">exact</span> <span class="n">x</span><span class="o">},</span>
<span class="n">case</span> <span class="n">var</span> <span class="o">:</span> <span class="o">{</span><span class="n">exact</span> <span class="n">x</span><span class="o">},</span>
<span class="n">case</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">s</span> <span class="n">t</span> <span class="o">{</span><span class="n">exact</span> <span class="o">((</span><span class="kn">eval</span> <span class="n">s</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="kn">eval</span> <span class="n">t</span><span class="o">))},</span>
<span class="n">case</span> <span class="n">times</span> <span class="o">:</span> <span class="n">s</span> <span class="n">t</span>  <span class="o">{</span><span class="n">exact</span> <span class="o">((</span><span class="kn">eval</span> <span class="n">s</span><span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="kn">eval</span> <span class="n">t</span><span class="o">))},</span>
<span class="kn">end</span>
<span class="kn">end</span> <span class="n">expr</span>
<span class="kn">end</span> <span class="n">hidden</span>
</pre></div>


<div class="codehilite"><pre><span></span> <span class="mi">06</span><span class="bp">.</span><span class="mi">03</span><span class="bp">.</span><span class="n">le</span><span class="err">…</span>    <span class="mi">19</span>  <span class="mi">26</span> <span class="n">error</span>           <span class="n">unknown</span> <span class="n">identifier</span> <span class="err">&#39;</span><span class="kn">eval</span><span class="err">&#39;</span>
 <span class="n">state</span><span class="o">:</span>
 <span class="n">case</span> <span class="n">hidden</span><span class="bp">.</span><span class="n">expr</span><span class="bp">.</span><span class="n">plus</span>
 <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">,</span>
 <span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">expr</span> <span class="n">α</span>
 <span class="err">⊢</span> <span class="bp">ℕ</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
</pre></div>

<a name="190561865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190561865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190561865">Kevin Buzzard (Mar 13 2020 at 22:28)</a>:</h4>
<p>You can't use <code>eval</code> in the definition of <code>eval</code></p>

<a name="190561904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190561904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190561904">Iocta (Mar 13 2020 at 22:29)</a>:</h4>
<p>Then how do I recurse?</p>

<a name="190562098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190562098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190562098">Kevin Buzzard (Mar 13 2020 at 22:31)</a>:</h4>
<p>This is all a bit CS for me, so don't take what I have to say too seriously.</p>

<a name="190562122"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190562122" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190562122">Kevin Buzzard (Mar 13 2020 at 22:31)</a>:</h4>
<p>but when you made the inductive type, Lean made a recursor for you</p>

<a name="190562133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190562133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190562133">Kevin Buzzard (Mar 13 2020 at 22:31)</a>:</h4>
<p>After the definition of <code>expr</code>, try <code>#print prefix expr</code></p>

<a name="190562193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190562193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190562193">Kevin Buzzard (Mar 13 2020 at 22:32)</a>:</h4>
<p>wait, better is <code>#print prefix hidden.expr</code></p>

<a name="190562241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190562241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190562241">Kevin Buzzard (Mar 13 2020 at 22:33)</a>:</h4>
<p>All that crazy stuff got made when you defined <code>expr</code>. In particular <code>hidden.expr.rec</code> got made, and if that doesn't do the job then nothing will</p>

<a name="190562364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190562364" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190562364">Kevin Buzzard (Mar 13 2020 at 22:35)</a>:</h4>
<p>or you can use <code>match</code> but maybe that's not covered until chapter 8</p>

<a name="190562404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190562404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190562404">Kevin Buzzard (Mar 13 2020 at 22:35)</a>:</h4>
<p>hmm maybe you can't use match, I should stop talking. Does the recursor do it for you?</p>

<a name="190562509"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190562509" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190562509">Kevin Buzzard (Mar 13 2020 at 22:37)</a>:</h4>
<p>I think you're supposed to be eating <code>f : nat -&gt; nat</code> as well, and <code>var n</code> is supposed to evaluate to <code>f n</code></p>

<a name="190562517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190562517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190562517">Iocta (Mar 13 2020 at 22:37)</a>:</h4>
<p>If you mean like this</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="kn">eval</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">expr</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
<span class="n">case</span> <span class="n">const</span> <span class="o">:</span> <span class="n">n</span> <span class="o">{</span><span class="n">exact</span> <span class="n">n</span> <span class="o">},</span>
<span class="n">case</span> <span class="n">var</span> <span class="o">:</span> <span class="n">n</span> <span class="o">{</span><span class="n">exact</span> <span class="n">n</span><span class="o">},</span>
<span class="n">case</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">s</span> <span class="n">t</span> <span class="o">{</span><span class="n">exact</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="n">rec</span> <span class="bp">+</span> <span class="n">t</span><span class="bp">.</span><span class="n">rec</span><span class="o">)},</span>
<span class="n">case</span> <span class="n">times</span> <span class="o">:</span> <span class="n">s</span> <span class="n">t</span>  <span class="o">{</span><span class="n">exact</span> <span class="o">(</span><span class="n">s</span><span class="bp">.</span><span class="n">rec</span> <span class="o">)</span> <span class="bp">*</span> <span class="o">(</span><span class="n">t</span><span class="bp">.</span><span class="n">rec</span><span class="o">)},</span>
<span class="kn">end</span>
</pre></div>


<p>then </p>
<div class="codehilite"><pre><span></span> <span class="mi">06</span><span class="bp">.</span><span class="mi">03</span><span class="bp">.</span><span class="n">le</span><span class="err">…</span>    <span class="mi">21</span>  <span class="mi">18</span> <span class="n">error</span>           <span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
   <span class="n">expr</span><span class="bp">.</span><span class="n">rec</span> <span class="n">s</span>
 <span class="n">term</span>
   <span class="n">s</span>
 <span class="n">has</span> <span class="n">type</span>
   <span class="n">expr</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span>
 <span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
   <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="err">?</span><span class="n">m_1</span> <span class="o">(</span><span class="n">const</span> <span class="err">?</span><span class="n">m_2</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">Sort</span> <span class="o">(</span><span class="n">imax</span> <span class="mi">1</span> <span class="err">?</span><span class="o">)</span>
</pre></div>

<a name="190562557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190562557" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190562557">Chris Hughes (Mar 13 2020 at 22:37)</a>:</h4>
<p>This is how you recurse</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="kn">eval</span> <span class="o">:</span> <span class="n">expr</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="bp">_</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="bp">_</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">plus</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="kn">eval</span> <span class="n">s</span> <span class="bp">+</span> <span class="kn">eval</span> <span class="n">t</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">times</span> <span class="n">s</span> <span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="kn">eval</span> <span class="n">s</span> <span class="bp">*</span> <span class="kn">eval</span> <span class="n">t</span>
</pre></div>

<a name="190562593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190562593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190562593">Kevin Buzzard (Mar 13 2020 at 22:38)</a>:</h4>
<p>You're not really supposed to be making data using tactic mode, but that is not the issue right now. How about <code>induction x</code> instead of cases x?</p>

<a name="190562636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190562636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190562636">Chris Hughes (Mar 13 2020 at 22:38)</a>:</h4>
<p>You can use<code> induction</code> instead of <code>cases</code> as well, but <code>eval</code> won't be called <code>eval </code>it will be called something like <code>x_ih</code></p>

<a name="190562670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190562670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190562670">Iocta (Mar 13 2020 at 22:39)</a>:</h4>
<p>Aha, that helps</p>

<a name="190562788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190562788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190562788">Kevin Buzzard (Mar 13 2020 at 22:41)</a>:</h4>
<p>That usage of the equation compiler isn't covered until chapter 8</p>

<a name="190563004"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190563004" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190563004">Chris Hughes (Mar 13 2020 at 22:44)</a>:</h4>
<p>The chapter 7 approved way</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="kn">eval</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">expr</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="n">expr</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">x</span> <span class="n">id</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span> <span class="n">ns</span> <span class="n">nt</span><span class="o">,</span> <span class="n">ns</span> <span class="bp">+</span> <span class="n">nt</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span> <span class="n">ns</span> <span class="n">nt</span><span class="o">,</span> <span class="n">ns</span> <span class="bp">*</span> <span class="n">nt</span><span class="o">)</span>
</pre></div>

<a name="190563138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190563138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190563138">Kevin Buzzard (Mar 13 2020 at 22:46)</a>:</h4>
<p>I think the idea is that the second <code>id</code> should be an <code>f</code></p>

<a name="190563155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190563155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190563155">Kevin Buzzard (Mar 13 2020 at 22:46)</a>:</h4>
<p>which is an input function</p>

<a name="190563349"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190563349" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190563349">Iocta (Mar 13 2020 at 22:49)</a>:</h4>
<p>Oh that's pretty close to something I had earlier</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="kn">eval</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">expr</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="n">expr</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">x</span>
<span class="n">id</span>
<span class="n">id</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">t</span><span class="o">)</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="n">s</span> <span class="bp">*</span> <span class="n">t</span><span class="o">)</span>
</pre></div>

<a name="190563461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190563461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190563461">Iocta (Mar 13 2020 at 22:51)</a>:</h4>
<p>which doesn't work because the latter functions are supposed to take ( outside outside inside inside) not just (inside inside)</p>

<a name="190563493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190563493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190563493">Kevin Buzzard (Mar 13 2020 at 22:51)</a>:</h4>
<p>You know you can use <code>_</code> to figure out what is going on?</p>

<a name="190563511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190563511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190563511">Iocta (Mar 13 2020 at 22:51)</a>:</h4>
<p>yeah I just didn't grok what it was telling me</p>

<a name="190563661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190563661" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190563661">Kevin Buzzard (Mar 13 2020 at 22:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="kn">eval</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span> <span class="n">expr</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="n">expr</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">x</span>
<span class="n">id</span>
<span class="n">id</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="bp">_</span><span class="o">)</span>
<span class="o">(</span><span class="bp">_</span><span class="o">)</span>
</pre></div>


<p>-&gt;</p>
<div class="codehilite"><pre><span></span>scratch2.lean:18:8: error
don&#39;t know how to synthesize placeholder
context:
α : Type u,
x s t : expr α
⊢ ℕ → ℕ → ℕ
▹
scratch2.lean:19:1: error
don&#39;t know how to synthesize placeholder
context:
α : Type u,
x : expr α
⊢ expr α → expr α → ℕ → ℕ → ℕ
</pre></div>


<p>so the first hole is expecting two more inputs and the second is expecting four</p>

<a name="190563719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190563719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190563719">Kevin Buzzard (Mar 13 2020 at 22:54)</a>:</h4>
<p>and you can see that s and t have type <code>expr alpha</code> not <code>nat</code></p>

<a name="190563725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190563725" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190563725">Iocta (Mar 13 2020 at 22:54)</a>:</h4>
<p>I do see it <em>now</em> :-)</p>

<a name="190563730"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190563730" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190563730">Kevin Buzzard (Mar 13 2020 at 22:54)</a>:</h4>
<p>:-)</p>

<a name="190563752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190563752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190563752">Kevin Buzzard (Mar 13 2020 at 22:54)</a>:</h4>
<p>My ability to debug soared once I realised I could understand the error messages</p>

<a name="190563802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190563802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190563802">Kevin Buzzard (Mar 13 2020 at 22:55)</a>:</h4>
<p>when I was a beginner I was just all "oh crap it still doesn't work" but now I learnt how to read the error messages I can go "oh look, type class inference failed" or "oh look, I put the wrong number of variables" etc. It is liberating :-)</p>

<a name="190563876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190563876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190563876">Iocta (Mar 13 2020 at 22:56)</a>:</h4>
<p>That's consistent with my limited experience so far as well</p>

<a name="190564438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190564438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190564438">Iocta (Mar 13 2020 at 23:05)</a>:</h4>
<p>now should I be able to use <code>eval</code>?  <code>#reduce expr.eval (const 0)</code> </p>
<div class="codehilite"><pre><span></span> <span class="mi">06</span><span class="bp">.</span><span class="mi">03</span><span class="bp">.</span><span class="n">le</span><span class="err">…</span>    <span class="mi">18</span>  <span class="mi">26</span> <span class="n">error</span>           <span class="n">failed</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">type</span> <span class="n">class</span> <span class="kn">instance</span> <span class="n">for</span>
 <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
 <span class="err">⊢</span> <span class="n">has_zero</span> <span class="o">(</span><span class="kt">Type</span> <span class="err">?</span><span class="o">)</span> <span class="o">(</span><span class="n">lean</span><span class="bp">-</span><span class="n">checker</span><span class="o">)</span>
</pre></div>

<a name="190564469"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190564469" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190564469">Kevin Buzzard (Mar 13 2020 at 23:05)</a>:</h4>
<p>What is the type of <code>const</code>?</p>

<a name="190564553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190564553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190564553">Iocta (Mar 13 2020 at 23:06)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">const</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">),</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">expr</span> <span class="n">α</span>
</pre></div>

<a name="190564570"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190564570" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190564570">Kevin Buzzard (Mar 13 2020 at 23:07)</a>:</h4>
<p>The error says "you wrote 0, so I'll try and figure out a term of the type I was expecting called 0, oh wait, I was expecting a term of type <code>Type u_1</code></p>

<a name="190564582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190564582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190564582">Iocta (Mar 13 2020 at 23:07)</a>:</h4>
<p>aha, so <code>#reduce expr.eval (const nat 0)</code></p>

<a name="190564596"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190564596" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190564596">Kevin Buzzard (Mar 13 2020 at 23:07)</a>:</h4>
<p><code>const alpha 0</code></p>

<a name="190564624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190564624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190564624">Kevin Buzzard (Mar 13 2020 at 23:08)</a>:</h4>
<p>what is this alpha doing in expr? That's the problem</p>

<a name="190564670"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190564670" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190564670">Kevin Buzzard (Mar 13 2020 at 23:08)</a>:</h4>
<p>Why not just remove the alpha?</p>

<a name="190564717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190564717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190564717">Iocta (Mar 13 2020 at 23:09)</a>:</h4>
<p>yeah that works</p>

<a name="190564750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190564750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190564750">Iocta (Mar 13 2020 at 23:09)</a>:</h4>
<p>I haven't got the hang of the alphas and <code>u</code>s yet</p>

<a name="190564839"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190564839" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190564839">Kevin Buzzard (Mar 13 2020 at 23:10)</a>:</h4>
<p>I had to read TPIL three times before I got the hang of it (but then again I suspect I had less of a CS background than you). What helped with me was just coming up with projects and working on them.</p>

<a name="190565388"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190565388" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190565388">Chris Hughes (Mar 13 2020 at 23:18)</a>:</h4>
<p>You have to write <code>const α  0</code></p>

<a name="190565433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190565433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190565433">Chris Hughes (Mar 13 2020 at 23:19)</a>:</h4>
<p>You can change the definition of <code>expr</code> to fix this. Use brackets like this <code>| const {} (n: nat) : expr</code></p>

<a name="190565453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190565453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190565453">Kevin Buzzard (Mar 13 2020 at 23:19)</a>:</h4>
<p>But is alpha playing any role at all? How about we remove all occurences of alpha?</p>

<a name="190666931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190666931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190666931">Iocta (Mar 15 2020 at 21:04)</a>:</h4>
<p>I need some help with "Use pattern matching to prove that the composition of surjective functions is surjective"</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">function</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">surjective</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">{</span><span class="n">γ</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">}</span>
<span class="kn">open</span> <span class="n">function</span>

<span class="kn">lemma</span> <span class="n">surjective_comp</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
<span class="n">surjective</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>

<a name="190667053"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190667053" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190667053">Iocta (Mar 15 2020 at 21:07)</a>:</h4>
<p>if I <code>intro gam: \gamma</code> can I destruct it into an element of beta that it came from?</p>

<a name="190669019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190669019" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190669019">Patrick Massot (Mar 15 2020 at 21:59)</a>:</h4>
<p>Do you want to use mathlib or are you doing TPIL exercises?</p>

<a name="190669321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190669321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190669321">Patrick Massot (Mar 15 2020 at 22:07)</a>:</h4>
<p>It seems to be a TPIL exercise. I have no idea what Jeremy had in mind. The closest to a term-mode proof I could do is</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">surjective_comp</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">γ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
<span class="n">surjective</span> <span class="o">(</span><span class="n">g</span> <span class="err">∘</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">z</span><span class="o">,</span>
<span class="k">let</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">hg</span> <span class="n">z</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">hf</span> <span class="n">y</span> <span class="k">in</span>
<span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">rwa</span> <span class="err">←</span> <span class="n">hx</span> <span class="n">at</span> <span class="n">hy</span><span class="bp">⟩</span>
</pre></div>

<a name="190669337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190669337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190669337">Patrick Massot (Mar 15 2020 at 22:07)</a>:</h4>
<p>You could replace <code>let</code> with match, adjusting the syntax as needed.</p>

<a name="190669385"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190669385" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190669385">Patrick Massot (Mar 15 2020 at 22:08)</a>:</h4>
<p>But I would rather import mathlib tactics and write:</p>
<div class="codehilite"><pre><span></span><span class="k">begin</span>
  <span class="n">intro</span> <span class="n">z</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">hg</span> <span class="n">z</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">hf</span> <span class="n">y</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="190676678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190676678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190676678">Iocta (Mar 16 2020 at 01:22)</a>:</h4>
<p>that's pretty slick</p>

<a name="190682615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190682615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190682615">Iocta (Mar 16 2020 at 04:08)</a>:</h4>
<p>What's the <code>match</code> version look like? I'm not getting the syntax right.</p>
<div class="codehilite"><pre><span></span><span class="k">match</span> <span class="n">hg</span><span class="o">,</span> <span class="n">hf</span> <span class="k">with</span>
<span class="bp">⟨</span><span class="n">y</span><span class="o">,</span> <span class="n">hy</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">hg</span> <span class="n">g</span> <span class="o">,</span> <span class="n">hf</span> <span class="n">f</span><span class="bp">⟩</span>
<span class="kn">end</span>
<span class="bp">⟨</span><span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">hx</span><span class="o">,</span> <span class="n">hy</span><span class="o">]</span><span class="bp">⟩</span>
</pre></div>

<a name="190942244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190942244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190942244">Iocta (Mar 18 2020 at 06:23)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">sum_inhabited</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="n">inhabited</span> <span class="n">b</span><span class="o">]</span> <span class="o">:</span> <span class="n">inhabited</span>  <span class="o">(</span><span class="n">sum</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span> <span class="n">default</span> <span class="bp">_</span> <span class="bp">⟩</span>
</pre></div>


<p>works but how do I find out what's going in the <code>_</code>?</p>

<a name="190942864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190942864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190942864">Iocta (Mar 18 2020 at 06:36)</a>:</h4>
<p>or, (independent of how to find out), what <em>is</em> going in the <code>_</code>?</p>

<a name="190943016"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190943016" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190943016">Bryan Gin-ge Chen (Mar 18 2020 at 06:39)</a>:</h4>
<p><code>#print sum_inhabited</code> helps here:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="kn">instance</span><span class="o">]</span>
<span class="kn">protected</span> <span class="n">def</span> <span class="n">sum_inhabited</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">b</span><span class="o">],</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">a</span> <span class="err">⊕</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">b</span><span class="o">],</span> <span class="o">{</span><span class="n">default</span> <span class="o">:=</span> <span class="n">default</span> <span class="o">(</span><span class="n">a</span> <span class="err">⊕</span> <span class="n">b</span><span class="o">)</span> <span class="n">sum</span><span class="bp">.</span><span class="n">inhabited_right</span><span class="o">}</span>
</pre></div>


<p>(Sometimes you have to turn off pretty printing and notation with <code>#print</code> with <code>set_option pp.all true</code> to get the info you want, but this seems like enough.)</p>

<a name="190943087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190943087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190943087">Bryan Gin-ge Chen (Mar 18 2020 at 06:41)</a>:</h4>
<p>Compare the output with <code>set_option pp.notation false</code>:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="kn">instance</span><span class="o">]</span>
<span class="kn">protected</span> <span class="n">def</span> <span class="n">sum_inhabited</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">b</span><span class="o">],</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">sum</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">a</span><span class="o">]</span> <span class="o">[</span><span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="n">b</span><span class="o">],</span> <span class="o">{</span><span class="n">default</span> <span class="o">:=</span> <span class="n">default</span> <span class="o">(</span><span class="n">sum</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">sum</span><span class="bp">.</span><span class="n">inhabited_right</span><span class="o">}</span>
</pre></div>

<a name="190943242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190943242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190943242">Iocta (Mar 18 2020 at 06:44)</a>:</h4>
<p>I see</p>

<a name="190943482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190943482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190943482">Mario Carneiro (Mar 18 2020 at 06:51)</a>:</h4>
<p>By the way, the only way a proof of an inhabited instance like <code>⟨ default _ ⟩</code> can work is if there is already an inhabited instance for that type</p>

<a name="190943495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190943495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190943495">Mario Carneiro (Mar 18 2020 at 06:51)</a>:</h4>
<p>in other words, the instance is useless because it's already there, and <code>by apply_instance</code> should also work</p>

<a name="190943556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/190943556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#190943556">Iocta (Mar 18 2020 at 06:52)</a>:</h4>
<p>mhmm</p>

<a name="191180824"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191180824" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191180824">Iocta (Mar 19 2020 at 22:00)</a>:</h4>
<p>can I import a module <code>import foo.bar</code> and access <code>foo.bar.baz</code> without <code>open</code>ing <code>bar</code>?</p>

<a name="191181295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191181295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191181295">Iocta (Mar 19 2020 at 22:05)</a>:</h4>
<p><code>import logic.basic</code> seems to open it automatically?</p>

<a name="191181386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191181386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191181386">Kevin Buzzard (Mar 19 2020 at 22:06)</a>:</h4>
<p>The definitions in logic.basic are probably not in any namespace called logic or logic.basic</p>

<a name="191181414"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191181414" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191181414">Kevin Buzzard (Mar 19 2020 at 22:07)</a>:</h4>
<p>Definition X in file Y is just called X after you import Y</p>

<a name="191181450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191181450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191181450">Iocta (Mar 19 2020 at 22:07)</a>:</h4>
<p><code>#check not_or_distrib</code> doesn't work unless I <code>import logic.basic</code></p>

<a name="191181490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191181490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191181490">Kevin Buzzard (Mar 19 2020 at 22:08)</a>:</h4>
<p>that's because this function is defined in logic.basic</p>

<a name="191181617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191181617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191181617">Kevin Buzzard (Mar 19 2020 at 22:09)</a>:</h4>
<p>but the only namespace used in logic.basic is <code>classical</code>, so after you import <code>logic.basic</code> you have stuff like <code>not_or_distrib</code> (in the root namespace) and <code>classical.not_forall</code> (in the classical namespace)</p>

<a name="191181675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191181675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191181675">Kevin Buzzard (Mar 19 2020 at 22:10)</a>:</h4>
<p>there is no logic.basic namespace, even after importing it</p>

<a name="191181855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191181855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191181855">Iocta (Mar 19 2020 at 22:12)</a>:</h4>
<p>I see</p>

<a name="191200916"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191200916" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191200916">Iocta (Mar 20 2020 at 03:54)</a>:</h4>
<p>Doing <a href="https://github.com/leanprover-community/mathlib/issues/3" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/3">#3</a> from <a href="https://leanprover.github.io/logic_and_proof/sets_in_lean.html" target="_blank" title="https://leanprover.github.io/logic_and_proof/sets_in_lean.html">https://leanprover.github.io/logic_and_proof/sets_in_lean.html</a></p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">set</span>
<span class="kn">import</span> <span class="n">logic</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">I</span> <span class="n">U</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">B</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">set</span> <span class="n">U</span><span class="o">)</span>



<span class="kn">theorem</span> <span class="n">Inter</span><span class="bp">.</span><span class="n">intro</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span><span class="bp">;</span> <span class="n">assumption</span>

<span class="bp">@</span><span class="o">[</span><span class="n">elab_simple</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">Inter</span><span class="bp">.</span><span class="n">elim</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">A</span> <span class="n">i</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">h</span>

<span class="kn">theorem</span> <span class="n">Union</span><span class="bp">.</span><span class="n">intro</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">}</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">x</span> <span class="err">∈</span> <span class="err">⋃</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span><span class="n">simp</span><span class="o">,</span> <span class="n">existsi</span> <span class="n">i</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span><span class="o">}</span>

<span class="kn">theorem</span> <span class="n">Union</span><span class="bp">.</span><span class="n">elim</span> <span class="o">{</span><span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">}</span>
<span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="err">⋃</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">A</span> <span class="n">i</span> <span class="bp">→</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span><span class="n">simp</span> <span class="n">at</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">cases</span> <span class="n">h₁</span> <span class="k">with</span> <span class="n">i</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h₂</span> <span class="n">i</span> <span class="n">h</span><span class="o">}</span>



<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">B</span> <span class="n">i</span><span class="o">)</span> <span class="err">⊆</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span> <span class="err">∩</span> <span class="n">B</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">x</span> <span class="n">h</span> <span class="n">T</span> <span class="n">h2</span><span class="o">,</span>
<span class="k">begin</span>
<span class="n">simp</span> <span class="bp">*</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">exists</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h2</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">teq</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">and</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h</span><span class="o">,</span>
<span class="n">intros</span> <span class="n">fa</span> <span class="n">fb</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">eq</span><span class="bp">.</span><span class="n">subst</span> <span class="n">teq</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">fa</span> <span class="n">i</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">fb</span> <span class="n">i</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>I have a proof using the regular logic functions, but I'm not sure how to write the proof using <code>Inter.elim</code> etc.</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">B</span> <span class="n">i</span><span class="o">)</span> <span class="err">⊆</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span> <span class="err">∩</span> <span class="n">B</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">x</span> <span class="n">h</span> <span class="n">S</span> <span class="n">h2</span><span class="o">,</span>

<span class="kn">end</span>
</pre></div>

<a name="191200933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191200933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191200933">Iocta (Mar 20 2020 at 03:55)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">I</span> <span class="n">U</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">U</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">(</span><span class="err">⋂</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="err">⋂</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">B</span> <span class="n">i</span><span class="o">,</span>
<span class="n">S</span> <span class="o">:</span> <span class="n">set</span> <span class="n">U</span><span class="o">,</span>
<span class="n">h2</span> <span class="o">:</span> <span class="n">S</span> <span class="err">∈</span> <span class="n">set</span><span class="bp">.</span><span class="n">range</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">A</span> <span class="n">i</span> <span class="err">∩</span> <span class="n">B</span> <span class="n">i</span><span class="o">)</span>
<span class="err">⊢</span> <span class="n">x</span> <span class="err">∈</span> <span class="n">S</span>
</pre></div>

<a name="191201582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191201582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191201582">Kenny Lau (Mar 20 2020 at 04:15)</a>:</h4>
<p>thanks for creating a copy-paste-able example.</p>

<a name="191201647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191201647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191201647">Kenny Lau (Mar 20 2020 at 04:17)</a>:</h4>
<p>you might want to start from here:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">B</span> <span class="n">i</span><span class="o">)</span> <span class="err">⊆</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span> <span class="err">∩</span> <span class="n">B</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">(</span><span class="err">⋂</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h2</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">(</span><span class="err">⋂</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">B</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="n">state</span><span class="o">:</span>
<span class="n">I</span> <span class="n">U</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span>
<span class="n">A</span> <span class="n">B</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">U</span><span class="o">,</span>
<span class="n">x</span> <span class="o">:</span> <span class="n">U</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="o">(</span><span class="err">⋂</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="err">⋂</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">B</span> <span class="n">i</span><span class="o">,</span>
<span class="n">h1</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="err">⋂</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">A</span> <span class="n">i</span><span class="o">,</span>
<span class="n">h2</span> <span class="o">:</span> <span class="n">x</span> <span class="err">∈</span> <span class="err">⋂</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">B</span> <span class="n">i</span>
<span class="err">⊢</span> <span class="n">x</span> <span class="err">∈</span> <span class="err">⋂</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">A</span> <span class="n">i</span> <span class="err">∩</span> <span class="n">B</span> <span class="n">i</span>
</pre></div>

<a name="191208085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191208085" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191208085">Kevin Buzzard (Mar 20 2020 at 07:17)</a>:</h4>
<p>Note that you can also do this directly:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">B</span> <span class="n">i</span><span class="o">)</span> <span class="err">⊆</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span> <span class="err">∩</span> <span class="n">B</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rintros</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">⟩</span><span class="o">,</span>

<span class="kn">end</span>
</pre></div>

<a name="191378019"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191378019" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191378019">Iocta (Mar 22 2020 at 03:35)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">B</span> <span class="n">i</span><span class="o">)</span> <span class="err">⊆</span> <span class="o">(</span><span class="err">⋂</span> <span class="n">i</span><span class="o">,</span> <span class="n">A</span> <span class="n">i</span> <span class="err">∩</span> <span class="n">B</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span> <span class="n">j</span> <span class="n">h</span> <span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">Inter</span><span class="bp">.</span><span class="n">intro</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
<span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">set</span><span class="bp">.</span><span class="n">mem_inter_eq</span><span class="o">],</span>
<span class="n">intro</span> <span class="n">i</span><span class="o">,</span>
<span class="n">split</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">Inter</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">h_left</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">Inter</span><span class="bp">.</span><span class="n">elim</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">h_right</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>works but I'm guessing there's a better solution, this isn't easy to follow.</p>

<a name="191385161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191385161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191385161">Iocta (Mar 22 2020 at 07:44)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">section</span>
<span class="kn">parameters</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
<span class="kn">parameter</span> <span class="o">(</span><span class="n">irreflR</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">R</span><span class="o">)</span>
<span class="kn">parameter</span> <span class="o">(</span><span class="n">transR</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">R</span><span class="o">)</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">&lt;</span> <span class="o">:=</span> <span class="n">R</span>

<span class="n">def</span> <span class="n">R&#39;</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">R</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">∨</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span>
<span class="n">local</span> <span class="kn">infix</span> <span class="bp">≤</span> <span class="o">:=</span> <span class="n">R&#39;</span>




<span class="kn">theorem</span> <span class="n">reflR&#39;</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">transR&#39;</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">):</span>
  <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="o">:=</span>
<span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h1</span>
<span class="o">(</span><span class="k">assume</span> <span class="n">rab</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h2</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">rbc</span><span class="o">,</span>  <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">transR</span> <span class="n">rab</span> <span class="n">rbc</span><span class="o">)))</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">eqbc</span><span class="o">,</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">subst</span> <span class="n">eqbc</span> <span class="n">rab</span><span class="o">)</span> <span class="o">))</span> <span class="o">)</span>
<span class="o">(</span><span class="k">assume</span> <span class="n">eqab</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="n">h2</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">rbc</span><span class="o">,</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">substr</span> <span class="n">eqab</span> <span class="n">rbc</span><span class="o">)))</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">eqbc</span><span class="o">,</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">substr</span> <span class="n">eqab</span> <span class="n">eqbc</span><span class="o">))))</span>


<span class="kn">theorem</span> <span class="n">transR&#39;&#39;</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">A</span><span class="o">}</span> <span class="o">(</span><span class="n">h1</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">≤</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">≤</span> <span class="n">c</span><span class="o">):</span>
  <span class="n">a</span> <span class="bp">≤</span> <span class="n">c</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intros</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h1</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h2</span><span class="o">,</span>
<span class="n">left</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">transR</span>
<span class="kn">end</span>
</pre></div>


<div class="codehilite"><pre><span></span> lap14.4.…    35   1 error           unknown identifier &#39;transR&#39;
</pre></div>


<p>I did a term proof, now trying the tactic proof. In the last line, how come it doesn't know about <code>transR</code>?</p>

<a name="191386463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191386463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191386463">Shing Tak Lam (Mar 22 2020 at 08:29)</a>:</h4>
<p><span class="user-mention" data-user-id="253355">@Iocta</span> </p>
<p>Add <code>include transR</code> below the <code>parameter (transR : transitive R)</code></p>
<p>So the beginning looks like</p>
<div class="codehilite"><pre><span></span><span class="kn">section</span>
<span class="kn">parameters</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">A</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">}</span>
<span class="kn">parameter</span> <span class="o">(</span><span class="n">irreflR</span> <span class="o">:</span> <span class="n">irreflexive</span> <span class="n">R</span><span class="o">)</span>
<span class="kn">parameter</span> <span class="o">(</span><span class="n">transR</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">R</span><span class="o">)</span>
<span class="n">include</span> <span class="n">transR</span>
</pre></div>


<p>(I found it in this GitHub issue <a href="https://github.com/leanprover/lean/issues/1527" target="_blank" title="https://github.com/leanprover/lean/issues/1527">here</a>, and the page number referred to doesn't seem to be correct... Maybe there was a prior edition to TPIL?)</p>

<a name="191387998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191387998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191387998">Kevin Buzzard (Mar 22 2020 at 09:24)</a>:</h4>
<p>Don't use parameters, use variables</p>

<a name="191418938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/more%20basics/near/191418938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/41001morebasics.html#191418938">Iocta (Mar 22 2020 at 22:12)</a>:</h4>
<p>that was from <a href="https://leanprover.github.io/logic_and_proof/relations_in_lean.html" target="_blank" title="https://leanprover.github.io/logic_and_proof/relations_in_lean.html">https://leanprover.github.io/logic_and_proof/relations_in_lean.html</a></p>


{% endraw %}

{% include archive_update.html %}