---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/24711Basicbuildingblocktactics.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html">Basic building block tactics</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="189082400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189082400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189082400">Lucas Allen (Feb 26 2020 at 03:02)</a>:</h4>
<p>I'm interested in learning about the basic building blocks of proofs in Lean. To this end I've read section 2 of Mario's masters thesis, but I don't have a CS background and didn't understand everything. From what I did understand the tactics, <code>intro</code>, <code>apply</code>, <code>induction</code>, and <code>rw</code>, relate to typing judgements, the basic building blocks of proofs.</p>
<p>Is there a list of tactics for which it's theoretically possible to prove any statement in Lean using only tactics on the list? Or is there a tactic for each typing judgement? And if so, what's the list? Or where can I learn more?</p>
<p>Thanks.</p>

<a name="189083657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083657">Mario Carneiro (Feb 26 2020 at 03:38)</a>:</h4>
<p><code>exact</code> does everything by itself</p>

<a name="189083662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083662">Mario Carneiro (Feb 26 2020 at 03:38)</a>:</h4>
<p>or <code>refine</code></p>

<a name="189083675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083675">Mario Carneiro (Feb 26 2020 at 03:39)</a>:</h4>
<p>You can probably get away with <code>intro</code> and <code>apply</code>, since that covers application and lambda</p>

<a name="189083718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083718">Mario Carneiro (Feb 26 2020 at 03:40)</a>:</h4>
<p><code>change</code> is important for triggering definitional conversion</p>

<a name="189083723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083723">Mario Carneiro (Feb 26 2020 at 03:40)</a>:</h4>
<p>but <code>induction</code> and <code>rw</code> are just fancy ways to apply functions</p>

<a name="189091945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189091945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189091945">Kevin Buzzard (Feb 26 2020 at 07:41)</a>:</h4>
<p>I guess it's theoretically possible to prove any statement in lean without using any tactics at all, because you can just use term mode. I think Agda might look like this?</p>

<a name="189082400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189082400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189082400">Lucas Allen (Feb 26 2020 at 03:02)</a>:</h4>
<p>I'm interested in learning about the basic building blocks of proofs in Lean. To this end I've read section 2 of Mario's masters thesis, but I don't have a CS background and didn't understand everything. From what I did understand the tactics, <code>intro</code>, <code>apply</code>, <code>induction</code>, and <code>rw</code>, relate to typing judgements, the basic building blocks of proofs.</p>
<p>Is there a list of tactics for which it's theoretically possible to prove any statement in Lean using only tactics on the list? Or is there a tactic for each typing judgement? And if so, what's the list? Or where can I learn more?</p>
<p>Thanks.</p>

<a name="189083657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083657">Mario Carneiro (Feb 26 2020 at 03:38)</a>:</h4>
<p><code>exact</code> does everything by itself</p>

<a name="189083662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083662">Mario Carneiro (Feb 26 2020 at 03:38)</a>:</h4>
<p>or <code>refine</code></p>

<a name="189083675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083675">Mario Carneiro (Feb 26 2020 at 03:39)</a>:</h4>
<p>You can probably get away with <code>intro</code> and <code>apply</code>, since that covers application and lambda</p>

<a name="189083718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083718">Mario Carneiro (Feb 26 2020 at 03:40)</a>:</h4>
<p><code>change</code> is important for triggering definitional conversion</p>

<a name="189083723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083723">Mario Carneiro (Feb 26 2020 at 03:40)</a>:</h4>
<p>but <code>induction</code> and <code>rw</code> are just fancy ways to apply functions</p>

<a name="189091945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189091945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189091945">Kevin Buzzard (Feb 26 2020 at 07:41)</a>:</h4>
<p>I guess it's theoretically possible to prove any statement in lean without using any tactics at all, because you can just use term mode. I think Agda might look like this?</p>

<a name="189082400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189082400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189082400">Lucas Allen (Feb 26 2020 at 03:02)</a>:</h4>
<p>I'm interested in learning about the basic building blocks of proofs in Lean. To this end I've read section 2 of Mario's masters thesis, but I don't have a CS background and didn't understand everything. From what I did understand the tactics, <code>intro</code>, <code>apply</code>, <code>induction</code>, and <code>rw</code>, relate to typing judgements, the basic building blocks of proofs.</p>
<p>Is there a list of tactics for which it's theoretically possible to prove any statement in Lean using only tactics on the list? Or is there a tactic for each typing judgement? And if so, what's the list? Or where can I learn more?</p>
<p>Thanks.</p>

<a name="189083657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083657">Mario Carneiro (Feb 26 2020 at 03:38)</a>:</h4>
<p><code>exact</code> does everything by itself</p>

<a name="189083662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083662">Mario Carneiro (Feb 26 2020 at 03:38)</a>:</h4>
<p>or <code>refine</code></p>

<a name="189083675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083675">Mario Carneiro (Feb 26 2020 at 03:39)</a>:</h4>
<p>You can probably get away with <code>intro</code> and <code>apply</code>, since that covers application and lambda</p>

<a name="189083718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083718">Mario Carneiro (Feb 26 2020 at 03:40)</a>:</h4>
<p><code>change</code> is important for triggering definitional conversion</p>

<a name="189083723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083723">Mario Carneiro (Feb 26 2020 at 03:40)</a>:</h4>
<p>but <code>induction</code> and <code>rw</code> are just fancy ways to apply functions</p>

<a name="189091945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189091945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189091945">Kevin Buzzard (Feb 26 2020 at 07:41)</a>:</h4>
<p>I guess it's theoretically possible to prove any statement in lean without using any tactics at all, because you can just use term mode. I think Agda might look like this?</p>

<a name="189082400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189082400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189082400">Lucas Allen (Feb 26 2020 at 03:02)</a>:</h4>
<p>I'm interested in learning about the basic building blocks of proofs in Lean. To this end I've read section 2 of Mario's masters thesis, but I don't have a CS background and didn't understand everything. From what I did understand the tactics, <code>intro</code>, <code>apply</code>, <code>induction</code>, and <code>rw</code>, relate to typing judgements, the basic building blocks of proofs.</p>
<p>Is there a list of tactics for which it's theoretically possible to prove any statement in Lean using only tactics on the list? Or is there a tactic for each typing judgement? And if so, what's the list? Or where can I learn more?</p>
<p>Thanks.</p>

<a name="189083657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083657">Mario Carneiro (Feb 26 2020 at 03:38)</a>:</h4>
<p><code>exact</code> does everything by itself</p>

<a name="189083662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083662">Mario Carneiro (Feb 26 2020 at 03:38)</a>:</h4>
<p>or <code>refine</code></p>

<a name="189083675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083675">Mario Carneiro (Feb 26 2020 at 03:39)</a>:</h4>
<p>You can probably get away with <code>intro</code> and <code>apply</code>, since that covers application and lambda</p>

<a name="189083718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083718">Mario Carneiro (Feb 26 2020 at 03:40)</a>:</h4>
<p><code>change</code> is important for triggering definitional conversion</p>

<a name="189083723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083723">Mario Carneiro (Feb 26 2020 at 03:40)</a>:</h4>
<p>but <code>induction</code> and <code>rw</code> are just fancy ways to apply functions</p>

<a name="189091945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189091945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189091945">Kevin Buzzard (Feb 26 2020 at 07:41)</a>:</h4>
<p>I guess it's theoretically possible to prove any statement in lean without using any tactics at all, because you can just use term mode. I think Agda might look like this?</p>

<a name="189082400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189082400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189082400">Lucas Allen (Feb 26 2020 at 03:02)</a>:</h4>
<p>I'm interested in learning about the basic building blocks of proofs in Lean. To this end I've read section 2 of Mario's masters thesis, but I don't have a CS background and didn't understand everything. From what I did understand the tactics, <code>intro</code>, <code>apply</code>, <code>induction</code>, and <code>rw</code>, relate to typing judgements, the basic building blocks of proofs.</p>
<p>Is there a list of tactics for which it's theoretically possible to prove any statement in Lean using only tactics on the list? Or is there a tactic for each typing judgement? And if so, what's the list? Or where can I learn more?</p>
<p>Thanks.</p>

<a name="189083657"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083657" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083657">Mario Carneiro (Feb 26 2020 at 03:38)</a>:</h4>
<p><code>exact</code> does everything by itself</p>

<a name="189083662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083662">Mario Carneiro (Feb 26 2020 at 03:38)</a>:</h4>
<p>or <code>refine</code></p>

<a name="189083675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083675">Mario Carneiro (Feb 26 2020 at 03:39)</a>:</h4>
<p>You can probably get away with <code>intro</code> and <code>apply</code>, since that covers application and lambda</p>

<a name="189083718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083718">Mario Carneiro (Feb 26 2020 at 03:40)</a>:</h4>
<p><code>change</code> is important for triggering definitional conversion</p>

<a name="189083723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189083723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189083723">Mario Carneiro (Feb 26 2020 at 03:40)</a>:</h4>
<p>but <code>induction</code> and <code>rw</code> are just fancy ways to apply functions</p>

<a name="189091945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189091945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189091945">Kevin Buzzard (Feb 26 2020 at 07:41)</a>:</h4>
<p>I guess it's theoretically possible to prove any statement in lean without using any tactics at all, because you can just use term mode. I think Agda might look like this?</p>

<a name="189178089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189178089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189178089">Lucas Allen (Feb 27 2020 at 01:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110049">Mario Carneiro</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189083718" title="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189083718">said</a>:</p>
<blockquote>
<p>You can probably get away with <code>intro</code> and <code>apply</code>, since that covers application and lambda</p>
<p><code>change</code> is important for triggering definitional conversion</p>
</blockquote>
<p>I see, thanks.</p>
<p>If <code>solve_by_elim</code> was extended so that it could also do <code>intro</code> and <code>change</code>, would it then be a proof search? I.e. if <code>max_reps := n</code>would it always find a proof of length less than or equal to <code>n</code> if one exists?</p>
<p><span class="user-mention silent" data-user-id="110038">Kevin Buzzard</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189091945" title="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189091945">said</a>:</p>
<blockquote>
<p>I guess it's theoretically possible to prove any statement in lean without using any tactics at all, because you can just use term mode. I think Agda might look like this?</p>
</blockquote>
<p>I guess this is why <code>exact</code> does everything. But that's no fun. :)</p>

<a name="189178281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189178281" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189178281">Scott Morrison (Feb 27 2020 at 01:08)</a>:</h4>
<p>No. Remember <code>solve_by_elim</code> only applies local hypotheses.</p>

<a name="189178367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189178367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189178367">Scott Morrison (Feb 27 2020 at 01:10)</a>:</h4>
<p>Also, <code>change</code> requires an explicit user provided argument, so I don't know what you're hoping it would do for you automatically.</p>

<a name="189180117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189180117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189180117">Lucas Allen (Feb 27 2020 at 01:48)</a>:</h4>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189178281" title="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189178281">said</a>:</p>
<blockquote>
<p>No. Remember <code>solve_by_elim</code> only applies local hypotheses.</p>
</blockquote>
<p>Right, but I thought if something can be proved then it can be proved only using local hypotheses, you just take the proof of lemma or theorem you'd normally use and insert in into the correct spot in your proof. Is that wrong? </p>
<p><span class="user-mention silent" data-user-id="110087">Scott Morrison</span> <a href="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189178367" title="#narrow/stream/113489-new-members/topic/Basic.20building.20block.20tactics/near/189178367">said</a>:</p>
<blockquote>
<p>Also, <code>change</code> requires an explicit user provided argument, so I don't know what you're hoping it would do for you automatically.</p>
</blockquote>
<p>I have no experience with <code>change</code>, and it's not in <code>tactics.md</code>. I'm going to spend a bit of time seeing what I can find out.</p>

<a name="189191827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189191827" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189191827">Kevin Buzzard (Feb 27 2020 at 07:13)</a>:</h4>
<p>Change = show</p>

<a name="189196387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189196387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189196387">Jasmin Blanchette (Feb 27 2020 at 08:59)</a>:</h4>
<p>If one is interested in minimalism, one can easily avoid the "change" (or "show") tactic. Say the goal is <code>⊢ half_empty</code> and I wish it were <code>⊢ half_full</code>. I can write</p>
<div class="codehilite"><pre><span></span>    <span class="n">apply</span> <span class="o">(</span><span class="k">begin</span> <span class="bp">...</span> <span class="kn">end</span> <span class="o">:</span> <span class="n">half_full</span><span class="o">)</span>

<span class="n">If</span> <span class="n">you</span> <span class="n">allow</span> <span class="n">yourself</span> <span class="bp">`</span><span class="k">have</span><span class="bp">`</span><span class="o">,</span> <span class="n">you</span> <span class="n">can</span> <span class="n">write</span>

    <span class="k">have</span> <span class="n">hhf</span> <span class="o">:</span> <span class="n">half_full</span> <span class="o">:=</span> <span class="bp">...</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">hhf</span>
</pre></div>

<a name="189271847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189271847" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189271847">Lucas Allen (Feb 28 2020 at 00:16)</a>:</h4>
<p>I'm interested in learning about the fundamental building blocks of proofs in Lean. In order to do this do I need to learn some CS stuff to the point I completely understand section 2 of Mario's thesis, or is it possible to understand what the basic building blocks are from existing tactics? I.e. are there tactics that emulate the various typing judgements, such as <code>intro</code> for example? Or am I way off base about how Lean works?</p>

<a name="189273625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189273625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189273625">Mario Carneiro (Feb 28 2020 at 00:46)</a>:</h4>
<p>I think a good place to start is by understanding term proofs, and how tactics are just mechanisms for building particular terms (which you can see with <code>#print</code>)</p>

<a name="189273729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189273729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189273729">Mario Carneiro (Feb 28 2020 at 00:48)</a>:</h4>
<p>In a tactic proof, each goal corresponds to an <code>_</code> (a hole to be filled) in the corresponding term proof, and each tactic replaces that hole with a term, usually containing more holes inside it. For example, <code>intro x</code> will replace the hole with <code>\lam x, _</code>.</p>

<a name="189273778"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189273778" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189273778">Mario Carneiro (Feb 28 2020 at 00:49)</a>:</h4>
<p>and <code>apply f</code> replaces the hole with <code>f _ _ _</code> (depending on how many arguments <code>f</code> has)</p>

<a name="189273873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189273873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189273873">Mario Carneiro (Feb 28 2020 at 00:50)</a>:</h4>
<p>It also might help to look at the definition of the <code>expr</code> type in lean, which shows all the kind of things that can appear in a term</p>

<a name="189274813"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189274813" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189274813">Lucas Allen (Feb 28 2020 at 01:07)</a>:</h4>
<p>Ok, I think I'm pretty comfortable with the idea of metavariables, but I'm might go through theorem proving in Lean again to pick up some of the things I missed the first time as well as understand what specifically different tactics are doing to the terms.</p>
<p>I'm not so comfortable with <code>expr</code>s, however, but I'll put some time into learning.</p>
<p>I'd still like to understand how a proof search tactic might work. Maybe I'll ask again after I've learned these things.</p>
<p>Thanks.</p>

<a name="189275113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189275113">Mario Carneiro (Feb 28 2020 at 01:13)</a>:</h4>
<p>A quick overview:</p>
<ul>
<li><code>intro x</code> replaces the goal with <code>\lam x, _</code></li>
<li><code>apply f</code> replaces the goal with <code>f _ _ _</code></li>
<li><code>refine e1 (e2 _) (e3 _)</code> replaces the goal with <code>e1 (e2 _) (e3 _)</code> (which should make it clear why I say sometimes that <code>refine</code> is the "universal" tactic, capable of playing the role of all others)</li>
<li><code>exact e</code> replaces the goal with <code>e</code></li>
<li><code>change foo</code> replaces the goal with <code>(_ : foo)</code></li>
<li><code>rw foo</code> replaces the goal with <code>eq.rec_on foo _</code></li>
<li><code>induction foo</code> replaces the goal with <code>T.rec_on foo _ _</code> where <code>T</code> is the type of <code>foo</code></li>
<li><code>cases foo</code>  replaces the goal with <code>T.cases_on foo _ _</code> where <code>T</code> is the type of <code>foo</code></li>
<li><code>split</code> replaces the goal with <code>and.intro _ _</code></li>
<li><code>have x := t</code> replaces the goal with <code>(\lam x, _) t</code></li>
<li><code>let x := t</code> replaces the goal with <code>let x := t in _</code></li>
<li><code>revert x</code> replaces the goal with <code>_ x</code></li>
</ul>

<a name="189275577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189275577">Mario Carneiro (Feb 28 2020 at 01:22)</a>:</h4>
<p><code>simp</code>, <code>norm_num</code>, <code>ring</code>, <code>omega</code>, <code>library_search</code>, <code>tidy</code>, <code>rcases</code>, <code>rintro</code> do more complicated or iterative things to the goal, but fundamentally they all have the same form as the above tactics: they look at the current type of the target hole and use that to determine some term, possibly with more holes in it, to fill the target</p>

<a name="189275675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189275675">Lucas Allen (Feb 28 2020 at 01:24)</a>:</h4>
<p>Awesome!</p>

<a name="189275768"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275768" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189275768">Lucas Allen (Feb 28 2020 at 01:26)</a>:</h4>
<p>Can <code>induction</code> be used instead of <code>rw</code>? For example, given <code>h : a = b</code>, can we always use <code>induction h</code> instead of <code>rw h</code>? Or are there some cases where funny things happen with <code>expr</code>s?</p>

<a name="189275771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189275771">Mario Carneiro (Feb 28 2020 at 01:26)</a>:</h4>
<p>Yep!</p>

<a name="189275798"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275798" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189275798">Mario Carneiro (Feb 28 2020 at 01:27)</a>:</h4>
<p>However it usually won't be able to calculate the "motive", a hidden extra argument to <code>eq.rec_on</code>, correctly if you use <code>induction h</code></p>

<a name="189275811"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275811" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189275811">Mario Carneiro (Feb 28 2020 at 01:27)</a>:</h4>
<p>However if one side of the equality is a variable, <code>induction h</code>, <code>cases h</code>, and <code>subst h</code> all act more or less the same way</p>

<a name="189275859"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275859" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189275859">Lucas Allen (Feb 28 2020 at 01:28)</a>:</h4>
<p>Also, are there situations where <code>cases</code> works, but induction doesn't? This might be covered in theorem proving in Lean.</p>

<a name="189275903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189275903">Mario Carneiro (Feb 28 2020 at 01:29)</a>:</h4>
<p>The reason is that unlike <code>induction</code>, <code>cases</code> is able to make use of the equality between the input and the values in the cases to eliminate some of the constructors. (If you were to do this in <code>induction</code>, the inductive hypothesis would end up being useless in most cases)</p>

<a name="189275940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189275940">Mario Carneiro (Feb 28 2020 at 01:30)</a>:</h4>
<p>Internally, <code>cases</code> actually first reverts the input variable and adds an equality</p>

<a name="189275966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189275966">Lucas Allen (Feb 28 2020 at 01:30)</a>:</h4>
<p>Oh, so <code>eq.rec_on</code> is different somehow to other <code>rec_on</code>'s for inductive types?</p>

<a name="189275983"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189275983" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189275983">Mario Carneiro (Feb 28 2020 at 01:30)</a>:</h4>
<p>No, it is just that <code>rw</code> uses an algorithm which is different from the generic one that is more useful for equalities</p>

<a name="189276066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189276066">Lucas Allen (Feb 28 2020 at 01:32)</a>:</h4>
<p>Right, because <code>induction</code> rewrites everything it can everywhere.</p>

<a name="189276075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189276075">Mario Carneiro (Feb 28 2020 at 01:32)</a>:</h4>
<p>You can always specify the motive yourself, but it's a pain. <code>eq.rec_on</code> says that from <code>a = b</code> and <code>C a</code> derive <code>C b</code>, so if you are faced with a goal that has <code>b</code>'s in it you want to reverse engineer what <code>C</code> should be so that <code>C b</code> evaluates to the goal and <code>C a</code> evaluates to something more useful</p>

<a name="189276240"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276240" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189276240">Lucas Allen (Feb 28 2020 at 01:36)</a>:</h4>
<p>Ok, so <code>rewrite</code> is a convenience thing, built for humans.</p>

<a name="189276248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189276248">Mario Carneiro (Feb 28 2020 at 01:36)</a>:</h4>
<p>yep, most tactics are like that</p>

<a name="189276267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189276267">Lucas Allen (Feb 28 2020 at 01:36)</a>:</h4>
<p>Yeah, what about <code>Ext</code>? can that be broken down into simpler tactics?</p>

<a name="189276268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189276268">Mario Carneiro (Feb 28 2020 at 01:36)</a>:</h4>
<p>you <em>could</em> write the term if you wanted to, but you don't want to</p>

<a name="189276282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276282" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189276282">Mario Carneiro (Feb 28 2020 at 01:37)</a>:</h4>
<p><code>ext</code> is just <code>try {apply f}</code> for every <code>f</code> that has been marked <code>@[ext]</code></p>

<a name="189276290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189276290">Mario Carneiro (Feb 28 2020 at 01:37)</a>:</h4>
<p>in practice, these lemmas tend to be about extensionality</p>

<a name="189276297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189276297">Lucas Allen (Feb 28 2020 at 01:37)</a>:</h4>
<p>Yeah, makes sense.</p>

<a name="189276432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189276432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189276432">Lucas Allen (Feb 28 2020 at 01:41)</a>:</h4>
<p>I have a bit to think about now. Thanks.</p>

<a name="189277748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189277748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189277748">Lucas Allen (Feb 28 2020 at 02:06)</a>:</h4>
<p>Is <code>unfold</code> just another version of <code>change</code>? I looked at the code and <code>unfold</code> uses the simplifier, which is complex and confusing.</p>

<a name="189277755"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189277755" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189277755">Lucas Allen (Feb 28 2020 at 02:07)</a>:</h4>
<p>Does <code>simp</code> use <code>change</code>?</p>

<a name="189278478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189278478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189278478">Mario Carneiro (Feb 28 2020 at 02:26)</a>:</h4>
<p><code>dsimp</code> and <code>dunfold</code> act like <code>change</code>, which is to say, they don't add anything to the term but rather just assert a new type for the term and let the kernel figure it out. (Actually that's a lie. In order to keep up performance in the kernel, the goal is actually replaced with <code>@id foo _</code> instead so that the kernel also gets the same definitional reduction hint as the elaborator. If you have <code>@id foo (@id bar x)</code>, lean's kernel is forced to prove that <code>foo</code> and <code>bar</code> are definitionally equal so that the term is well typed.)</p>

<a name="189278546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189278546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189278546">Mario Carneiro (Feb 28 2020 at 02:28)</a>:</h4>
<p><code>simp</code> and <code>unfold</code> actually insert equality theorems. It's kind of like <code>rw</code> but instead of using a single <code>eq.rec</code> term with a complicated motive, it is a <code>cast</code> applied to a bunch of congruence lemmas with types like <code>x = y -&gt; z = w -&gt; x + z = y + w</code>.</p>

<a name="189278571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189278571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189278571">Mario Carneiro (Feb 28 2020 at 02:29)</a>:</h4>
<p>This approach allows you to do extra things in the course of those lemmas, like for example ignoring equalities of arguments that are known to be in subsingleton types, as well as generally using equality proofs that are not definitional</p>

<a name="189365151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Basic%20building%20block%20tactics/near/189365151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/24711Basicbuildingblocktactics.html#189365151">Lucas Allen (Feb 29 2020 at 00:22)</a>:</h4>
<p>I see, Thanks. I had a look at <code>dunfold</code> but it's just a meta constant, so I guess it's more fundamental than <code>unfold</code>. <code>tactic.change</code> is a meta constant as well. </p>
<p>I've been rereading chapter 2 of theorem proving in Lean, and decided to have a go at reducing the proof term for <code>succ_add</code>.</p>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="n">reduce</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span>
  <span class="n">nat</span><span class="bp">.</span><span class="n">brec_on</span> <span class="n">m</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="n">F</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">))</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span>
       <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="n">F</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">))</span> <span class="n">m</span><span class="o">),</span>
          <span class="n">nat</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">m</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="bp">_</span><span class="n">F</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">))</span> <span class="mi">0</span><span class="o">),</span>
               <span class="n">id_rhs</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">)</span> <span class="n">rfl</span><span class="o">)</span>
            <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="n">F</span> <span class="o">:</span> <span class="n">nat</span><span class="bp">.</span><span class="n">below</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">))</span> <span class="o">(</span><span class="n">succ</span> <span class="n">m</span><span class="o">)),</span>
               <span class="n">id_rhs</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)))</span> <span class="o">(</span><span class="n">congr_arg</span> <span class="n">succ</span> <span class="o">(</span><span class="bp">_</span><span class="n">F</span><span class="bp">.</span><span class="n">fst</span><span class="bp">.</span><span class="n">fst</span> <span class="n">n</span><span class="o">)))</span>
            <span class="bp">_</span><span class="n">F</span><span class="o">)</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">_</span><span class="n">F</span><span class="o">)</span> <span class="n">n</span>
</pre></div>


<p>It gives me <code>λ (n m : ℕ), ⁇</code> and red sqiggle under <code>nat.brec_on</code> with the error message "invalid 'nat.brec_on' application, elaborator has special support for this kind of application (it is handled as an "eliminator"), but the expected type must be known."</p>
<p>Does it want know the type of <code>succ_add</code>? And is there some way to reduce a proof term to the type it's proving?</p>


{% endraw %}

{% include archive_update.html %}