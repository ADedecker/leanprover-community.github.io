---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/50770rwfailure.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html">rw failure</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="158582769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/158582769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#158582769">Paula Neeley (Feb 15 2019 at 02:00)</a>:</h4>
<p>Hey guys,<br>
First timer, so please be nice :)<br>
I'm aiming to prove the example at the bottom of the long code snippet. I made the lemmas "foo" and "bar" to help. My theorem "bar" worked to prove the inductive step, but I don't understand the output that Lean gives me when I try to prove this lemma "bar" itself. The base case gives me the output:</p>
<div class="codehilite"><pre><span></span>2 goals
case list.nil
α : Type u_1,
s : list α,
a : α
⊢ length (s ++ [a]) = length (s ++ nil) + 1
</pre></div>


<p>Specifically, I am unsure what the [a] here means and how to work with it. Any insights would be appreciated.</p>
<div class="codehilite"><pre><span></span>section
open list

variable {α : Type*}
variables s t : list α
variable a : α

theorem length_nil : length (@nil α) = 0 := rfl

theorem foo (t : list α) : t ++ nil = t :=
begin
induction t with a t ih,
{refl},
rw [cons_append, ih],
end

theorem bar : length (s ++ a :: t) = length (s ++ t) + 1 :=
begin
induction t with a t ih,
sorry
end

#check foo
#check nil_append
#check cons_append
#check length_cons
#check length_nil

#eval [1, 2, 3] ++ [4, 5]
#eval length [1, 2, 3, 4, 5]

end

/-
Prove the following.
-/

section
open list

variable {α : Type*}
variables s t : list α
variable a : α

example : length (s ++ t) = length s + length t :=
begin
induction t with a t ih,
{rw [length_nil, foo], refl},
rw [length_cons, bar, ih], refl,
end

end
</pre></div>

<a name="158583275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/158583275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#158583275">Simon Hudon (Feb 15 2019 at 02:12)</a>:</h4>
<p><code>[a]</code> is the same as <code>a :: nil</code> (it's a special notation)</p>

<a name="158583362"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/158583362" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#158583362">Simon Hudon (Feb 15 2019 at 02:14)</a>:</h4>
<p>You should consider doing your induction on <code>s</code> instead of <code>t</code>. The reason is that <code>++</code> is defined by recursion on <code>s</code> : <code>x :: xs ++ ys = x :: (xs ++ ys)</code></p>

<a name="158583389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/158583389" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#158583389">Simon Hudon (Feb 15 2019 at 02:15)</a>:</h4>
<p>Also: welcome to Zulip Paula!</p>

<a name="158583402"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/158583402" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#158583402">Paula Neeley (Feb 15 2019 at 02:15)</a>:</h4>
<blockquote>
<p>You should consider doing your induction on <code>s</code> instead of <code>t</code>. The reason is that <code>++</code> is defined by recursion on <code>s</code> : <code>x :: xs ++ ys = x :: (xs ++ ys)</code></p>
</blockquote>
<p>Oh ok, I will try that! Thank you for your help!</p>

<a name="158598928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/158598928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#158598928">Kenny Lau (Feb 15 2019 at 08:32)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">list</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kn">variables</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span>
<span class="kn">variable</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span>

<span class="kn">theorem</span> <span class="n">length_nil</span> <span class="o">:</span> <span class="n">length</span> <span class="o">(</span><span class="bp">@</span><span class="n">nil</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">append_nil&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="n">t</span> <span class="bp">++</span> <span class="n">nil</span> <span class="bp">=</span> <span class="n">t</span>
<span class="bp">|</span> <span class="o">[]</span>       <span class="o">:=</span> <span class="n">rfl</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span><span class="bp">::</span><span class="n">tl</span><span class="o">)</span> <span class="o">:=</span> <span class="n">congr_arg</span> <span class="o">((</span><span class="bp">::</span><span class="o">)</span><span class="n">hd</span><span class="o">)</span> <span class="o">(</span><span class="n">append_nil</span> <span class="n">tl</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">length_append&#39;</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">,</span> <span class="n">length</span> <span class="o">(</span><span class="n">s</span> <span class="bp">++</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">length</span> <span class="n">s</span> <span class="bp">+</span> <span class="n">length</span> <span class="n">t</span>
<span class="bp">|</span> <span class="o">[]</span>       <span class="n">t</span> <span class="o">:=</span> <span class="o">(</span><span class="n">zero_add</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">hd</span><span class="bp">::</span><span class="n">tl</span><span class="o">)</span> <span class="n">t</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">length_cons</span><span class="o">,</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ_add</span><span class="o">,</span> <span class="err">←</span> <span class="n">length_append&#39;</span> <span class="n">tl</span> <span class="n">t</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span>

<span class="kn">theorem</span> <span class="n">length_append_cons</span> <span class="o">:</span> <span class="n">length</span> <span class="o">(</span><span class="n">s</span> <span class="bp">++</span> <span class="n">a</span> <span class="bp">::</span> <span class="n">t</span><span class="o">)</span> <span class="bp">=</span> <span class="n">length</span> <span class="o">(</span><span class="n">s</span> <span class="bp">++</span> <span class="n">t</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">length_append&#39;</span><span class="o">,</span> <span class="n">length_append&#39;</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">append_nil&#39;</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">nil_append</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">cons_append</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">length_cons</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">length_nil</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="bp">++</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>
<span class="bp">#</span><span class="kn">eval</span> <span class="n">length</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span>

<span class="kn">end</span> <span class="n">list</span>
</pre></div>

<a name="160868091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160868091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160868091">Robert Spencer (Mar 15 2019 at 12:00)</a>:</h4>
<p>(deleted)</p>

<a name="160868727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160868727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160868727">Tony Wang (Mar 15 2019 at 12:11)</a>:</h4>
<p>(deleted)</p>

<a name="160869044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160869044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160869044">Tony Wang (Mar 15 2019 at 12:17)</a>:</h4>
<p>Hello - I was just wondering for the bit where I have <code>rw succ_a_plus_b_equals_a_plus_succ_b</code> below, surely there's a better way to use the definition of <code>add</code>?</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">xnat</span>
<span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">xnat</span>
<span class="bp">|</span> <span class="n">succ</span> <span class="o">:</span> <span class="n">xnat</span> <span class="bp">→</span> <span class="n">xnat</span>

<span class="kn">open</span> <span class="n">xnat</span>

<span class="n">def</span> <span class="n">add</span> <span class="o">:</span> <span class="n">xnat</span> <span class="bp">→</span> <span class="n">xnat</span> <span class="bp">→</span> <span class="n">xnat</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">zero</span> <span class="o">:=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>

<span class="kn">notation</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">add</span> <span class="n">a</span> <span class="n">b</span>

<span class="kn">theorem</span> <span class="n">succ_a_plus_b_equals_a_plus_succ_b</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">xnat</span><span class="o">)</span> <span class="o">:</span> <span class="n">succ</span><span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">succ</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">add</span>

<span class="kn">theorem</span> <span class="n">succ_is_succ_zero_add</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">xnat</span><span class="o">)</span> <span class="o">:</span> <span class="n">succ</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">succ</span> <span class="n">zero</span> <span class="bp">+</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">begin</span>
    <span class="n">induction</span> <span class="n">a</span> <span class="k">with</span> <span class="n">k</span> <span class="n">Hk</span><span class="o">,</span>
    <span class="o">{</span>
        <span class="n">unfold</span> <span class="n">add</span>
    <span class="o">},</span>
    <span class="o">{</span>
        <span class="n">rw</span> <span class="n">Hk</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">succ_a_plus_b_equals_a_plus_succ_b</span><span class="o">,</span>
        <span class="n">rw</span> <span class="n">Hk</span>
    <span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="160869148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160869148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160869148">Tony Wang (Mar 15 2019 at 12:18)</a>:</h4>
<p>Nvm I found it: <code>rw ←add</code> seems to work!</p>

<a name="160869187"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160869187" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160869187">Calle Sönne (Mar 15 2019 at 12:19)</a>:</h4>
<p>I have the following code:</p>
<div class="codehilite"><pre><span></span><span class="kn">definition</span> <span class="n">digit</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">floor</span><span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="n">b</span> <span class="err">^</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">-</span> <span class="n">floor</span><span class="o">(</span><span class="n">r</span> <span class="bp">*</span> <span class="n">b</span> <span class="err">^</span> <span class="n">n</span><span class="o">)</span><span class="bp">*</span><span class="n">b</span>

<span class="kn">lemma</span> <span class="n">digit_mul_base</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">digit</span> <span class="n">b</span> <span class="n">r</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">digit</span> <span class="n">b</span> <span class="o">(</span><span class="n">r</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rwa</span> <span class="o">[</span><span class="n">digit</span><span class="o">,</span> <span class="n">digit</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">],</span> <span class="n">conv</span>
  <span class="k">begin</span> <span class="n">congr</span><span class="o">,</span> <span class="n">skip</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">nat</span><span class="bp">.</span><span class="n">cast_pow</span><span class="o">,</span> <span class="err">←</span><span class="n">nat</span><span class="bp">.</span><span class="n">cast_mul</span><span class="o">,</span> <span class="err">←</span><span class="n">pow_succ</span> <span class="n">b</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)],</span>
  <span class="kn">end</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>This gives me an error with following tactic state:</p>
<div class="codehilite"><pre><span></span><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kn">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="n">b</span> <span class="bp">*</span> <span class="n">b</span> <span class="err">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">state</span><span class="o">:</span>
<span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">linear_ordered_ring</span> <span class="n">α</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">floor_ring</span> <span class="n">α</span><span class="o">,</span>
<span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">r</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
<span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span>
<span class="err">⊢</span> <span class="err">⌊</span><span class="n">r</span> <span class="bp">*</span> <span class="err">↑</span><span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">b</span> <span class="err">^</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span><span class="err">⌋</span> <span class="bp">-</span> <span class="err">⌊</span><span class="n">r</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">b</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">b</span> <span class="err">^</span> <span class="n">n</span><span class="err">⌋</span> <span class="bp">*</span> <span class="err">↑</span><span class="n">b</span> <span class="bp">=</span> <span class="err">?</span><span class="n">m_1</span>
</pre></div>


<p>I cant seem to find the error, any help would be appreciated</p>

<a name="160869679"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160869679" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160869679">Tony Wang (Mar 15 2019 at 12:27)</a>:</h4>
<p>If I unfold a definition with more than one part, is it possible to specify which part I want to unfold?</p>

<a name="160869914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160869914" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160869914">Mario Carneiro (Mar 15 2019 at 12:30)</a>:</h4>
<p>you can use <code>conv</code> to focus on a subterm</p>

<a name="160904675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160904675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160904675">Kevin Buzzard (Mar 15 2019 at 19:14)</a>:</h4>
<p>[changed thread title]. <span class="user-mention" data-user-id="132603">@Calle Sönne</span> </p>
<p>One <code>b * b ^ (n + 1)</code> is</p>
<div class="codehilite"><pre><span></span>    @has_mul.mul.{0} nat (@semigroup.to_has_mul.{0} nat (@monoid.to_semigroup.{0} nat nat.monoid)) b
    (@has_pow.pow.{0 0} nat nat (@monoid.has_pow.{0} nat nat.monoid) b
       (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
</pre></div>


<p>and the other is</p>
<div class="codehilite"><pre><span></span>     (@has_mul.mul.{0} nat nat.has_mul b
                   (@has_pow.pow.{0 0} nat nat nat.has_pow b
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))))))
</pre></div>


<p>and these are apparently not defeq.</p>

<a name="160904926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160904926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160904926">Kevin Buzzard (Mar 15 2019 at 19:17)</a>:</h4>
<p><code>example : @monoid.has_pow.{0} nat nat.monoid = nat.has_pow := rfl -- fails</code></p>
<p>There's the problem. You have two different powers.</p>

<a name="160905588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160905588" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160905588">Kevin Buzzard (Mar 15 2019 at 19:24)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">test</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">has_pow</span><span class="bp">.</span><span class="n">pow</span> <span class="bp">ℕ</span> <span class="bp">ℕ</span> <span class="o">(</span><span class="bp">@</span><span class="n">monoid</span><span class="bp">.</span><span class="n">has_pow</span><span class="bp">.</span><span class="o">{</span><span class="mi">0</span><span class="o">}</span> <span class="n">nat</span> <span class="n">nat</span><span class="bp">.</span><span class="n">monoid</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="err">^</span> <span class="n">b</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">induction</span> <span class="n">b</span> <span class="k">with</span> <span class="n">c</span> <span class="n">Hc</span><span class="o">,</span>
    <span class="n">refl</span><span class="o">,</span>
  <span class="n">unfold</span> <span class="n">has_pow</span><span class="bp">.</span><span class="n">pow</span> <span class="n">monoid</span><span class="bp">.</span><span class="n">pow</span> <span class="n">nat</span><span class="bp">.</span><span class="n">pow</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">Hc</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">mul_comm</span><span class="o">,</span> <span class="c1">-- *boggle*</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">digit_mul_base</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">digit</span> <span class="n">b</span> <span class="n">r</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="n">digit</span> <span class="n">b</span> <span class="o">(</span><span class="n">r</span><span class="bp">*</span><span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">rwa</span> <span class="o">[</span><span class="n">digit</span><span class="o">,</span> <span class="n">digit</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">],</span> <span class="n">conv</span>
  <span class="k">begin</span> <span class="n">congr</span><span class="o">,</span> <span class="n">skip</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">←</span><span class="n">nat</span><span class="bp">.</span><span class="n">cast_pow</span><span class="o">,</span> <span class="err">←</span><span class="n">nat</span><span class="bp">.</span><span class="n">cast_mul</span><span class="o">],</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">test</span><span class="o">,</span> <span class="c1">-- no visible effect ;-)</span>
  <span class="n">rw</span> <span class="err">←</span><span class="n">pow_succ</span> <span class="n">b</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">),</span> <span class="c1">-- works now ;-)</span>
  <span class="kn">end</span><span class="o">,</span>
</pre></div>

<a name="160905621"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160905621" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160905621">Kevin Buzzard (Mar 15 2019 at 19:24)</a>:</h4>
<p>So there's a crappy fix, but actually someone with some sense should hopefully come along at some point and tell us what we should be doing. <span class="user-mention" data-user-id="110044">@Chris Hughes</span> ?</p>

<a name="160905675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160905675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160905675">Chris Hughes (Mar 15 2019 at 19:25)</a>:</h4>
<p>There's a lemma <code>nat.pow_eq_pow</code> I think.</p>

<a name="160905709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160905709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160905709">Kevin Buzzard (Mar 15 2019 at 19:26)</a>:</h4>
<p>Thanks. <span class="user-mention" data-user-id="132603">@Calle Sönne</span> rewrite that instead of <code>test</code>.</p>

<a name="160905766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160905766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160905766">Chris Hughes (Mar 15 2019 at 19:26)</a>:</h4>
<p>It's also a crappy fix</p>

<a name="160905793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160905793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160905793">Kevin Buzzard (Mar 15 2019 at 19:26)</a>:</h4>
<p>yes but at least we're going in the right direction. Why did it happen? Something to do with the casts no doubt.</p>

<a name="160905809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160905809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160905809">Kevin Buzzard (Mar 15 2019 at 19:26)</a>:</h4>
<p>We can add this one to Rob Lewis' list of cast issues ;-)</p>

<a name="160906309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160906309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160906309">Chris Hughes (Mar 15 2019 at 19:32)</a>:</h4>
<p>The better solution is actually to use <code>nat.pow_succ</code> on closer inspection.</p>

<a name="160944954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160944954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160944954">Calle Sönne (Mar 16 2019 at 10:01)</a>:</h4>
<p>thanks, that worked</p>

<a name="160945015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160945015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160945015">Kevin Buzzard (Mar 16 2019 at 10:02)</a>:</h4>
<p>Aah bingo</p>

<a name="160945040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/rw%20failure/near/160945040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/50770rwfailure.html#160945040">Kevin Buzzard (Mar 16 2019 at 10:03)</a>:</h4>
<p>Nat has its own suite of pow lemmas because nat.pow is in core so we can't redefine it to be monoid.pow</p>


{% endraw %}

{% include archive_update.html %}