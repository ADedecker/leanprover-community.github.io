---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/17142basics.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html">basics</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="185060255"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185060255" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185060255">Iocta (Jan 07 2020 at 22:09)</a>:</h4>
<p>Is there a built-in function <code>\lambda h, h</code>?</p>

<a name="185060400"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185060400" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185060400">Aria Miuk (Jan 07 2020 at 22:10)</a>:</h4>
<p>That should be <code>id</code>.</p>

<a name="185060417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185060417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185060417">Iocta (Jan 07 2020 at 22:11)</a>:</h4>
<p>Thanks</p>

<a name="185060600"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185060600" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185060600">Iocta (Jan 07 2020 at 22:14)</a>:</h4>
<p>Is it possible to do this without <code>classical</code>? <code>example : ¬(p ↔ ¬p) := sorry</code></p>

<a name="185061003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185061003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185061003">Simon Hudon (Jan 07 2020 at 22:19)</a>:</h4>
<p>Yes. Do you want to prove it yourself?</p>

<a name="185061088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185061088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185061088">Aria Miuk (Jan 07 2020 at 22:20)</a>:</h4>
<p>Yes it is provable. Think about  how to get <code>p</code> into context and the definition of <code>not</code>.</p>

<a name="185062439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185062439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185062439">Iocta (Jan 07 2020 at 22:36)</a>:</h4>
<p>No luck. How do I get <code>p</code> into context?</p>

<a name="185062517"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185062517" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185062517">Bryan Gin-ge Chen (Jan 07 2020 at 22:37)</a>:</h4>
<p>Have you been able to get <code>¬p</code> into the goal? Remember that this is actually <code>p → false</code>.</p>

<a name="185063226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185063226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185063226">Aria Miuk (Jan 07 2020 at 22:46)</a>:</h4>
<p>Strat with <code>intros contra</code> (or <code>\lambda contra, _</code>) and see how one magically conjures hypotheses :).</p>

<a name="185064582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185064582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185064582">Iocta (Jan 07 2020 at 23:04)</a>:</h4>
<p>I'm missing something. I can't find anything shaped like <code>p</code> or <code>p \to false</code>.</p>

<a name="185064698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185064698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185064698">Aria Miuk (Jan 07 2020 at 23:06)</a>:</h4>
<p>You're on the right path. You're looking for something <code>p \to false</code>. Can you prove it?</p>

<a name="185066693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185066693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185066693">Iocta (Jan 07 2020 at 23:37)</a>:</h4>
<p>No I'm back where I started :-)</p>

<a name="185066764"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185066764" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185066764">Aria Miuk (Jan 07 2020 at 23:38)</a>:</h4>
<p>Look at your contradictory hypothesis, <code>(p ↔ ¬p)</code>. You "win" once you either know <code>p</code>, or <code>not p</code>. Agreed? (As this then leads to contradiction.)</p>

<a name="185066856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185066856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185066856">Aria Miuk (Jan 07 2020 at 23:40)</a>:</h4>
<p>So then surely the <em>only</em> way to prove this is to either know <code>p</code> or <code>not p</code>. There is bound to be no other way.</p>

<a name="185066896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185066896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185066896">Aria Miuk (Jan 07 2020 at 23:41)</a>:</h4>
<p>So choose one, whichever you prefer. And formulate: <code>have h : p, { ... }</code>. (Or the other one.)</p>

<a name="185067013"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185067013" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185067013">Aria Miuk (Jan 07 2020 at 23:42)</a>:</h4>
<p>Can you prove either of these? What happens if you attempt?</p>

<a name="185069953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185069953" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185069953">Iocta (Jan 08 2020 at 00:31)</a>:</h4>
<p>I want to do something like <code>or.elim hp</code>, but I can't figure out how to make <code>hp</code>. </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">c</span><span class="o">,</span>
<span class="k">have</span> <span class="n">hp</span><span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="bp">_</span><span class="o">,</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="bp">_</span>
</pre></div>

<a name="185070165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185070165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185070165">Iocta (Jan 08 2020 at 00:35)</a>:</h4>
<p>If hp then hnp, and absurd hp hnp. And vice versa. But how do I state either of those hypotheses?</p>

<a name="185070268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185070268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185070268">Aria Miuk (Jan 08 2020 at 00:37)</a>:</h4>
<p>So you need to prove <code>p</code>. Surely your only hypothesis is <code>c</code>. Let's use it. <code>c.2</code> gives us <code>not p -&gt; p</code>, we apply it to get the conclusion <code>not p</code>. So far so good?</p>

<a name="185070320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185070320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185070320">Bryan Gin-ge Chen (Jan 08 2020 at 00:38)</a>:</h4>
<p>Here's another transcript of my thoughts as I work through the start of this one "automatically" (in the style of <a href="#narrow/stream/113489-new-members/topic/.60or.60.20implication/near/184439048" title="#narrow/stream/113489-new-members/topic/.60or.60.20implication/near/184439048">this previous post</a>). </p>
<p>We start out with a single underscore and let Lean tell us what's missing:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- (1)</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">_</span>
<span class="c">/-</span><span class="cm"> p : Prop</span>
<span class="cm">⊢ ¬(p ↔ ¬p) -/</span>
</pre></div>


<p>Here and below, I'll just quote the part of the error message(s) that shows the hypotheses in the context and the goal. Since <code>¬(p ↔ ¬p)</code> is the same as <code>(p ↔ ¬p) → false</code>, which is a function type, we should be able to make progress by introducing a lambda:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- (2a)</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="bp">_</span>
<span class="c">/-</span><span class="cm"> p : Prop,</span>
<span class="cm">h : p ↔ ¬p</span>
<span class="cm">⊢ false -/</span>
</pre></div>


<p>Note that <code>p ↔ ¬p</code> is the same as <code>(p → ¬p) ∧ (¬p → p)</code> so we could proceed by using <code>h.1</code> and <code>h.2</code>. However, I'll redo this step by making use of Lean's pattern-matching syntax to split <code>h</code> into two hypotheses:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- (2b)</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">_</span>
<span class="c">/-</span><span class="cm"> p : Prop,</span>
<span class="cm">_x : p ↔ ¬p,</span>
<span class="cm">_fun_match : (p ↔ ¬p) → false,</span>
<span class="cm">h1 : p → ¬p,</span>
<span class="cm">h2 : ¬p → p</span>
<span class="cm">⊢ false -/</span>
</pre></div>


<p>Aside from <code>h1</code> and <code>h2</code> there's some other junk in the context related to the pattern-matching; I won't show it again below. Now, how do we make progress towards the goal of <code>false</code>? Now we realize that <code>h1 : p → ¬p</code> is short for <code>h1 : p → p → false</code>. Since passing two parameters to <code>h1</code> will yield <code>false</code>, we should try replacing the underscore with <code>h1 _ _</code>:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- (3)</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h1</span> <span class="bp">_</span> <span class="bp">_</span>
<span class="c">/-</span><span class="cm"> h1 : p → ¬p,</span>
<span class="cm">h2 : ¬p → p</span>
<span class="cm">⊢ p -/</span>
<span class="c">/-</span><span class="cm"> h1 : p → ¬p,</span>
<span class="cm">h2 : ¬p → p</span>
<span class="cm">⊢ p -/</span>
</pre></div>


<p>There are now two error messages because there are two underscores. Since I'm only intending to show a few more steps, from here on out I'm only going to show the error message corresponding to the first underscore. How do we make progress towards <code>p</code> there? Well, note that <code>h2 : ¬p → p</code> is a function which takes one parameter and returns <code>p</code>, so let's replace the underscore with <code>h2 _</code>:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- (4)</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h1</span> <span class="o">(</span><span class="n">h2</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">_</span>
<span class="c">/-</span><span class="cm"> h1 : p → ¬p,</span>
<span class="cm">h2 : ¬p → p</span>
<span class="cm">⊢ ¬p -/</span>
</pre></div>


<p>Hey, here's the goal of <code>¬p</code> we hinted at! Now what? Well, naïvely, we might apply <code>h1</code> again, since it ends in <code>¬p</code>. However, if you try this, you'll see that continuing this way won't work (try it, what happens?). What should we do instead? Well, if we instead observe that <code>¬p</code> is the same as <code>p → false</code>, we can alternatively introduce another lambda here:</p>
<div class="codehilite"><pre><span></span><span class="c1">-- (5)</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">⟨</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h1</span> <span class="o">(</span><span class="n">h2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h3</span><span class="o">,</span> <span class="bp">_</span><span class="o">))</span> <span class="bp">_</span>
<span class="c">/-</span><span class="cm"> h1 : p → ¬p,</span>
<span class="cm">h2 : ¬p → p,</span>
<span class="cm">h3 : p</span>
<span class="cm">⊢ false -/</span>
</pre></div>


<p>Now we have <code>p</code> in the context, as desired! I'll leave the rest to you, but one final hint. Our goal is <code>false</code> again. Last time we saw this (step (3)), we replaced the underscore with <code>h1 _ _</code>. You should try doing this again. You'll end up in a state with 3 underscores / errors, but there's now something in the context which will let you close two of them right away...</p>
<p>You can fill in the last underscore very similarly.</p>
<p>When you get to the end, you'll notice that in blindly "chasing underscores" we end up with quite a bit of duplication. We could have avoided this by naming some terms with <code>have</code> statements, and it's worth refactoring the proof along those lines. Then you might start again from scratch and try to write a version of the proof with the <code>have</code> statements from the beginning.</p>

<a name="185071145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185071145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185071145">Iocta (Jan 08 2020 at 00:52)</a>:</h4>
<p>I'll meditate on this. Thanks.</p>

<a name="185073964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185073964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185073964">Iocta (Jan 08 2020 at 01:51)</a>:</h4>
<p>The basic version looks like </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="bp">|</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">|</span><span class="o">),</span>
<span class="o">(</span><span class="n">h1</span>
  <span class="o">(</span><span class="n">h2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">hp</span> <span class="o">(</span><span class="n">h1</span> <span class="n">hp</span><span class="o">)))</span>
  <span class="o">(</span><span class="n">h2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">hp</span> <span class="o">(</span><span class="n">h1</span> <span class="n">hp</span><span class="o">)))</span>
<span class="o">)</span>
</pre></div>


<p>Is this less redundant, or is it the same thing?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="bp">|</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">|</span><span class="o">),</span>
<span class="k">have</span> <span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp&#39;</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">hp&#39;</span> <span class="o">(</span><span class="n">h1</span> <span class="n">hp&#39;</span><span class="o">)),</span>
<span class="k">have</span> <span class="n">hp</span><span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">h2</span> <span class="n">hnp</span><span class="o">),</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">absurd</span> <span class="n">hp</span> <span class="n">hnp</span><span class="o">)</span>
</pre></div>

<a name="185075337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185075337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185075337">Bryan Gin-ge Chen (Jan 08 2020 at 02:27)</a>:</h4>
<p>Well, <code>absurd</code> itself is short for a certain proof term... do you know how <code>absurd</code> is proved?</p>

<a name="185075875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185075875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185075875">Kenny Lau (Jan 08 2020 at 02:40)</a>:</h4>
<p><span class="user-mention" data-user-id="253355">@Iocta</span> maybe try this more general theorem:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">Curry&#39;s_paradox</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">))</span> <span class="bp">→</span> <span class="n">q</span> <span class="o">:=</span>
<span class="bp">_</span>
</pre></div>

<a name="185077413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185077413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185077413">Iocta (Jan 08 2020 at 03:17)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="bp">|</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">|</span><span class="o">),</span>
<span class="k">have</span> <span class="n">hnp</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp&#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">h1</span> <span class="n">hp&#39;</span><span class="o">)</span>  <span class="n">hp&#39;</span><span class="o">),</span>
<span class="k">have</span> <span class="n">hp</span><span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">h2</span> <span class="n">hnp</span><span class="o">),</span>
<span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">hnp</span> <span class="n">hp</span>
</pre></div>

<a name="185077889"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185077889" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185077889">Iocta (Jan 08 2020 at 03:27)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">Curry&#39;s_paradox</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">))</span> <span class="bp">→</span> <span class="n">q</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">(</span><span class="bp">|</span><span class="n">h1</span><span class="o">,</span> <span class="n">h2</span><span class="bp">|</span><span class="o">),</span>
<span class="k">have</span> <span class="n">hp</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">h2</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp&#39;</span><span class="o">,</span> <span class="n">h1</span> <span class="n">hp&#39;</span> <span class="n">hp&#39;</span><span class="o">)),</span>
<span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">h1</span> <span class="n">hp</span> <span class="n">hp</span><span class="o">)</span>
</pre></div>

<a name="185079877"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185079877" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185079877">Kevin Buzzard (Jan 08 2020 at 04:17)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kn">theorem</span> <span class="n">Curry&#39;s_paradox</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">↔</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">))</span> <span class="bp">→</span> <span class="n">q</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">tauto</span><span class="bp">!</span>
</pre></div>

<a name="185087888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185087888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185087888">Iocta (Jan 08 2020 at 08:00)</a>:</h4>
<p>Why's this wrong? How to fix it?</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">classical</span>

<span class="kn">lemma</span> <span class="n">unnotnot</span> <span class="o">:</span> <span class="bp">¬¬</span><span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">hnnp</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnp</span><span class="o">,</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">absurd</span> <span class="n">hnp</span> <span class="n">hnnp</span><span class="o">))</span>


<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">q</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span>
<span class="k">have</span> <span class="n">hnq</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">by_contradiction</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnnq</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">hp</span> <span class="o">(</span><span class="n">unnotnot</span> <span class="n">hnnq</span><span class="o">)))),</span>
  <span class="k">show</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span>
<span class="o">)</span>
<span class="n">or</span><span class="bp">.</span><span class="n">inl</span>
</pre></div>

<a name="185088007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185088007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185088007">Kenny Lau (Jan 08 2020 at 08:02)</a>:</h4>
<p><code>or.inr</code> should be <code>or.inr hnq</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">classical</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">unnotnot</span> <span class="o">:</span> <span class="bp">¬¬</span><span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">hnnp</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnp</span><span class="o">,</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">absurd</span> <span class="n">hnp</span> <span class="n">hnnp</span><span class="o">))</span>


<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span> <span class="bp">∨</span> <span class="bp">¬</span><span class="n">q</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span>
<span class="k">have</span> <span class="n">hnq</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">by_contradiction</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnnq</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">hp</span> <span class="o">(</span><span class="n">unnotnot</span> <span class="n">hnnq</span><span class="o">)))),</span>
  <span class="k">show</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="n">hnq</span>
<span class="o">)</span>
<span class="n">or</span><span class="bp">.</span><span class="n">inl</span>
</pre></div>

<a name="185088037"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185088037" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185088037">Kenny Lau (Jan 08 2020 at 08:03)</a>:</h4>
<p>the type of <code>or.inr</code> is unified with <code>¬q → ¬p ∨ ¬q</code></p>

<a name="185088366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185088366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185088366">Iocta (Jan 08 2020 at 08:10)</a>:</h4>
<p>Thanks</p>

<a name="185088591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185088591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185088591">Iocta (Jan 08 2020 at 08:15)</a>:</h4>
<p>Is it possible to prove <code>unnotnot</code> without <code>classical</code>?</p>

<a name="185088969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185088969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185088969">Kenny Lau (Jan 08 2020 at 08:24)</a>:</h4>
<p>no</p>

<a name="185088972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185088972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185088972">Kenny Lau (Jan 08 2020 at 08:24)</a>:</h4>
<p>it's equivalent to <code>em</code></p>

<a name="185194501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185194501" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185194501">Iocta (Jan 09 2020 at 09:07)</a>:</h4>
<p>When I have <code>\not p</code> in context and <code>p</code> in goal, is there something I should be saying to myself?</p>

<a name="185194680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185194680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185194680">Kenny Lau (Jan 09 2020 at 09:10)</a>:</h4>
<p>if you can prove the goal, then you can prove <code>false</code>; so maybe aim to prove <code>false</code> instead</p>

<a name="185194700"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185194700" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185194700">Iocta (Jan 09 2020 at 09:10)</a>:</h4>
<p>Alright</p>

<a name="185447701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185447701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185447701">Iocta (Jan 12 2020 at 19:54)</a>:</h4>
<p>Can I fill this underscore, or am I down the wrong path? </p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="n">q</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
<span class="k">have</span> <span class="n">notq</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hq&#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span> <span class="n">hq&#39;</span><span class="o">))),</span>
<span class="n">and</span><span class="bp">.</span><span class="n">intro</span>
<span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnp</span><span class="o">,</span> <span class="bp">_</span><span class="o">))</span>
<span class="n">notq</span>
</pre></div>

<a name="185447788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185447788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185447788">Chris Hughes (Jan 12 2020 at 19:56)</a>:</h4>
<p>You can fill in the underscore</p>

<a name="185447848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185447848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185447848">Iocta (Jan 12 2020 at 19:58)</a>:</h4>
<p>ok</p>

<a name="185447863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185447863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185447863">Iocta (Jan 12 2020 at 19:58)</a>:</h4>
<p>Is it possible to get into situations where I wouldn't be able to fill in the underscore, but where the overall claim is true?</p>

<a name="185447885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185447885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185447885">Kenny Lau (Jan 12 2020 at 19:59)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="bp">_</span>
</pre></div>

<a name="185447966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185447966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185447966">Bryan Gin-ge Chen (Jan 12 2020 at 20:00)</a>:</h4>
<p>There was another example at the very end of <a href="#narrow/stream/113489-new-members/topic/.60or.60.20implication/near/184439048" title="#narrow/stream/113489-new-members/topic/.60or.60.20implication/near/184439048">this reply</a> to one of your questions (step 2R).</p>

<a name="185448066"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185448066" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185448066">Iocta (Jan 12 2020 at 20:03)</a>:</h4>
<p>how do I find conversations I've been involved in on zulip?</p>

<a name="185448137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185448137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185448137">Kevin Buzzard (Jan 12 2020 at 20:05)</a>:</h4>
<p>search for yourself using the search bar at the top.</p>

<a name="185448185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185448185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185448185">Iocta (Jan 12 2020 at 20:06)</a>:</h4>
<p>ah I see</p>

<a name="185458232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185458232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185458232">Iocta (Jan 13 2020 at 01:06)</a>:</h4>
<p>This <code>example</code> works but it's quite long. Did I miss some opportunity to simplify?</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kn">theorem</span> <span class="n">contrap</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="bp">¬</span><span class="n">q</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span> <span class="n">hnq</span> <span class="n">hp</span><span class="o">,</span> <span class="n">hnq</span> <span class="o">(</span><span class="n">h</span> <span class="n">hp</span><span class="o">)</span>


<span class="kn">open</span> <span class="n">classical</span>

<span class="kn">lemma</span> <span class="n">unnotnot</span> <span class="o">:</span> <span class="bp">¬¬</span><span class="n">p</span> <span class="bp">→</span> <span class="n">p</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">hnnp</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnp</span><span class="o">,</span> <span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">absurd</span> <span class="n">hnp</span> <span class="n">hnnp</span><span class="o">))</span>

<span class="kn">lemma</span> <span class="n">notnot</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="bp">¬¬</span><span class="n">p</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">hp</span> <span class="n">hnp</span><span class="o">,</span> <span class="n">hnp</span> <span class="n">hp</span>

<span class="kn">theorem</span> <span class="n">ncontrap</span> <span class="o">:</span> <span class="o">(</span> <span class="bp">¬</span><span class="n">p</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">q</span> <span class="bp">→</span> <span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">np2nq</span> <span class="n">hq</span><span class="o">,</span>
<span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span>
<span class="n">id</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">hnp</span><span class="o">,</span>  <span class="o">(</span><span class="n">absurd</span> <span class="o">(</span><span class="n">np2nq</span> <span class="n">hnp</span><span class="o">)</span>   <span class="o">(</span><span class="n">notnot</span> <span class="bp">_</span> <span class="n">hq</span><span class="o">)))</span>


<span class="kn">lemma</span> <span class="n">contrapositive_not</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">¬</span><span class="o">(</span><span class="bp">¬</span><span class="n">q</span> <span class="bp">→</span> <span class="bp">¬</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span><span class="n">h</span> <span class="n">h&#39;</span><span class="o">,</span>
<span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">q</span><span class="o">)</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">hq</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">nnp2nnq</span> <span class="o">:</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">contrap</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h&#39;</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">p2q</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span>
  <span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">hq</span><span class="o">:</span> <span class="bp">_</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">unnotnot</span> <span class="bp">_</span> <span class="o">(</span><span class="n">nnp2nnq</span> <span class="o">(</span><span class="n">notnot</span> <span class="bp">_</span> <span class="n">hp</span><span class="o">)),</span> <span class="n">hq</span><span class="o">),</span>
  <span class="n">absurd</span> <span class="n">p2q</span> <span class="n">h</span><span class="o">)</span>
<span class="o">(</span><span class="bp">λ</span> <span class="n">hnq</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">hnp</span><span class="o">:</span> <span class="bp">¬</span><span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#39;</span> <span class="n">hnq</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">p2q</span><span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">ncontrap</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h&#39;</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">false&#39;</span> <span class="o">:</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span> <span class="n">p2q</span><span class="o">,</span>
  <span class="n">false&#39;</span><span class="o">)</span>


<span class="kn">example</span> <span class="o">:</span> <span class="bp">¬</span><span class="o">(</span><span class="n">p</span> <span class="bp">→</span> <span class="n">q</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="n">q</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span>
<span class="k">have</span> <span class="n">hnq</span> <span class="o">:</span> <span class="bp">¬</span><span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hq&#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hp</span><span class="o">,</span> <span class="n">hq&#39;</span><span class="o">))),</span>
<span class="n">and</span><span class="bp">.</span><span class="n">intro</span>
<span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">em</span> <span class="n">p</span><span class="o">)</span> <span class="n">id</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnp</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="bp">_</span><span class="o">,</span> <span class="k">from</span> <span class="n">contrapositive_not</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span>
<span class="o">(</span><span class="n">false</span><span class="bp">.</span><span class="n">elim</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hnq&#39;</span><span class="o">,</span> <span class="n">hnp</span><span class="o">)))))</span>
<span class="n">hnq</span>
</pre></div>

<a name="185458907"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185458907" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185458907">Reid Barton (Jan 13 2020 at 01:27)</a>:</h4>
<p>This looks a lot more complicated than necessary. In particular, you shouldn't need to use <code>em</code> again to fill in the underscore.<br>
In the context of the underscore, you know <code>not p</code> and also <code>not (p -&gt; q)</code>. But <code>not p</code> is <code>p -&gt; false</code>, and from <code>false</code> you can prove <code>q</code>, so you get <code>p -&gt; q</code>, which contradicts <code>not (p -&gt; q)</code>.</p>

<a name="185463876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185463876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185463876">Iocta (Jan 13 2020 at 04:17)</a>:</h4>
<p>Thanks.</p>

<a name="185470188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/basics/near/185470188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/17142basics.html#185470188">Kevin Buzzard (Jan 13 2020 at 07:23)</a>:</h4>
<p>Of course you can also prove all of these basic logic statements with one line using tactics, and most if not all of them will already be proved in lean or mathlib already. If you're interested in seeing very short proofs you can read the proofs in the library</p>


{% endraw %}

{% include archive_update.html %}