---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/68895Provingsomethingisasubfield.html
---

## Stream: [new members](https://leanprover-community.github.io/archive/113489newmembers/index.html)
### Topic: [Proving something is a subfield](https://leanprover-community.github.io/archive/113489newmembers/68895Provingsomethingisasubfield.html)

---

<base href="https://leanprover.zulipchat.com">
{% raw %}
#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 22:21)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154872747):
<p>I'm trying to prove that the intersection of two subfields is a subfield -- the problem with using <code>subfield.mk</code>, or just using <code>{...}</code> directly, is that <code>subfield</code> is defined using <code>extends</code>, so I need to prove that it's a subring -- and by extension that it is an additive subgroup and a submonoid. What's the notation for this?</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 22:21)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154872763):
<p>This is what I have:</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 22:21)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154872773):
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">field</span>
<span class="kn">import</span> <span class="n">field_theory</span><span class="bp">.</span><span class="n">subfield</span>
<span class="kn">theorem</span> <span class="n">field_intersect</span> <span class="o">(</span><span class="n">F1</span> <span class="n">F2</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="n">F1</span><span class="o">]</span> <span class="o">[</span><span class="n">h2</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="n">F2</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="o">(</span><span class="n">F1</span> <span class="err">∩</span> <span class="n">F2</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>   <span class="c1">--do I need to put something here?</span>
    <span class="n">inv_mem</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">hx1</span><span class="o">,</span> <span class="n">hx2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hx1</span><span class="o">)</span> <span class="o">(</span><span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hx2</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 22:37)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154874067):
<p>Got it, it's <code>to_is_subring</code>.</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:10)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154876299):
<p>Ok, I suppose one could do without that, too.</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:10)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154876309):
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">field_intersect</span> <span class="o">(</span><span class="n">F1</span> <span class="n">F2</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="n">F1</span><span class="o">]</span> <span class="o">[</span><span class="n">h2</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="n">F2</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="o">(</span><span class="n">F1</span> <span class="err">∩</span> <span class="n">F2</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">zero_mem</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">h1</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="n">h2</span><span class="bp">.</span><span class="n">zero_mem</span><span class="o">,</span>
    <span class="n">one_mem</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">h1</span><span class="bp">.</span><span class="n">one_mem</span> <span class="n">h2</span><span class="bp">.</span><span class="n">one_mem</span><span class="o">,</span>
    <span class="n">add_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">hb1</span><span class="o">,</span> <span class="n">hb2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span>
        <span class="o">(</span><span class="k">by</span> <span class="o">{</span><span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h1</span><span class="bp">.</span><span class="n">add_mem</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">k</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha1</span> <span class="n">hb1</span><span class="o">})</span>
        <span class="o">(</span><span class="k">by</span> <span class="o">{</span><span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h2</span><span class="bp">.</span><span class="n">add_mem</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">k</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha2</span> <span class="n">hb2</span><span class="o">}),</span>
    <span class="n">mul_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">hb1</span><span class="o">,</span> <span class="n">hb2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span>
        <span class="o">(</span><span class="k">by</span> <span class="o">{</span><span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h1</span><span class="bp">.</span><span class="n">mul_mem</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">k</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha1</span> <span class="n">hb1</span><span class="o">})</span>
        <span class="o">(</span><span class="k">by</span> <span class="o">{</span><span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h2</span><span class="bp">.</span><span class="n">mul_mem</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">k</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha2</span> <span class="n">hb2</span><span class="o">}),</span>
    <span class="n">neg_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span>
        <span class="o">(</span><span class="k">by</span> <span class="o">{</span><span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h1</span><span class="bp">.</span><span class="n">neg_mem</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">k</span> <span class="n">a</span> <span class="n">ha1</span><span class="o">})</span>
        <span class="o">(</span><span class="k">by</span> <span class="o">{</span><span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h2</span><span class="bp">.</span><span class="n">neg_mem</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">k</span> <span class="n">a</span> <span class="n">ha2</span><span class="o">}),</span>
    <span class="n">inv_mem</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">hx1</span><span class="o">,</span> <span class="n">hx2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hx1</span><span class="o">)</span> <span class="o">(</span><span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hx2</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:11)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154876361):
<p>I got confused because Lean doesn't point out which fields are to be provided when something extends something.</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:14)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154876596):
<p>On a related note, why doesn't this work?</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">field_intersect</span> <span class="o">(</span><span class="n">F1</span> <span class="n">F2</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="n">F1</span><span class="o">]</span> <span class="o">[</span><span class="n">h2</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="n">F2</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="o">(</span><span class="n">F1</span> <span class="err">∩</span> <span class="n">F2</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">zero_mem</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">h1</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="n">h2</span><span class="bp">.</span><span class="n">zero_mem</span><span class="o">,</span>
    <span class="n">one_mem</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">h1</span><span class="bp">.</span><span class="n">one_mem</span> <span class="n">h2</span><span class="bp">.</span><span class="n">one_mem</span><span class="o">,</span>
    <span class="n">add_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">hb1</span><span class="o">,</span> <span class="n">hb2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="n">h1</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">ha1</span> <span class="n">hb1</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">ha2</span> <span class="n">hb2</span><span class="o">),</span>
    <span class="n">mul_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">hb1</span><span class="o">,</span> <span class="n">hb2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="n">h1</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">ha1</span> <span class="n">hb1</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">ha2</span> <span class="n">hb2</span><span class="o">),</span>
    <span class="n">neg_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="n">h1</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="n">ha1</span><span class="o">)</span> <span class="o">(</span><span class="n">h2</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="n">ha2</span><span class="o">),</span>
    <span class="n">inv_mem</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">hx1</span><span class="o">,</span> <span class="n">hx2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hx1</span><span class="o">)</span> <span class="o">(</span><span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hx2</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>


<p>Or even this:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">field_intersect</span> <span class="o">(</span><span class="n">F1</span> <span class="n">F2</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="n">F1</span><span class="o">]</span> <span class="o">[</span><span class="n">h2</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="n">F2</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="o">(</span><span class="n">F1</span> <span class="err">∩</span> <span class="n">F2</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">zero_mem</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">h1</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="n">h2</span><span class="bp">.</span><span class="n">zero_mem</span><span class="o">,</span>
    <span class="n">one_mem</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">h1</span><span class="bp">.</span><span class="n">one_mem</span> <span class="n">h2</span><span class="bp">.</span><span class="n">one_mem</span><span class="o">,</span>
    <span class="n">add_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">hb1</span><span class="o">,</span> <span class="n">hb2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="bp">@</span><span class="n">h1</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha1</span> <span class="n">hb1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">h2</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha2</span> <span class="n">hb2</span><span class="o">),</span>
    <span class="n">mul_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">hb1</span><span class="o">,</span> <span class="n">hb2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="bp">@</span><span class="n">h1</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">ha1</span> <span class="n">hb1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">h2</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha2</span> <span class="n">hb2</span><span class="o">),</span>
    <span class="n">neg_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="bp">@</span><span class="n">h1</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="n">a</span> <span class="n">ha1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">h2</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="n">a</span> <span class="n">ha2</span><span class="o">),</span>
    <span class="n">inv_mem</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">hx1</span><span class="o">,</span> <span class="n">hx2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hx1</span><span class="o">)</span> <span class="o">(</span><span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hx2</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>


<p>One has to do a <code>have</code> statement and then construct the statement with the local instance of <code>neg_mem</code>, etc. Why?</p>

#### [ Reid Barton (Jan 10 2019 at 23:15)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154876635):
<p>What exactly did you write the first time? with <code>to_is_subring</code></p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:15)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154876664):
<p>Oh, I just nested them all in:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">field_intersect</span> <span class="o">(</span><span class="n">F1</span> <span class="n">F2</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="n">F1</span><span class="o">]</span> <span class="o">[</span><span class="n">h2</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="n">F2</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="o">(</span><span class="n">F1</span> <span class="err">∩</span> <span class="n">F2</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">to_is_subring</span> <span class="o">:=</span> <span class="o">{</span>
        <span class="n">to_is_add_subgroup</span> <span class="o">:=</span> <span class="o">{</span>
            <span class="n">to_is_add_submonoid</span> <span class="o">:=</span> <span class="o">{</span>
                <span class="n">zero_mem</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">h1</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="n">h2</span><span class="bp">.</span><span class="n">zero_mem</span><span class="o">,</span>
                <span class="n">add_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">hb1</span><span class="o">,</span> <span class="n">hb2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span>
                    <span class="o">(</span><span class="k">by</span> <span class="o">{</span><span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h1</span><span class="bp">.</span><span class="n">add_mem</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">k</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha1</span> <span class="n">hb1</span><span class="o">})</span>
                    <span class="o">(</span><span class="k">by</span> <span class="o">{</span><span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h2</span><span class="bp">.</span><span class="n">add_mem</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">k</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha2</span> <span class="n">hb2</span><span class="o">}),</span>
            <span class="o">},</span>
            <span class="n">neg_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span>
                <span class="o">(</span><span class="k">by</span> <span class="o">{</span><span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h1</span><span class="bp">.</span><span class="n">neg_mem</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">k</span> <span class="n">a</span> <span class="n">ha1</span><span class="o">})</span>
                <span class="o">(</span><span class="k">by</span> <span class="o">{</span><span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h2</span><span class="bp">.</span><span class="n">neg_mem</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">k</span> <span class="n">a</span> <span class="n">ha2</span><span class="o">}),</span>
            <span class="o">},</span>
        <span class="n">to_is_submonoid</span> <span class="o">:=</span> <span class="o">{</span>
            <span class="n">one_mem</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">h1</span><span class="bp">.</span><span class="n">one_mem</span> <span class="n">h2</span><span class="bp">.</span><span class="n">one_mem</span><span class="o">,</span>
            <span class="n">mul_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">hb1</span><span class="o">,</span> <span class="n">hb2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span>
                <span class="o">(</span><span class="k">by</span> <span class="o">{</span><span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h1</span><span class="bp">.</span><span class="n">mul_mem</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">k</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha1</span> <span class="n">hb1</span><span class="o">})</span>
                <span class="o">(</span><span class="k">by</span> <span class="o">{</span><span class="k">have</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">h2</span><span class="bp">.</span><span class="n">mul_mem</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">@</span><span class="n">k</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha2</span> <span class="n">hb2</span><span class="o">}),</span>
        <span class="o">},</span>
    <span class="o">},</span>
    <span class="n">inv_mem</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">hx1</span><span class="o">,</span> <span class="n">hx2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hx1</span><span class="o">)</span> <span class="o">(</span><span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hx2</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>

#### [ Mario Carneiro (Jan 10 2019 at 23:22)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877108):
<p><code>@h1.neg_mem</code> doesn't work because you can't mix field notation and <code>@</code> notation</p>

#### [ Mario Carneiro (Jan 10 2019 at 23:22)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877121):
<p>you have to write <code>@neg_mem h1</code></p>

#### [ Mario Carneiro (Jan 10 2019 at 23:24)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877252):
<p>also you shouldn't project out of a typeclass argument, because it's implicit</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:24)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877259):
<p>Re:(@,.) -- I thought so, but I tried that and it doesn't work either -- it just doesn't find <code>is_subfield.neg_mem</code></p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:25)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877297):
<blockquote>
<p>also you shouldn't project out of a typeclass argument, because it's implicit</p>
</blockquote>
<p>What do you mean?</p>

#### [ Mario Carneiro (Jan 10 2019 at 23:25)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877317):
<p>what do you get when you try it?</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:26)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877398):
<p><code>unknown identifier 'is_subfield.add_mem'</code></p>

#### [ Mario Carneiro (Jan 10 2019 at 23:26)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877407):
<p>that means it's not called that</p>

#### [ Mario Carneiro (Jan 10 2019 at 23:27)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877424):
<p>what is the def of <code>is_subfield</code>?</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:27)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877432):
<p>I tried with <code>is_add_submonoid</code> too.</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:27)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877442):
<div class="codehilite"><pre><span></span><span class="n">type</span> <span class="n">mismatch</span> <span class="n">at</span> <span class="n">application</span>
  <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">add_mem</span>
<span class="n">term</span>
  <span class="n">h1</span>
<span class="n">has</span> <span class="n">type</span>
  <span class="n">is_subfield</span> <span class="n">F1</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="n">but</span> <span class="n">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="k">have</span> <span class="n">type</span>
  <span class="kt">Type</span> <span class="err">?</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="err">?</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
</pre></div>

#### [ Mario Carneiro (Jan 10 2019 at 23:27)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877453):
<p>you don't pass in <code>h1</code> at all</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:28)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877513):
<p>I did.</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:28)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877517):
<p>This is what I'm trying:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">field_intersect</span> <span class="o">(</span><span class="n">F1</span> <span class="n">F2</span> <span class="o">:</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">h1</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="n">F1</span><span class="o">]</span> <span class="o">[</span><span class="n">h2</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="n">F2</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="o">(</span><span class="n">F1</span> <span class="err">∩</span> <span class="n">F2</span><span class="o">)</span> <span class="o">:=</span> <span class="o">{</span>
    <span class="n">zero_mem</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">h1</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="n">h2</span><span class="bp">.</span><span class="n">zero_mem</span><span class="o">,</span>
    <span class="n">one_mem</span> <span class="o">:=</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">h1</span><span class="bp">.</span><span class="n">one_mem</span> <span class="n">h2</span><span class="bp">.</span><span class="n">one_mem</span><span class="o">,</span>
    <span class="n">add_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">hb1</span><span class="o">,</span> <span class="n">hb2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">((</span><span class="bp">@</span><span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">h1</span><span class="o">)</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha1</span> <span class="n">hb1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">h2</span><span class="bp">.</span><span class="n">add_mem</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha2</span> <span class="n">hb2</span><span class="o">),</span>
    <span class="n">mul_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">hb1</span><span class="o">,</span> <span class="n">hb2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="bp">@</span><span class="n">h1</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">ha1</span> <span class="n">hb1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">h2</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha2</span> <span class="n">hb2</span><span class="o">),</span>
    <span class="n">neg_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="bp">⟨</span><span class="n">ha1</span><span class="o">,</span> <span class="n">ha2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="bp">@</span><span class="n">h1</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="n">a</span> <span class="n">ha1</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">h2</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="n">a</span> <span class="n">ha2</span><span class="o">),</span>
    <span class="n">inv_mem</span> <span class="o">:=</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span> <span class="bp">⟨</span><span class="n">hx1</span><span class="o">,</span> <span class="n">hx2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">(</span><span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hx1</span><span class="o">)</span> <span class="o">(</span><span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="n">hx2</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>

#### [ Mario Carneiro (Jan 10 2019 at 23:28)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877518):
<p>i know, stop</p>

#### [ Mario Carneiro (Jan 10 2019 at 23:28)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877523):
<p>just call it without passing in <code>h1</code></p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:29)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877543):
<p>Ah.</p>

#### [ Mario Carneiro (Jan 10 2019 at 23:29)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877546):
<p>like <code>is_add_submonoid.add_mem ha1 hb1</code></p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:30)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877642):
<p>I see, yes this works.</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:30)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877652):
<p>But why? What's wrong with trying to feed Lean the class?</p>

#### [ Mario Carneiro (Jan 10 2019 at 23:31)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877684):
<p>the class is implicit, you aren't supposed to give it, lean finds it by typeclass inference</p>

#### [ Mario Carneiro (Jan 10 2019 at 23:31)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877696):
<p>you can give it if you use <code>@</code></p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:32)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877758):
<p>Yes, why wasn't that working?</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:32)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877771):
<p>Using <code>@</code> and feeding the class?</p>

#### [ Mario Carneiro (Jan 10 2019 at 23:32)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877782):
<p>that should work, you just need a few more arguments that way, like the types</p>

#### [ Mario Carneiro (Jan 10 2019 at 23:33)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877802):
<p>I guess it looks something like <code>@is_add_submonoid.add_mem F1 h1 a b ha1 hb1</code></p>

#### [ Mario Carneiro (Jan 10 2019 at 23:34)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877891):
<p>oh wait, no it should be something more complicated than just <code>h1</code> there</p>

#### [ Mario Carneiro (Jan 10 2019 at 23:35)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154877921):
<p>because <code>h1</code> is a <code>is_subfield</code> and it needs a <code>is_add_monoid</code>, it does some typeclass inference to fill the gap</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 10 2019 at 23:36)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/154878002):
<p>Oh ok. I think I see why it's best to leave things to Lean's class inference.</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 16 2019 at 20:28)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/155280441):
<p>I'm proving a similar theorem and having the same problem again, except this time just leaving Lean to do its type class inference doesn't work (only <code>zero_mem</code> and <code>one_mem</code> work):</p>
<div class="codehilite"><pre><span></span><span class="kn">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">L</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">→</span> <span class="n">L</span><span class="o">)</span>
<span class="kn">theorem</span> <span class="n">field_intersect&#39;</span> <span class="o">(</span><span class="n">PL</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">L</span><span class="o">))</span> <span class="o">[</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">J</span> <span class="err">∈</span> <span class="n">PL</span><span class="o">,</span> <span class="n">is_subfield</span> <span class="n">J</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">sInter</span> <span class="n">PL</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>   <span class="n">zero_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="o">(</span><span class="n">H</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="o">},</span>
    <span class="n">one_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="o">(</span><span class="n">H</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span><span class="bp">.</span><span class="n">one_mem</span> <span class="o">},</span>
    <span class="n">add_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">add_mem</span> <span class="o">(</span><span class="n">ha</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">mul_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="n">is_submonoid</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="o">(</span><span class="n">ha</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">neg_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="n">is_add_subgroup</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="o">(</span><span class="n">h</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">inv_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="o">(</span><span class="n">h</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
</pre></div>


<p>It worked with <code>set.Inter</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">field_intersect</span> <span class="o">(</span><span class="n">Fi</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="n">set</span> <span class="n">K</span><span class="o">)</span> <span class="o">[</span><span class="n">hi</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">is_subfield</span> <span class="o">(</span><span class="n">Fi</span> <span class="n">i</span><span class="o">)]</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">Inter</span> <span class="n">Fi</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>   <span class="n">zero_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">hi</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="o">},</span>
    <span class="n">one_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">hi</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">one_mem</span> <span class="o">},</span>
    <span class="n">add_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span> <span class="n">i</span><span class="o">,</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">add_mem</span> <span class="o">(</span><span class="n">ha</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">mul_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span> <span class="n">i</span><span class="o">,</span> <span class="n">is_submonoid</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="o">(</span><span class="n">ha</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">neg_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span> <span class="n">i</span><span class="o">,</span> <span class="n">is_add_subgroup</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="o">(</span><span class="n">h</span> <span class="n">i</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">inv_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span> <span class="n">i</span><span class="o">,</span> <span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="o">(</span><span class="n">h</span> <span class="n">i</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
</pre></div>

#### [ Kevin Buzzard (Jan 16 2019 at 20:46)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/155281908):
<p>Can you post working code so I can cut and paste?</p>

#### [ Kevin Buzzard (Jan 16 2019 at 20:46)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/155281909):
<p>PS this "simp, ..." style is discouraged. There are always ways around it.</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 16 2019 at 20:53)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/155282381):
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">field</span>
<span class="kn">import</span> <span class="n">field_theory</span><span class="bp">.</span><span class="n">subfield</span>
<span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">polynomial</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">L</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">→</span> <span class="n">L</span><span class="o">)</span>
<span class="kn">theorem</span> <span class="n">field_intersect&#39;</span> <span class="o">(</span><span class="n">PL</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">L</span><span class="o">))</span> <span class="o">[</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">J</span> <span class="err">∈</span> <span class="n">PL</span><span class="o">,</span> <span class="n">is_subfield</span> <span class="n">J</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">sInter</span> <span class="n">PL</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>   <span class="n">zero_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="o">(</span><span class="n">H</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span><span class="bp">.</span><span class="n">zero_mem</span> <span class="o">},</span>
    <span class="n">one_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="o">(</span><span class="n">H</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span><span class="bp">.</span><span class="n">one_mem</span> <span class="o">},</span>
    <span class="n">add_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="n">is_add_submonoid</span><span class="bp">.</span><span class="n">add_mem</span> <span class="o">(</span><span class="n">ha</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">mul_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="n">is_submonoid</span><span class="bp">.</span><span class="n">mul_mem</span> <span class="o">(</span><span class="n">ha</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">neg_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="n">is_add_subgroup</span><span class="bp">.</span><span class="n">neg_mem</span> <span class="o">(</span><span class="n">h</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">inv_mem</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span><span class="o">,</span> <span class="n">exact</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">h</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="n">is_subfield</span><span class="bp">.</span><span class="n">inv_mem</span> <span class="o">(</span><span class="n">h</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
</pre></div>

#### [ Abhimanyu Pallavi Sudhir (Jan 16 2019 at 20:53)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/155282401):
<p>Doesn't that work (for copy-pasting, I mean)?</p>

#### [ Kevin Buzzard (Jan 16 2019 at 21:04)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/155283329):
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">field_theory</span><span class="bp">.</span><span class="n">subfield</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">K</span> <span class="n">L</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">K</span><span class="o">]</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">L</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">K</span> <span class="bp">→</span> <span class="n">L</span><span class="o">)</span>
<span class="kn">theorem</span> <span class="n">field_intersect&#39;</span> <span class="o">(</span><span class="n">PL</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">L</span><span class="o">))</span> <span class="o">[</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">J</span> <span class="err">∈</span> <span class="n">PL</span><span class="o">,</span> <span class="n">is_subfield</span> <span class="n">J</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_subfield</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">sInter</span> <span class="n">PL</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span>   <span class="n">zero_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="o">(</span><span class="n">H</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span><span class="bp">.</span><span class="n">zero_mem</span><span class="o">,</span>
    <span class="n">one_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="o">(</span><span class="n">H</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span><span class="bp">.</span><span class="n">one_mem</span><span class="o">,</span>
    <span class="n">add_mem</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">ha</span> <span class="n">hb</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">,</span> <span class="k">let</span> <span class="n">X</span> <span class="o">:=</span> <span class="o">(</span><span class="n">H</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span><span class="bp">.</span><span class="n">add_mem</span> <span class="k">in</span> <span class="n">X</span> <span class="o">(</span><span class="n">ha</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="n">J</span> <span class="n">HJ</span><span class="o">),</span>
    <span class="n">mul_mem</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="n">neg_mem</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="n">inv_mem</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
<span class="o">}</span>
</pre></div>


<p>You don't need <code>simp</code> for stuff like this, you can just spell it out. Although I struggled with <code>add_mem</code> and I don't know why, it's something to do with classes that I don't understand properly.</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 16 2019 at 21:07)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/155283540):
<p>Yeah, the <code>simp</code> was a legacy from my code for <code>field_intersect</code> with indexed subsets.</p>

#### [ Abhimanyu Pallavi Sudhir (Jan 16 2019 at 21:07)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/155283598):
<p>Interesting that the <code>let ... in</code> thing works, though -- I did notice that going <code>have</code> the <code>add_mem</code> statement (without feeding it any parameters) in tactic mode worked.</p>

#### [ Patrick Massot (Jan 16 2019 at 21:30)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/155285644):
<p>This is pretty weird. A more understandable solution would be <code>λ a b ha hb J HJ, by haveI := H J HJ ; exact is_add_submonoid.add_mem (ha J HJ) (hb J HJ),</code></p>

#### [ Patrick Massot (Jan 16 2019 at 21:33)](https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Proving%20something%20is%20a%20subfield/near/155285877):
<p>Of course you can also use the ugly direct term <code>@is_add_submonoid.add_mem _ _ _ (H J HJ).to_is_add_submonoid _ _ (ha J HJ) (hb J HJ)</code></p>


{% endraw %}
