---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/113489newmembers/35829attemptatsomegeometry.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html">attempt at some geometry</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="185127850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185127850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185127850">Matt Earnshaw (Jan 08 2020 at 16:08)</a>:</h4>
<p>as an exercise I wanted to try proving some theorems from Artin's <em>Geometric Algebra</em>, but I quickly hit a wall -- maybe due to being weak on the basics, maybe due to infelicitous transcription of the axioms. here is what I have so far, but as you can see I did not make much progress on the first lemma, just unsure how to proceed! apologies for the very vague 'question' but any tips or pointers would be appreciated.</p>
<div class="codehilite"><pre><span></span>-- constants of types subsume the usual statement of a theory&#39;s signature and axioms
constants Pt Ln : Sort
constant belongs : Pt → Ln → Prop
constant parallel : Ln → Ln → Prop

-- Artin def 2.1: can and ought we to formulate this as a term of type parallel l₁ l₂? this should be a definition not an axiom - is &#39;constant&#39; appropriate?
constant eq_or_no_common_pt_implies_parallel (l₁ l₂ : Ln) : (l₁ = l₂ ∨ ¬∃ p : Pt, belongs p l₁ ∧ belongs p l₂) → parallel l₁ l₂

-- Artin axiom 1: distinct points determine unique line
constant unique_ln_bw_two_pts (p₁ p₂ : Pt) : (p₁ ≠ p₂) → ∃ p₁p₂ : Ln, belongs p₁ p₁p₂ ∧ belongs p₂ p₁p₂ ∧ (∀ l : Ln, belongs p₁ l ∧ belongs p₂ l → p₁p₂ = l)
-- Artin axiom 2: exists unique parallel
constant exists_parallel (p : Pt) (l : Ln) : (∃ l₁ : Ln, parallel l l₁ ∧ belongs p l₁)
constant unique_parallel (p : Pt) (l l₁ l₂ : Ln) : (parallel l l₁ ∧ parallel l l₂ ∧ belongs p l₁ ∧ belongs p l₁) → l₁ = l₂

lemma line_parallel_to_itself (l : Ln) : reflexive parallel :=
begin
  have h₁ := eq_or_no_common_pt_implies_parallel l l,
  have h₂ := eq.refl l,
  sorry
end

theorem parallel_is_equivalence : equivalence parallel :=
begin
  -- split,
  -- exact line_parallel_to_itself,
end
</pre></div>

<a name="185128089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185128089">Kevin Buzzard (Jan 08 2020 at 16:10)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">line_parallel_to_itself</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:</span> <span class="n">reflexive</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">eq_or_no_common_pt_implies_parallel</span><span class="o">,</span>
  <span class="n">left</span><span class="o">,</span>
  <span class="n">refl</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="185128158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185128158">Johan Commelin (Jan 08 2020 at 16:11)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt Earnshaw</span> In general people tend to avoid <code>constant</code> completely, except for little demo purposes.</p>

<a name="185128171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185128171">Kevin Buzzard (Jan 08 2020 at 16:11)</a>:</h4>
<p>[note that I have proved it like a computer scientist -- I wrote the proof backwards]</p>

<a name="185128333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185128333">Johan Commelin (Jan 08 2020 at 16:12)</a>:</h4>
<p>But for testing things out, it's fine. And in that cases your "axioms" should also be encoded as <code>constant</code>s</p>

<a name="185128416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185128416">Johan Commelin (Jan 08 2020 at 16:14)</a>:</h4>
<p>A different option would be to turn all your <code>constant</code>s into <code>variable</code>s, and maybe make some of them <em>implicit</em> (using <code>{}</code>)</p>

<a name="185128520"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128520" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185128520">Johan Commelin (Jan 08 2020 at 16:14)</a>:</h4>
<p>In the end, if you move away from <code>constant</code>, your best bet would be to bundle all your data and axioms into a <code>structure</code></p>

<a name="185128684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185128684">Johan Commelin (Jan 08 2020 at 16:16)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt Earnshaw</span> You have a typo in the <code>unique_parallel</code> axiom. You ask that <code>l1</code> is parallel to <code>l</code> twice.</p>

<a name="185128712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185128712">Johan Commelin (Jan 08 2020 at 16:16)</a>:</h4>
<p>Also, can't you just ask that <code>l1</code> is parallel to <code>l2</code>, and leave <code>l</code> completely out of the picture?</p>

<a name="185128876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185128876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185128876">Johan Commelin (Jan 08 2020 at 16:18)</a>:</h4>
<p>Another remark: usually it's better to not use <code>\and</code> in assumptions, but to just state the clauses as separate assumptions. That makes it easier to use the lemma/axiom</p>

<a name="185135377"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185135377" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185135377">Matt Earnshaw (Jan 08 2020 at 17:22)</a>:</h4>
<p>thanks both, this is very helpful already. now I am trying to make headway on the symmetry part of the equivalence relation proof.  It seem necessary to introduce the converse <code>constant parallel_implies_eq_or_no_common_pt (l₁ l₂ : Ln) : parallel l₁ l₂ → (l₁ = l₂ ∨ ¬∃ p : Pt, belongs p l₁ ∧ belongs p l₂)</code> (which finally <em>defines</em> parallel). then</p>
<div class="codehilite"><pre><span></span>lemma symmetric_parallel : symmetric parallel :=
begin
  intros l₁ l₂ h,
  have x := (parallel_implies_eq_or_no_common_pt l₁ l₂) h,
  cases x,
  rw x,
  apply line_parallel_to_itself,
end
</pre></div>


<p>with context</p>
<div class="codehilite"><pre><span></span>l₁ l₂ : Ln,
h : parallel l₁ l₂,
x : ¬∃ (p : Pt), belongs p l₁ ∧ belongs p l₂
⊢ parallel l₂ l₁
</pre></div>


<p>now what I <em>want</em> to do is use <code>and.symm</code> to swap the terms in <code>x</code>, but am stuck there.</p>

<a name="185143048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185143048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185143048">Bryan Gin-ge Chen (Jan 08 2020 at 18:41)</a>:</h4>
<p>I'm sure this can be golfed (note that I imported <code>logic.basic</code> (for <code>not_exists</code>) and <code>tactic.basic</code> (for <code>rintro</code>) from mathlib):</p>
<div class="codehilite"><pre><span></span><span class="kn">constant</span> <span class="n">parallel_implies_eq_or_no_common_pt</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="bp">→</span> <span class="o">(</span><span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span> <span class="bp">∨</span> <span class="bp">¬∃</span> <span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">symmetric_parallel</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">(</span><span class="n">parallel_implies_eq_or_no_common_pt</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">x</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">line_parallel_to_itself</span> <span class="n">l₂</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">eq_or_no_common_pt_implies_parallel</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span><span class="o">,</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">not_exists</span><span class="o">]</span> <span class="n">at</span> <span class="n">x</span> <span class="err">⊢</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">x&#39;</span> <span class="bp">⟨</span><span class="n">h₁</span><span class="o">,</span><span class="n">h₂</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">x</span> <span class="n">x&#39;</span> <span class="bp">⟨</span><span class="n">h₂</span><span class="o">,</span><span class="n">h₁</span><span class="bp">⟩</span><span class="o">,</span>  <span class="o">},</span>
<span class="kn">end</span>
</pre></div>

<a name="185145475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185145475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185145475">Johan Commelin (Jan 08 2020 at 19:04)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt Earnshaw</span> Shouldn't <code>parallel</code> actually be a definition, as in:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">parallel</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬∃</span> <span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">)</span>
</pre></div>

<a name="185147046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185147046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185147046">Matt Earnshaw (Jan 08 2020 at 19:19)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> thanks that's helpful. think I have the transitivity proof down now</p>

<a name="185147126"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185147126" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185147126">Matt Earnshaw (Jan 08 2020 at 19:20)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> yes, it should be, thanks. makes things neater</p>

<a name="185148312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185148312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185148312">Johan Commelin (Jan 08 2020 at 19:32)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt Earnshaw</span> This is what I have atm:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="c1">-- constants of types subsume the usual statement of a theory&#39;s signature and axioms</span>
<span class="kn">constants</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="o">:</span> <span class="n">Sort</span>
<span class="kn">constant</span> <span class="n">belongs</span> <span class="o">:</span> <span class="n">Pt</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="n">def</span> <span class="n">parallel</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬∃</span> <span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">)</span>

<span class="c1">-- Artin axiom 1: distinct points determine unique line</span>
<span class="kn">constant</span> <span class="n">unique_ln_bw_two_pts</span> <span class="o">(</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">p₁p₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p₁</span> <span class="n">p₁p₂</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p₂</span> <span class="n">p₁p₂</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">l</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p₁</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p₂</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">p₁p₂</span> <span class="bp">=</span> <span class="n">l</span><span class="o">)</span>
<span class="c1">-- Artin axiom 2: exists unique parallel</span>
<span class="kn">constant</span> <span class="n">exists_parallel</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">l₁</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">parallel</span> <span class="n">l</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span>
<span class="kn">constant</span> <span class="n">unique_parallel</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₁</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₂</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span>

<span class="kn">lemma</span> <span class="n">parallel_refl</span> <span class="o">:</span> <span class="n">reflexive</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">left</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">parallel_symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintros</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">h</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">parallel_refl</span> <span class="bp">_</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span>
    <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">exists_imp_exists</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">and</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">parallel_trans</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintros</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">h₁₂</span><span class="o">)</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">h₂₃</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">parallel_refl</span> <span class="bp">_</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">parallel_is_equivalence</span> <span class="o">:</span> <span class="n">equivalence</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">parallel_refl</span><span class="o">,</span> <span class="n">parallel_symm</span><span class="o">,</span> <span class="n">parallel_trans</span><span class="bp">⟩</span>
</pre></div>

<a name="185148373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185148373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185148373">Johan Commelin (Jan 08 2020 at 19:33)</a>:</h4>
<p>I'm using some tactics that aren't in core. But I think the help cutting through boilerplate.</p>

<a name="185148787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185148787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185148787">Matt Earnshaw (Jan 08 2020 at 19:37)</a>:</h4>
<p>that gives me <code>contrapose only applies to nondependent arrows between decidable props</code>, though I am satisfied with the following (but still good to see alternatives)</p>
<div class="codehilite"><pre><span></span>lemma parallel_symmetric : symmetric parallel :=
begin
  intros l₁ l₂ h,
  cases h,
  { rw h,
    left,
    refl },
  { right,
    exact h },
end
</pre></div>

<a name="185149058"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185149058" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185149058">Johan Commelin (Jan 08 2020 at 19:40)</a>:</h4>
<p>Look at the other lines I added to the top</p>

<a name="185149078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185149078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185149078">Johan Commelin (Jan 08 2020 at 19:41)</a>:</h4>
<p><code>noncomputable theory</code> and <code>open_locale classical</code></p>

<a name="185149205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185149205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185149205">Johan Commelin (Jan 08 2020 at 19:42)</a>:</h4>
<p>How can <code>right, exact h</code> close that goal? You need to apply symmetry somewhere.</p>

<a name="185149309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185149309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185149309">Matt Earnshaw (Jan 08 2020 at 19:43)</a>:</h4>
<p>ah I see</p>

<a name="185149437"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185149437" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185149437">Matt Earnshaw (Jan 08 2020 at 19:45)</a>:</h4>
<p>hm, I suppose it's only working due to tactic magic - in which case I prefer yours</p>

<a name="185149727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185149727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185149727">Johan Commelin (Jan 08 2020 at 19:48)</a>:</h4>
<p>But you are only using basic tactics, so there shouldn't be any magic at all.</p>

<a name="185149770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185149770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185149770">Johan Commelin (Jan 08 2020 at 19:48)</a>:</h4>
<p>But I agree that lean seems to be happy with it</p>

<a name="185150120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185150120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185150120">Johan Commelin (Jan 08 2020 at 19:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∧</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="n">Q</span> <span class="bp">∧</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">h</span>
</pre></div>


<p>doesn't work. So I really don't get why your version does work. Maybe something with the existential, but it's still weird</p>

<a name="185150966"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185150966" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185150966">Johan Commelin (Jan 08 2020 at 20:01)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">parallel_trans</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintros</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">h₁₂</span><span class="o">)</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">h₂₃</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">parallel_refl</span> <span class="bp">_</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">by_cases</span> <span class="n">h₁₃</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₃</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">subst</span> <span class="n">h₁₃</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">parallel_refl</span> <span class="bp">_</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">right</span><span class="o">,</span>
      <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h₁₃</span><span class="o">,</span>
      <span class="n">rcases</span> <span class="n">h₁₃</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp₁</span><span class="o">,</span> <span class="n">hp₂</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">apply</span> <span class="n">unique_parallel</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">,</span>
      <span class="n">all_goals</span>
      <span class="o">{</span> <span class="n">try</span> <span class="o">{</span><span class="n">right</span><span class="o">},</span> <span class="n">assumption</span> <span class="o">}</span> <span class="o">}</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>The last line of the proof abuses the weird behaviour that I don't understand</p>

<a name="185152739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185152739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185152739">Johan Commelin (Jan 08 2020 at 20:21)</a>:</h4>
<blockquote>
<p>that gives me <code>contrapose only applies to nondependent arrows between decidable props</code>, though I am satisfied with the following (but still good to see alternatives)</p>
</blockquote>
<p>lemma parallel_symmetric : symmetric parallel :=<br>
begin<br>
  intros l₁ l₂ h,<br>
  cases h,<br>
  { rw h,<br>
    left,<br>
    refl },<br>
  { right,<br>
    exact h },<br>
end</p>
<div class="codehilite"><pre><span></span>
</pre></div>


<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Do you understand what's going on?</p>

<a name="185153554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185153554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185153554">Mario Carneiro (Jan 08 2020 at 20:31)</a>:</h4>
<p>oh wow, that was a real wtf</p>

<a name="185153582"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185153582" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185153582">Mario Carneiro (Jan 08 2020 at 20:31)</a>:</h4>
<p>the problem is</p>
<div class="codehilite"><pre><span></span><span class="kn">constants</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="o">:</span> <span class="n">Sort</span>
</pre></div>

<a name="185153595"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185153595" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185153595">Mario Carneiro (Jan 08 2020 at 20:31)</a>:</h4>
<p><code>Sort = Prop</code></p>

<a name="185153674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185153674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185153674">Mario Carneiro (Jan 08 2020 at 20:32)</a>:</h4>
<p>therefore <code>l₁</code> and <code>l₂</code> are two proofs of the proposition <code>Ln</code> and are hence equal by proof irrelevance</p>

<a name="185153876"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185153876" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185153876">Bryan Gin-ge Chen (Jan 08 2020 at 20:34)</a>:</h4>
<p>Wow, indeed <code>#check Pt</code> gives <code>Pt : Prop</code>.</p>

<a name="185154571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185154571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185154571">Johan Commelin (Jan 08 2020 at 20:42)</a>:</h4>
<p>Aha, that's sneaky</p>

<a name="185154767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185154767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185154767">Johan Commelin (Jan 08 2020 at 20:45)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt Earnshaw</span> The solution is to change <code>Sort</code> into <code>Type</code></p>

<a name="185155905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185155905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185155905">Kevin Buzzard (Jan 08 2020 at 20:57)</a>:</h4>
<p>Or presumably a change to <code>Sort u</code> would also solve this.</p>

<a name="185156128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185156128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185156128">Mario Carneiro (Jan 08 2020 at 20:59)</a>:</h4>
<p>I would suggest <code>Type u</code> instead</p>

<a name="185156448"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185156448" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185156448">Johan Commelin (Jan 08 2020 at 21:03)</a>:</h4>
<blockquote>
<p>Or presumably a change to <code>Sort u</code> would also solve this.</p>
</blockquote>
<p>That would still allow <code>Prop</code> if <code>u = 0</code></p>

<a name="185156629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185156629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185156629">Kevin Buzzard (Jan 08 2020 at 21:05)</a>:</h4>
<p>Yes, but presumably the invalid proof still stops working...</p>

<a name="185157299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185157299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185157299">Mario Carneiro (Jan 08 2020 at 21:11)</a>:</h4>
<p>It will, but if you try to do any constructions they won't be able to live in the same universe <code>Sort u</code> in all likelihood, they will have to live in <code>Sort (max 1 u)</code> or similar and that will be inconvenient. (This is why most type constructors like <code>list</code> work on <code>Type u</code> instead of <code>Sort u</code>.)</p>

<a name="185160627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185160627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185160627">Matt Earnshaw (Jan 08 2020 at 21:48)</a>:</h4>
<p>aha</p>

<a name="185182091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185182091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185182091">Bryan Gin-ge Chen (Jan 09 2020 at 04:10)</a>:</h4>
<p>Aside from the typo that Johan already pointed out, there's actually another issue with the type of <code>unique_parallel</code>: </p>
<div class="codehilite"><pre><span></span><span class="kn">constant</span> <span class="n">unique_parallel</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">l₁</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₁</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₂</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span>
</pre></div>


<p>This says that given a point <code>p</code>, two parallel lines <code>l₁</code> and <code>l₂</code> passing through <code>p</code> must be equal to each other. However, Artin phrased axiom 2 this way: "Given a point <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> and a line <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>, there exists one and only one line <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> lies on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> and such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∥</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">m\parallel l</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>." In particular, note that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> does not have to belong to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>. Here's a minimal fix:</p>
<div class="codehilite"><pre><span></span><span class="kn">constant</span> <span class="n">unique_parallel</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">l</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">l</span> <span class="n">l₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hp₁</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₂</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span>
</pre></div>


<p>Here's Johan's snippet updated with the <code>Type*</code> fix and the fix above, as well as a proof of <code>parallel_trans</code>. I also made a few parameters implicit with curly braces:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="c1">-- constants of types subsume the usual statement of a theory&#39;s signature and axioms</span>
<span class="kn">constants</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span>
<span class="kn">constant</span> <span class="n">belongs</span> <span class="o">:</span> <span class="n">Pt</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span>

<span class="n">def</span> <span class="n">parallel</span> <span class="o">(</span><span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span> <span class="bp">∨</span> <span class="o">(</span><span class="bp">¬∃</span> <span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">)</span>

<span class="c1">-- Artin axiom 1: distinct points determine unique line</span>
<span class="kn">constant</span> <span class="n">unique_ln_bw_two_pts</span> <span class="o">{</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span><span class="o">)</span> <span class="bp">→</span> <span class="bp">∃</span> <span class="n">p₁p₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p₁</span> <span class="n">p₁p₂</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p₂</span> <span class="n">p₁p₂</span> <span class="bp">∧</span> <span class="o">(</span><span class="bp">∀</span> <span class="n">l</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p₁</span> <span class="n">l</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p₂</span> <span class="n">l</span> <span class="bp">→</span> <span class="n">p₁p₂</span> <span class="bp">=</span> <span class="n">l</span><span class="o">)</span>
<span class="c1">-- Artin axiom 2: exists unique parallel</span>
<span class="kn">constant</span> <span class="n">exists_parallel</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="bp">∃</span> <span class="n">l₁</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">parallel</span> <span class="n">l</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span>
<span class="kn">constant</span> <span class="n">unique_parallel</span> <span class="o">{</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">}</span> <span class="o">{</span><span class="n">l</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">l</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">parallel</span> <span class="n">l</span> <span class="n">l₂</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hp₁</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span> <span class="o">(</span><span class="n">hp₂</span> <span class="o">:</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span>

<span class="kn">lemma</span> <span class="n">parallel_refl</span> <span class="o">:</span> <span class="n">reflexive</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">left</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">parallel_symm</span> <span class="o">:</span> <span class="n">symmetric</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintros</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">(</span><span class="n">rfl</span><span class="bp">|</span><span class="n">h</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">parallel_refl</span> <span class="bp">_</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span>
    <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">apply</span> <span class="n">exists_imp_exists</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">and</span><span class="bp">.</span><span class="n">symm</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">lemma</span> <span class="n">parallel_trans</span> <span class="o">:</span> <span class="n">transitive</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intros</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="n">l₃</span> <span class="n">h₁₂</span> <span class="n">h₂₃</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">H</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">p</span><span class="o">,</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₃</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">H</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₃</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₃</span> <span class="o">:=</span> <span class="n">unique_parallel</span> <span class="o">(</span><span class="n">parallel_symm</span> <span class="n">h₁₂</span><span class="o">)</span> <span class="n">h₂₃</span> <span class="n">h₁</span> <span class="n">h₃</span><span class="o">,</span>
    <span class="n">subst</span> <span class="n">this</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">parallel_refl</span> <span class="n">l₁</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">H</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>

<span class="kn">theorem</span> <span class="n">parallel_is_equivalence</span> <span class="o">:</span> <span class="n">equivalence</span> <span class="n">parallel</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">parallel_refl</span><span class="o">,</span> <span class="n">parallel_symm</span><span class="o">,</span> <span class="n">parallel_trans</span><span class="bp">⟩</span>
</pre></div>

<a name="185182238"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185182238" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185182238">Kenny Lau (Jan 09 2020 at 04:15)</a>:</h4>
<p>also I think all of these should be structure / class instead of constants</p>

<a name="185182310"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185182310" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185182310">Bryan Gin-ge Chen (Jan 09 2020 at 04:17)</a>:</h4>
<p>How would you set it up?</p>

<a name="185188035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185188035">Kenny Lau (Jan 09 2020 at 06:59)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="n">class</span> <span class="n">has_parallel</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">parallel</span> <span class="o">:</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∥</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">has_parallel</span><span class="bp">.</span><span class="n">parallel</span>

<span class="n">class</span> <span class="n">pre_geometry</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">has_mem</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="bp">.</span>

<span class="kn">instance</span> <span class="n">pre_geometry</span><span class="bp">.</span><span class="n">has_parallel</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_parallel</span> <span class="n">Ln</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">L₁</span> <span class="n">L₂</span><span class="o">,</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₂</span> <span class="bp">∨</span> <span class="bp">¬∃</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₂</span><span class="bp">⟩</span>

<span class="n">class</span> <span class="n">geometry</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_unique_ln_bw_two_pts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">},</span> <span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p₁</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">p₂</span> <span class="err">∈</span> <span class="n">L</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_unique_parallel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="bp">∃!</span> <span class="n">L&#39;</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L&#39;</span> <span class="bp">∧</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L&#39;</span><span class="o">)</span>

<span class="kn">section</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="n">include</span> <span class="n">Pt</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">refl</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">:</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L</span> <span class="o">:=</span>
<span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₁</span> <span class="o">:=</span>
<span class="n">or</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">h</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="err">∘</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp1</span><span class="o">,</span> <span class="n">hp2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp2</span><span class="o">,</span> <span class="n">hp1</span><span class="bp">⟩</span>
<span class="kn">end</span>
</pre></div>

<a name="185188262"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188262" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185188262">Johan Commelin (Jan 09 2020 at 07:05)</a>:</h4>
<p>Nice (-;</p>

<a name="185188603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185188603">Johan Commelin (Jan 09 2020 at 07:14)</a>:</h4>
<p>Kenny, I'm not sure if one can prove transitivity now</p>

<a name="185188608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185188608">Johan Commelin (Jan 09 2020 at 07:14)</a>:</h4>
<p>It seems one needs the crazy version of unique parallel for that</p>

<a name="185188686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185188686">Kenny Lau (Jan 09 2020 at 07:16)</a>:</h4>
<p>I haven't been following this discussion</p>

<a name="185188687"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188687" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185188687">Kenny Lau (Jan 09 2020 at 07:16)</a>:</h4>
<p>what are the axioms now?</p>

<a name="185188827"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188827" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185188827">Johan Commelin (Jan 09 2020 at 07:20)</a>:</h4>
<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span> </p>
<div class="codehilite"><pre><span></span><span class="kn">constant</span> <span class="n">unique_parallel</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="n">l₁</span> <span class="n">l₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">parallel</span> <span class="n">l</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">parallel</span> <span class="n">l</span> <span class="n">l₂</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span> <span class="bp">∧</span> <span class="n">belongs</span> <span class="n">p</span> <span class="n">l₁</span><span class="o">)</span> <span class="bp">→</span> <span class="n">l₁</span> <span class="bp">=</span> <span class="n">l₂</span>
</pre></div>

<a name="185188830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185188830">Johan Commelin (Jan 09 2020 at 07:20)</a>:</h4>
<p>I thought you could kick out the line <code>l</code>. But only once you know transivity...</p>

<a name="185188886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185188886">Kenny Lau (Jan 09 2020 at 07:22)</a>:</h4>
<p>isn't that covered by my <code>exists_unique_parallel</code>?</p>

<a name="185188894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185188894">Johan Commelin (Jan 09 2020 at 07:22)</a>:</h4>
<p>I didn't try too hard, but I couldn't write down a proof immediately</p>

<a name="185188997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185188997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185188997">Kenny Lau (Jan 09 2020 at 07:24)</a>:</h4>
<p>isn't that what it says?</p>

<a name="185189069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185189069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185189069">Johan Commelin (Jan 09 2020 at 07:26)</a>:</h4>
<p>I don't see how</p>

<a name="185189079"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185189079" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185189079">Johan Commelin (Jan 09 2020 at 07:27)</a>:</h4>
<p>Sorry, I'm confused. I think I understand now</p>

<a name="185189379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185189379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185189379">Johan Commelin (Jan 09 2020 at 07:35)</a>:</h4>
<p>/me should learn what <code>exists_unique</code> means</p>

<a name="185189391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185189391" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185189391">Johan Commelin (Jan 09 2020 at 07:35)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">section</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="n">include</span> <span class="n">Pt</span>

<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">by_cases</span> <span class="n">h₁₃</span> <span class="o">:</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₃</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">left</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="n">rcases</span> <span class="n">h₁₂</span> <span class="k">with</span> <span class="n">rfl</span><span class="bp">|</span><span class="n">h₁₂</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="n">rcases</span> <span class="n">h₂₃</span> <span class="k">with</span> <span class="n">rfl</span><span class="bp">|</span><span class="n">h₂₃</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="n">right</span><span class="o">,</span> <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">apply</span> <span class="n">h₁₃</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">H₁</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="bp">⟨</span><span class="n">H₂</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">symmetry</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
<span class="kn">end</span>

<span class="kn">end</span>
</pre></div>

<a name="185189694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185189694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185189694">Kenny Lau (Jan 09 2020 at 07:43)</a>:</h4>
<p>yay</p>

<a name="185189741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185189741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185189741">Bryan Gin-ge Chen (Jan 09 2020 at 07:44)</a>:</h4>
<p>Alternatively:</p>
<div class="codehilite"><pre><span></span><span class="kn">section</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="n">include</span> <span class="n">Pt</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">refl</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">:</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L</span> <span class="o">:=</span>
<span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₁</span> <span class="o">:=</span>
<span class="n">or</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">h</span> <span class="o">(</span><span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="err">∘</span> <span class="n">eq</span><span class="bp">.</span><span class="n">symm</span><span class="o">)</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span> <span class="err">$</span> <span class="bp">λ</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp1</span><span class="o">,</span> <span class="n">hp2</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp2</span><span class="o">,</span> <span class="n">hp1</span><span class="bp">⟩</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span> <span class="k">begin</span>
  <span class="n">by_cases</span> <span class="n">H</span> <span class="o">:</span> <span class="bp">∃</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₃</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rcases</span> <span class="n">H</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₃</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="k">have</span> <span class="o">:</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₃</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span>
      <span class="n">rcases</span> <span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span> <span class="k">with</span> <span class="bp">⟨</span><span class="n">L</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hp</span><span class="o">,</span> <span class="n">hL</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">h</span><span class="err">ᵤ</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hL₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">h</span><span class="err">ᵤ</span> <span class="n">L₁</span> <span class="bp">⟨</span><span class="n">h₁</span><span class="o">,</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="n">h₁₂</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="k">have</span> <span class="n">hL₁₃</span> <span class="o">:</span> <span class="n">L₃</span> <span class="bp">=</span> <span class="n">L</span> <span class="o">:=</span> <span class="n">h</span><span class="err">ᵤ</span> <span class="n">L₃</span> <span class="bp">⟨</span><span class="n">h₃</span><span class="o">,</span> <span class="n">h₂₃</span><span class="bp">⟩</span><span class="o">,</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">hL₁₂</span><span class="o">,</span> <span class="n">hL₁₃</span><span class="o">],</span>
    <span class="o">},</span>
    <span class="n">subst</span> <span class="n">this</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">exact</span> <span class="n">H</span><span class="o">,</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>

<a name="185190025"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185190025" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185190025">Johan Commelin (Jan 09 2020 at 07:51)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">apply</span> <span class="n">classical</span><span class="bp">.</span><span class="n">or_iff_not_imp_right</span><span class="bp">.</span><span class="n">mpr</span><span class="o">,</span> <span class="n">rw</span> <span class="n">not_not</span><span class="o">,</span>
  <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">H₁</span><span class="o">,</span> <span class="bp">_⟩</span> <span class="bp">⟨</span><span class="n">H₂</span><span class="o">,</span> <span class="bp">_⟩</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">symmetry</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">assumption</span> <span class="o">},</span>
<span class="kn">end</span>
</pre></div>

<a name="185191352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185191352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185191352">Johan Commelin (Jan 09 2020 at 08:17)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">),</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₃</span><span class="o">)</span> <span class="bp">→</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₃</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">classical</span><span class="bp">.</span><span class="n">or_iff_not_imp_right</span><span class="bp">.</span><span class="n">mpr</span><span class="o">,</span> <span class="n">rwa</span> <span class="n">not_not</span><span class="o">,</span> <span class="o">},</span>
  <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">)</span><span class="bp">;</span> <span class="n">finish</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>I wish there was a hammer that would kill the second line.</p>

<a name="185191530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185191530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185191530">Johan Commelin (Jan 09 2020 at 08:21)</a>:</h4>
<p>The following script really captures the essentials of the proof, I think:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">jmc_wishes</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">suffices</span> <span class="o">:</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">),</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₃</span><span class="o">)</span> <span class="bp">→</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₃</span><span class="o">,</span> <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">∃!</span> <span class="o">(</span><span class="n">L&#39;</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L&#39;</span> <span class="bp">∧</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L&#39;</span> <span class="o">:=</span> <span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>The <code>sorry</code>s should be filled in with a 1-word hammer tactic.</p>

<a name="185191898"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185191898" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185191898">Bryan Gin-ge Chen (Jan 09 2020 at 08:28)</a>:</h4>
<p>In honor of Kenny's term proofs of <code>refl</code> and <code>symm</code>, I present this monstrosity:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans_t</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span> <span class="o">(</span><span class="n">classical</span><span class="bp">.</span><span class="n">em</span> <span class="o">(</span><span class="bp">∃</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₃</span><span class="o">))</span><span class="bp">.</span><span class="n">elim</span>
    <span class="o">(</span><span class="bp">λ</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">h₁</span><span class="o">,</span> <span class="n">h₃</span><span class="bp">⟩</span><span class="o">,</span> <span class="n">or</span><span class="bp">.</span><span class="n">inl</span> <span class="err">$</span>
      <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">)</span>
        <span class="bp">⟨</span><span class="n">h₁</span><span class="o">,</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="n">h₁₂</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">h₃</span><span class="o">,</span> <span class="n">h₂₃</span><span class="bp">⟩</span><span class="o">)</span> <span class="n">or</span><span class="bp">.</span><span class="n">inr</span>
</pre></div>

<a name="185192158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185192158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185192158">Johan Commelin (Jan 09 2020 at 08:32)</a>:</h4>
<p>I changed the definition of parallel:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">noncomputable</span> <span class="n">theory</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="n">class</span> <span class="n">has_parallel</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">parallel</span> <span class="o">:</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∥</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">has_parallel</span><span class="bp">.</span><span class="n">parallel</span>

<span class="n">class</span> <span class="n">pre_geometry</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">has_mem</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="bp">.</span>

<span class="kn">instance</span> <span class="n">pre_geometry</span><span class="bp">.</span><span class="n">has_parallel</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_parallel</span> <span class="n">Ln</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">L₁</span> <span class="n">L₂</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">),</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">→</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₂</span><span class="bp">⟩</span>

<span class="n">class</span> <span class="n">geometry</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_unique_ln_bw_two_pts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">},</span> <span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p₁</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">p₂</span> <span class="err">∈</span> <span class="n">L</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_unique_parallel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="bp">∃!</span> <span class="n">L&#39;</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L&#39;</span> <span class="bp">∧</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L&#39;</span><span class="o">)</span>

<span class="kn">section</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="n">include</span> <span class="n">Pt</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">refl</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">:</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₁</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">⟩</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>
<span class="kn">end</span>

<span class="kn">section</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="n">include</span> <span class="n">Pt</span>

<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rintro</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">),</span>
  <span class="n">all_goals</span> <span class="o">{</span> <span class="n">split</span><span class="bp">;</span> <span class="n">assumption</span> <span class="bp">&lt;|&gt;</span> <span class="n">symmetry</span><span class="bp">;</span> <span class="n">assumption</span> <span class="o">}</span>
<span class="kn">end</span>

<span class="kn">end</span>
</pre></div>

<a name="185192311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185192311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185192311">Bryan Gin-ge Chen (Jan 09 2020 at 08:34)</a>:</h4>
<p>That lets you remove the <code>noncomputable theory</code> and <code>open_locale classical</code>.</p>

<a name="185192344"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185192344" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185192344">Johan Commelin (Jan 09 2020 at 08:35)</a>:</h4>
<p>Ooh, maybe I should revert my change...</p>

<a name="185192881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185192881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185192881">Johan Commelin (Jan 09 2020 at 08:43)</a>:</h4>
<p>Using namespaces:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="n">class</span> <span class="n">has_parallel</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">parallel</span> <span class="o">:</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∥</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">has_parallel</span><span class="bp">.</span><span class="n">parallel</span>

<span class="n">class</span> <span class="n">pre_geometry</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">has_mem</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="bp">.</span>

<span class="kn">instance</span> <span class="n">pre_geometry</span><span class="bp">.</span><span class="n">has_parallel</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">[</span><span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span> <span class="o">:</span> <span class="n">has_parallel</span> <span class="n">Ln</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">L₁</span> <span class="n">L₂</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">),</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">→</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₂</span><span class="bp">⟩</span>

<span class="n">class</span> <span class="n">geometry</span> <span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kn">extends</span> <span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_unique_ln_bw_two_pts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">},</span> <span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p₁</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">p₂</span> <span class="err">∈</span> <span class="n">L</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_unique_parallel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="bp">∃!</span> <span class="n">L&#39;</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L&#39;</span> <span class="bp">∧</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L&#39;</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">has_parallel</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">pre_geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="n">include</span> <span class="n">Pt</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">refl</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">:</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₁</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">⟩</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kn">end</span> <span class="n">has_parallel</span>

<span class="kn">namespace</span> <span class="n">has_parallel</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">[</span><span class="n">geometry</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
<span class="n">include</span> <span class="n">Pt</span>

<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span>
<span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">H₁</span><span class="o">,</span> <span class="n">h₁₂</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">H₂</span><span class="o">,</span> <span class="n">h₂₃</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">has_parallel</span>
</pre></div>

<a name="185193026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185193026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185193026">Mario Carneiro (Jan 09 2020 at 08:45)</a>:</h4>
<p>mario the linter says <code>pre_geometry.has_parallel</code> is bad</p>

<a name="185193062"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185193062" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185193062">Johan Commelin (Jan 09 2020 at 08:45)</a>:</h4>
<p>Did I goof up?</p>

<a name="185193159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185193159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185193159">Mario Carneiro (Jan 09 2020 at 08:46)</a>:</h4>
<p>it's a bit tricky; you can't infer that instance because <code>Pt</code> is dangling</p>

<a name="185193197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185193197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185193197">Mario Carneiro (Jan 09 2020 at 08:47)</a>:</h4>
<p>I think you should bundle a geometry and extract <code>Pt</code> and <code>Ln</code> components</p>

<a name="185193209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185193209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185193209">Johan Commelin (Jan 09 2020 at 08:47)</a>:</h4>
<p>Makes sense</p>

<a name="185194139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185194139" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185194139">Johan Commelin (Jan 09 2020 at 09:00)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> Something like?</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">pre_geometry</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">[</span><span class="n">has_mem</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>
</pre></div>

<a name="185194260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185194260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185194260">Kenny Lau (Jan 09 2020 at 09:02)</a>:</h4>
<blockquote>
<p>it's a bit tricky; you can't infer that instance because <code>Pt</code> is dangling</p>
</blockquote>
<p>I was thinking of using <code>out_param</code></p>

<a name="185194741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185194741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185194741">Johan Commelin (Jan 09 2020 at 09:11)</a>:</h4>
<p>I guess that for potential "applications" that might be better.</p>

<a name="185194796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185194796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185194796">Johan Commelin (Jan 09 2020 at 09:12)</a>:</h4>
<p>I currently have:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="n">class</span> <span class="n">has_parallel</span> <span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">parallel</span> <span class="o">:</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="n">Ln</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∥</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">has_parallel</span><span class="bp">.</span><span class="n">parallel</span>

<span class="kn">structure</span> <span class="n">pre_geometry</span> <span class="o">:</span> <span class="kt">Type</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">Pt</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">Ln</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">[</span><span class="n">has_mem</span> <span class="o">:</span> <span class="n">has_mem</span> <span class="n">Pt</span> <span class="n">Ln</span><span class="o">]</span>

<span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">pre_geometry</span><span class="bp">.</span><span class="n">has_mem</span>

<span class="kn">instance</span> <span class="n">pre_geometry</span><span class="bp">.</span><span class="n">has_parallel</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">pre_geometry</span><span class="o">}</span> <span class="o">:</span> <span class="n">has_parallel</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Ln</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">L₁</span> <span class="n">L₂</span><span class="o">,</span> <span class="o">(</span><span class="bp">∃</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Pt</span><span class="o">),</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₁</span> <span class="bp">∧</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">→</span> <span class="n">L₁</span> <span class="bp">=</span> <span class="n">L₂</span><span class="bp">⟩</span>

<span class="n">class</span> <span class="n">geometry</span> <span class="kn">extends</span> <span class="n">pre_geometry</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">exists_unique_ln_bw_two_pts</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">p₁</span> <span class="n">p₂</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">},</span> <span class="n">p₁</span> <span class="bp">≠</span> <span class="n">p₂</span> <span class="bp">→</span> <span class="bp">∃!</span> <span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p₁</span> <span class="err">∈</span> <span class="n">L</span> <span class="bp">∧</span> <span class="n">p₂</span> <span class="err">∈</span> <span class="n">L</span><span class="o">)</span>
<span class="o">(</span><span class="n">exists_unique_parallel</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">Pt</span><span class="o">)</span> <span class="o">(</span><span class="n">L</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">),</span> <span class="bp">∃!</span> <span class="n">L&#39;</span> <span class="o">:</span> <span class="n">Ln</span><span class="o">,</span> <span class="n">p</span> <span class="err">∈</span> <span class="n">L&#39;</span> <span class="bp">∧</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L&#39;</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">has_parallel</span>
<span class="kn">variables</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">pre_geometry</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">refl</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">refl</span> <span class="o">{</span><span class="n">L</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Ln</span><span class="o">}</span> <span class="o">:</span> <span class="n">L</span> <span class="err">∥</span> <span class="n">L</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">_</span><span class="o">,</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">symm</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">symm</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₁</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">⟩</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">hp</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span>

<span class="kn">end</span> <span class="n">has_parallel</span>

<span class="kn">namespace</span> <span class="n">has_parallel</span>
<span class="kn">variables</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">geometry</span><span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">trans</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">trans</span> <span class="o">{</span><span class="n">L₁</span> <span class="n">L₂</span> <span class="n">L₃</span> <span class="o">:</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Ln</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁₂</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₂</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂₃</span> <span class="o">:</span> <span class="n">L₂</span> <span class="err">∥</span> <span class="n">L₃</span><span class="o">)</span> <span class="o">:</span> <span class="n">L₁</span> <span class="err">∥</span> <span class="n">L₃</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="bp">⟨</span><span class="n">p</span><span class="o">,</span> <span class="n">H₁</span><span class="o">,</span> <span class="n">H₂</span><span class="bp">⟩</span><span class="o">,</span>
<span class="n">unique_of_exists_unique</span> <span class="o">(</span><span class="n">geometry</span><span class="bp">.</span><span class="n">exists_unique_parallel</span> <span class="n">p</span> <span class="n">L₂</span><span class="o">)</span> <span class="bp">⟨</span><span class="n">H₁</span><span class="o">,</span> <span class="n">h₁₂</span><span class="bp">.</span><span class="n">symm</span><span class="bp">⟩</span> <span class="bp">⟨</span><span class="n">H₂</span><span class="o">,</span> <span class="n">h₂₃</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">has_parallel</span>
</pre></div>


<p>I don't really like the <code>Ω.Ln</code> etc...</p>

<a name="185195161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185195161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185195161">Mario Carneiro (Jan 09 2020 at 09:18)</a>:</h4>
<p>would <code>Ln Ω</code> make you feel better?</p>

<a name="185195214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185195214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185195214">Johan Commelin (Jan 09 2020 at 09:19)</a>:</h4>
<p>Not that much ...</p>

<a name="185195297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185195297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185195297">Johan Commelin (Jan 09 2020 at 09:20)</a>:</h4>
<p>Maybe <code>Ω</code> should be a parameter?</p>

<a name="185195632"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185195632" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185195632">Kenny Lau (Jan 09 2020 at 09:25)</a>:</h4>
<p>maybe we should build an example</p>

<a name="185215812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185215812" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185215812">Matt Earnshaw (Jan 09 2020 at 14:24)</a>:</h4>
<p>it's helpful to see experienced folk grappling with this. need to learn typeclasses and structures properly to totally get it but this is neat. -- <span class="user-mention" data-user-id="112680">@Johan Commelin</span> in your most recent version above is it possible to write down equivalence as a term of  type <code>equivalence ...</code>? (I tried like <code>equivalence parallel</code> in the has_parallel namespace but it seems not quite right)</p>

<a name="185218688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185218688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185218688">Johan Commelin (Jan 09 2020 at 14:54)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt Earnshaw</span> Voila:</p>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">has_parallel</span>
<span class="kn">open</span> <span class="n">parallel</span>
<span class="kn">variables</span> <span class="o">{</span><span class="err">Ω</span> <span class="o">:</span> <span class="n">geometry</span><span class="o">}</span>

<span class="kn">lemma</span> <span class="n">parallel</span><span class="bp">.</span><span class="n">equivalence</span> <span class="o">:</span> <span class="n">equivalence</span> <span class="o">(</span><span class="n">pre_geometry</span><span class="bp">.</span><span class="n">has_parallel</span> <span class="o">:</span> <span class="n">has_parallel</span> <span class="err">Ω</span><span class="bp">.</span><span class="n">Ln</span><span class="o">)</span><span class="bp">.</span><span class="n">parallel</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">refl</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span> <span class="bp">λ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">h₁</span><span class="bp">.</span><span class="n">trans</span> <span class="n">h₂</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">has_parallel</span>
</pre></div>

<a name="185218793"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185218793" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185218793">Johan Commelin (Jan 09 2020 at 14:55)</a>:</h4>
<p>Because I <code>open parallel</code>, I can just write <code>refl</code> instead of <code>parallel.refl</code> in the proof.</p>

<a name="185226097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185226097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185226097">Matt Earnshaw (Jan 09 2020 at 16:05)</a>:</h4>
<p>thanks. that starts to look a bit inelegant but i won't worry about it at this stage. trying to push on with Theorem 2.2 concerning pencils of parallel lines. as a test I tried the following:</p>
<div class="codehilite"><pre><span></span>def pencil (l : Ω.Ln) := {m : Ω.Ln | l ∥ m}

lemma pencil_of_line_contains_line (l : Ω.Ln) : l ∈ pencil l := parallel.refl
</pre></div>


<p>which works, but I don't really understand how lean figures out that <code>parallel.refl</code> is a term of <code>l ∈ pencil l</code> ?</p>

<a name="185226841"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185226841" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185226841">Bryan Gin-ge Chen (Jan 09 2020 at 16:12)</a>:</h4>
<p><code>set Ln</code> is the type of predicates on <code>Ln</code>, i.e. functions from <code>Ln</code> to <code>Prop</code>. In particular <code>x ∈ { y | P }</code> means the same thing as <code>P x</code>. Thus <code>l ∈ pencil l</code> translates to <code>l ∥ l</code>.</p>
<p>(edit: I thought there was some discussion of this in TPiL or Logic &amp; Proof but I didn't see any. However, the start of <a href="https://github.com/leanprover-community/lean/blob/master/library/init/data/set.lean" target="_blank" title="https://github.com/leanprover-community/lean/blob/master/library/init/data/set.lean">init.logic</a> is fairly readable.)</p>

<a name="185227288"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185227288" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185227288">Johan Commelin (Jan 09 2020 at 16:16)</a>:</h4>
<p><span class="user-mention" data-user-id="247064">@Matt Earnshaw</span> I should note that <code>equivalence</code> isn't used that much in mathlib. On the other hand, the three lemmas tagged with <code>@[refl]</code>, <code>@[symm]</code> and <code>@[trans]</code> are very useful.</p>

<a name="185227363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/attempt%20at%20some%20geometry/near/185227363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/35829attemptatsomegeometry.html#185227363">Johan Commelin (Jan 09 2020 at 16:17)</a>:</h4>
<p>For quotients by equivalence relations, we use <code>setoid</code>, but you don't want that here</p>


{% endraw %}

{% include archive_update.html %}