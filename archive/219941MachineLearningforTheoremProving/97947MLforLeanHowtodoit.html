---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/index.html">Machine Learning for Theorem Proving</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html">ML for Lean: How to do it?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="186014952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186014952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186014952">Jason Rute (Jan 18 2020 at 22:46)</a>:</h4>
<p>I want to start the conversation of how to enable machine learning for Lean 3 and Lean 4.  Of course there isn't just one application of machine learning or one type of machine learning.  Right now, I can see two immediate applications/connections of machine learning and Lean:</p>
<ul>
<li>Extending <a href="https://sites.google.com/view/holist/home" target="_blank" title="https://sites.google.com/view/holist/home">HOList</a> to Lean.  I’ve already started a <a href="https://gist.github.com/jasonrute/00109af2bdc0974d2e8e79faf26ba556" target="_blank" title="https://gist.github.com/jasonrute/00109af2bdc0974d2e8e79faf26ba556">document here</a> on what this would take (and if we are serious about doing this, the N2Formal team at Google AI would probably be willing to provide some assistance).  At first this would probably be more of a machine learning benchmark than a useable system, but I think we could also incorporate it into (a forked version of) Lean with some work.</li>
<li><a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Proposal.3A.20Apply.20premise.20selection.20to.20Hammer" title="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Proposal.3A.20Apply.20premise.20selection.20to.20Hammer">Adding machine learning premise selection to the Lean hammer project</a></li>
</ul>
<p>Here are the four areas where machine learning will eventually need to interface with Lean.</p>
<ol>
<li><strong>At the tactic level.</strong>  If we are to ever use ML <em>from within</em> Lean, there would be to have tactics which apply machine learning under the hood.  The tactics could behave like <code>simp</code> and close the goal, or like <code>library_search</code> and suggest a proof which doesn’t use machine learning.  Both have their uses.  @Gabriel Ebner has <a href="http://www.andrew.cmu.edu/user/avigad/meetings/fomm2020/slides/fomm_ebner.pdf" target="_blank" title="http://www.andrew.cmu.edu/user/avigad/meetings/fomm2020/slides/fomm_ebner.pdf">already implemented something like this in Lean 3</a> with his Lean <code>hammer</code> tactic.  The tactic uses C++ for premise selection which means it could interface with TensorFlow or PyTorch instead.  However, it also sounds like to do this he had to hack Lean to make it work.  <strong>So it sounds like we know how to do this in Lean 3, and hopefully it will be easier in Lean 4 (where we don’t have to fork Lean to make this work).  However, one probably needs to document this more to see what is possible.</strong></li>
<li><strong>Theorem dependency recording and statistics.</strong> For some applications of machine learning, it is important to have training data.  The minimum needed for something like HOList is a list of theorems statements (and either their dependencies or a linear order of theorems where the dependencies come before the theorem which uses it).  For the hammer premise selection, one needs something similar, the list of premises used for the proof of each theorem (and for further training, the premises actually used in the hammer proof).  It sounds like (at least for the hammer project) @Gabriel Ebner <a href="#narrow/stream/113488-general/topic/Hammer.20talk" title="#narrow/stream/113488-general/topic/Hammer.20talk">has a script which generates this information</a>.  It might not be in the form needed by the HOList project however.  Others have talked about how Lean stores theorems in the “environment”, although I don't understand the details. <strong>So it sounds like we have at least one way to do this in Lean 3 if not more.  Again, the question remains of what form this information is available in and what needs it meets.  I wonder if this will be easier in Lean 4.</strong></li>
<li><strong>(Optional) Full proof recording at the tactic level</strong> For supervised learning of tactics (and again this is NOT needed for HOList, but could be a nice to have), one needs recorded tactic proofs (so one needs the tactics used and their parameters).  I have no idea if there is any work done here and if this is easy or hard.</li>
<li><strong>Outside communication and control of Lean’s tactic framework</strong>  For a system like DeepHOL/HOList, one needs to (from within Python preferably) control a tactic search inside of Lean.  Let me describe how this currently works in DeepHOL/HOList.  A forked HOL Light version is put in a docker container.  This container also contains a gRPC server which takes three request types.  These requests are sent to the HOL Light docker container server from another docker container which handles the proof guidance and training.)  The three requests are as follows: ApplyTactic says “apply [tactic] with [parameters] to [goal]."  Then the server tries that in HOL Light and if it succeeds, it returns a new list of goals.  VerifyProof says “check if [list of tactics with parameters] solves [theorem/goal]."  Last, RegisterTheorem registers a theorem so that it can be called later by the system.  (Technically, in HOList it has to be the most recently verified theorem.  Also, it returns an integer fingerprint of the theorem.)  For a more detailed descriptions of how these three requests work, see <a href="https://github.com/jasonrute/holist-communication-example/blob/master/walkthrough_of_holist_api.ipynb" target="_blank" title="https://github.com/jasonrute/holist-communication-example/blob/master/walkthrough_of_holist_api.ipynb">here</a>.  For DeepHOL/HOList or a similar system we would probably need to build something like this communication interface.  (For DeepHOL/HOList, we would probably need to implement these three commands, but it might be good to step back and think about how this could be done to support other systems besides DeepHOL.) Some have mentioned there is already <a href="https://github.com/dselsam/lean-python-bindings" target="_blank" title="https://github.com/dselsam/lean-python-bindings">Python bindings for Lean</a> which does something like this.  Others have mentioned that the LSP handles stuff like this.  It would be great to discuss this more concretely.  <strong>Is there a clear path to implementing something like this in Lean 3?  (It doesn’t need to be that fast, so we should try the easiest to implement idea first I think.)  Will this be easier in Lean 4?</strong></li>
</ol>

<a name="186070121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186070121" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186070121">Jason Rute (Jan 20 2020 at 02:54)</a>:</h4>
<p>I looked a bit into <a href="https://github.com/dselsam/lean-python-bindings" target="_blank" title="https://github.com/dselsam/lean-python-bindings">Daniel's old Python bindings for Lean</a>.  They aren't documented, but the test code gives a hint at what they can do.  It looks promising.  However, I can't get them installed correctly.  (It is probably my own not understanding C++ and other things involved in the install.)  Someone suggested also that the bindings my not work with current Lean.  Has anyone got them to work recently?</p>

<a name="186070522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186070522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186070522">Jason Rute (Jan 20 2020 at 03:09)</a>:</h4>
<p>Also, I think I said something wrong about LSP.  I suggested that Lean 3 uses LSP.  That will be Lean 4 I guess.  Lean 3 I guess can communicate with <code>lean --server</code> <a href="#narrow/stream/113488-general/topic/guides/near/184985918" title="#narrow/stream/113488-general/topic/guides/near/184985918">by sending JSON messages via STDIN and reading JSON responses from STDOUT</a>.  It seems that one can deduce the Lean 3 message format from the <a href="https://github.com/leanprover/lean-client-js/tree/master/lean-client-js-core/" target="_blank" title="https://github.com/leanprover/lean-client-js/tree/master/lean-client-js-core/">lean-client-js-core</a> package.  Honestly, this is getting outside my wheelhouse, so I would have to do a lot of digging and learning to figure out how this all works.  However, if I do, I'll try to write some descriptions of what is possible here and if it fits the needs of something like DeepHOL.</p>

<a name="186070634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186070634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186070634">Bryan Gin-ge Chen (Jan 20 2020 at 03:13)</a>:</h4>
<p>Feel free to ask here if you've got questions about Lean 3's server mode!</p>

<a name="186071195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186071195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186071195">Jesse Michael Han (Jan 20 2020 at 03:30)</a>:</h4>
<p>you can observe the Lean 3 server protocol in Emacs by enabling <code>M-x lean-turn-on-debug-mode</code></p>

<a name="186071312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186071312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186071312">Bryan Gin-ge Chen (Jan 20 2020 at 03:34)</a>:</h4>
<p>You can also see it action in the <a href="https://leanprover-community.github.io/lean-web-editor/" target="_blank" title="https://leanprover-community.github.io/lean-web-editor/">community web editor</a> if you click the question mark and scroll down to the "Debug settings" and then open your browser's console.</p>

<a name="186143472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186143472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186143472">Jason Rute (Jan 21 2020 at 00:37)</a>:</h4>
<p>Taking <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>'s advice, I looked at Lean's server mode through the <a href="https://leanprover-community.github.io/lean-web-editor/" target="_blank" title="https://leanprover-community.github.io/lean-web-editor/">community web editor</a>.  First, I could only get it to work on Firefox (it didn't work on Safari or Chrome on my Mac).  Second, when <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> says my "browser's console", that means go to Tools &gt; Web Developer &gt; Web Console.</p>

<a name="186143475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186143475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186143475">Jason Rute (Jan 21 2020 at 00:37)</a>:</h4>
<p>From my limited experimentation, there appears to be three requests one can make of the server, "info", "sync", and "complete".  I'm still trying to figure out what these three do.  I should probably next try to interact directly with the Lean3 server via python.  Until I do that, it appears that "sync" does most of the heavy lifting.  It appears to send the whole file contents.</p>
<div class="codehilite"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;sync&quot;</span><span class="p">,</span>
  <span class="nt">&quot;file_name&quot;</span><span class="p">:</span> <span class="s2">&quot;/test.lean&quot;</span><span class="p">,</span>
  <span class="nt">&quot;content&quot;</span><span class="p">:</span> <span class="s2">&quot;example (m n : ℕ) : m + n = n + m :=\nby refl&quot;</span><span class="p">,</span>
  <span class="nt">&quot;seq_num&quot;</span><span class="p">:</span> <span class="mi">40</span>
<span class="p">}</span>
</pre></div>


<p>And then one gets back responses about the state of the file, including messages about tactics which don't work.</p>
<div class="codehilite"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;msgs&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&quot;caption&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
      <span class="nt">&quot;file_name&quot;</span><span class="p">:</span> <span class="s2">&quot;/test.lean&quot;</span><span class="p">,</span>
      <span class="nt">&quot;pos_col&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;pos_line&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
      <span class="nt">&quot;severity&quot;</span><span class="p">:</span> <span class="s2">&quot;error&quot;</span><span class="p">,</span>
      <span class="nt">&quot;text&quot;</span><span class="p">:</span> <span class="s2">&quot;invalid apply tactic, failed to unify\n  m + n = n + m\nwith\n  ?m_2 = ?m_2\nstate:\nm n : ℕ\n⊢ m + n = n + m&quot;</span>
    <span class="p">}</span>
  <span class="p">],</span>
  <span class="nt">&quot;response&quot;</span><span class="p">:</span> <span class="s2">&quot;all_messages&quot;</span>
<span class="p">}</span>
</pre></div>


<p>The "info" command seems for getting more information about variable types, squiggly lines, and other information displayed in the side bar.  I think the "complete" command is for autocompletion.  (Again, using a Python (or other) client to manually communicate with <code>lean --server</code> would make all this more clear.)</p>

<a name="186143481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186143481" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186143481">Jason Rute (Jan 21 2020 at 00:38)</a>:</h4>
<p>If the "sync" command is the natural way to use try out tactics on a goal via Lean3 server, that would be a pretty blunt tool, but could be workable.  One could enter the goal with a hole (e.g. <code>example (m n : ℕ) : m + n = n + m := begin end</code>).  Then one can try filling in the hole with various tactics and see what the responses are, including the new goal state (e.g. enter <code>example (m n : ℕ) : m + n = n + m := begin induction n end</code>).  However, it seems that the agent would have to interact with the actual Lean code and parse the pretty printed human readable responses (e.g. the agent would have to parse: <code>"tactic failed, there are unsolved goals\nstate:\n2 goals\ncase nat.zero\nm : ℕ\n⊢ m + 0 = 0 + m\n\ncase nat.succ\nm n_n : ℕ,\nn_ih : m + n_n = n_n + m\n⊢ m + nat.succ n_n = nat.succ n_n + m"</code>).  This isn't impossible.  There are only a few message templates the agent would have to deal with and possibly one could turn off some pretty printers to make the formulas more machine readable.  Nonetheless, I think something like the Python bindings look more promising.</p>

<a name="186143525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186143525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186143525">Jason Rute (Jan 21 2020 at 00:38)</a>:</h4>
<p>Am I understanding this correctly, <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>?</p>

<a name="186144329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186144329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186144329">Jason Rute (Jan 21 2020 at 01:02)</a>:</h4>
<p>With pretty printing, the goal mentioned above is:</p>
<div class="codehilite"><pre><span></span>tactic failed, there are unsolved goals
state:
2 goals
case nat.zero
m : ℕ
⊢ m + 0 = 0 + m
case nat.succ
m n_n : ℕ,
n_ih : m + n_n = n_n + m
⊢ m + nat.succ n_n = nat.succ n_n + m
</pre></div>


<p>After setting <code>set_option pp.all true</code>, it becomes</p>
<div class="codehilite"><pre><span></span>tactic failed, there are unsolved goals
state:
2 goals
case nat.zero
m : nat
⊢ @eq.{1} nat (@has_add.add.{0} nat nat.has_add m nat.zero) (@has_add.add.{0} nat nat.has_add nat.zero m)

case nat.succ
m n_n : nat,
n_ih : @eq.{1} nat (@has_add.add.{0} nat nat.has_add m n_n) (@has_add.add.{0} nat nat.has_add n_n m)
⊢ @eq.{1} nat (@has_add.add.{0} nat nat.has_add m (nat.succ n_n)) (@has_add.add.{0} nat nat.has_add (nat.succ n_n) m)
</pre></div>


<p>which is fairly machine parsable (on a level similar to the s-expressions used by HOList/DeepHOL).  Given that tools like HOList don't need the fastest server, it would be interesting to see if something like the HOList server interface could be built from the Lean server.</p>

<a name="186144616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186144616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186144616">Bryan Gin-ge Chen (Jan 21 2020 at 01:10)</a>:</h4>
<p>Most of what you wrote about the commands looks correct to me. There are actually a few more commands like "search" and "hole", that are used for text editor integration. If you can read typescript, you can also get an idea of the interface for the server commands by browsing <a href="https://github.com/leanprover/lean-client-js/blob/master/lean-client-js-core/src/server.ts" target="_blank" title="https://github.com/leanprover/lean-client-js/blob/master/lean-client-js-core/src/server.ts">this</a> and <a href="https://github.com/leanprover/lean-client-js/blob/master/lean-client-js-core/src/commands.ts" target="_blank" title="https://github.com/leanprover/lean-client-js/blob/master/lean-client-js-core/src/commands.ts">this</a> from <code>lean-client-js-core</code>.</p>
<blockquote>
<p>However, it seems that the agent would have to interact with the actual Lean code and parse the pretty printed human readable responses</p>
</blockquote>
<p>I'm not a Lean metaprogramming expert, but I think it should be possible to write meta code which will return whatever info you want in machine-readable form as well. For instance, the info in the error messages you quoted is available from <code>tactic.local_context</code>. See <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md">mathlib's "tactic writing" tutorial</a> for some more info.</p>
<p>The hole commands might also be interesting to you, since they let you trigger Lean meta code at positions in the code ("holes") that are surrounded by <code>{!</code> and <code>!}</code>. Among other things, you can write meta code which returns a string in the "replacements" field of the response message; you might be able to use this to query Lean for something you're interested in and return it in JSON or some other format. <a href="https://github.com/leanprover-community/mathlib/blob/ff2a41e4579d2238b8864e2bd072831a2006a808/docs/holes.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/ff2a41e4579d2238b8864e2bd072831a2006a808/docs/holes.md">Here's</a> some docs on the hole commands provided by mathlib.</p>

<a name="186144989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186144989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186144989">Jason Rute (Jan 21 2020 at 01:19)</a>:</h4>
<p>Ok interesting.  Thanks!</p>

<a name="186146224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186146224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186146224">Reid Barton (Jan 21 2020 at 01:51)</a>:</h4>
<p>From what I recall, if you've used Lean from inside VS Code/emacs, you've pretty much directly experienced all the functionality the server mode has to offer</p>

<a name="186146645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186146645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186146645">Jason Rute (Jan 21 2020 at 02:03)</a>:</h4>
<p>The more I think about it, this VS Code/emacs functionality is probably all that is needed to reproduce something like the HOList interface.  I think the only added thing would be to use a small amount of custom meta programming to get the outputs (such as the current goal state after applying a tactic) in the most useful form.  (And even this is optional since the current text outputs are fairly useful and parsable.)  The only worries I have is that (1) it is not fast enough, and (2) the idea I have of how to implement it is too hacky.  Maybe I'll sketch out my idea soon since it is pretty straightforward.</p>

<a name="186178485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186178485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186178485">Jason Rute (Jan 21 2020 at 12:41)</a>:</h4>
<p>Here is how one could implement something very similar to HOList’s API but for Lean, using the Lean server.  (As with the HOList API, I am assuming tactics are only applied to single goals and not to lists of goals.)</p>

<a name="186178492"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186178492" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186178492">Jason Rute (Jan 21 2020 at 12:41)</a>:</h4>
<p>The HOList API has an <code>ApplyTactic</code> request which sends a goal and a tactic command (with parameters).  The response is either a success or failure.  A success returns the new goal state. In the Lean Server (ignoring right now the details of how to represent formulas), all I would have to do is take my goal:</p>
<div class="codehilite"><pre><span></span><span class="n">m</span> <span class="n">n_n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">,</span>
<span class="n">n_ih</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n_n</span> <span class="bp">=</span> <span class="n">n_n</span> <span class="bp">+</span> <span class="n">m</span>
<span class="err">⊢</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n_n</span> <span class="bp">=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n_n</span> <span class="bp">+</span> <span class="n">m</span>
</pre></div>


<p>and my tactic (plus parameters) <code>induction m</code>.<br>
Next, I convert this all to an <code>example</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">m</span> <span class="n">n_n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
        <span class="o">(</span><span class="n">n_ih</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n_n</span> <span class="bp">=</span> <span class="n">n_n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">)</span>
        <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n_n</span> <span class="bp">=</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n_n</span> <span class="bp">+</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">induction</span> <span class="n">m</span>
<span class="kn">end</span>
</pre></div>


<p>I put this in a file and run sync on it.</p>

<a name="186178541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186178541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186178541">Jason Rute (Jan 21 2020 at 12:42)</a>:</h4>
<p>Implementing HOList’s <code>VerifyProof</code> request is even more straight forward.  It is given a theorem (e.g. <code>⊢ ∀  m n : nat, m + n = n + m</code>) and a proof which is a list of tactics (with parameters) (e.g. [<code>intro</code>, <code>intro</code>, <code>simp</code>]) and returns whether that proof succeeds.  Just put it into a file and check it with the server:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="bp">∀</span>  <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">intro</span><span class="bp">;</span>
<span class="n">intro</span><span class="bp">;</span>
<span class="n">simp</span>
<span class="kn">end</span>
</pre></div>

<a name="186178558"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186178558" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186178558">Jason Rute (Jan 21 2020 at 12:42)</a>:</h4>
<p>Finally there is HOList’s <code>RegisterTheorem</code>.  If one is using it to register a theorem (e.g. <code>(m n_n : ℕ) ⊢ m + n = n + m</code>) one just needs to enter the theorem into Lean with a unique identifier.  If one is ok with sorries, then</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">thm_1862938746298</span> <span class="o">(</span><span class="n">m</span> <span class="n">n_n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">sorry</span>
</pre></div>


<p>If like HOList, one wants to use the proof from VerifyProof (see my documentation of the HOList API), then use the proof (just [<code>simp</code>] in this case):</p>
<div class="codehilite"><pre><span></span><span class="kn">theorem</span> <span class="n">thm_1862938746298</span> <span class="o">(</span><span class="n">m</span> <span class="n">n_n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">simp</span>
<span class="kn">end</span>
</pre></div>


<p>These registered theorems should probably go in another file so they don’t have to be checked every time.</p>

<a name="186178568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186178568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186178568">Jason Rute (Jan 21 2020 at 12:42)</a>:</h4>
<p>Also, there is adding definitions via <code>RegisterTheorem</code>.  Again, this seems straight forward.</p>

<a name="186178574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186178574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186178574">Jason Rute (Jan 21 2020 at 12:42)</a>:</h4>
<p>It think the next thing would be to try this out (calling the Lean server as above) in a simple Python client to make sure it works.</p>

<a name="186178580"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186178580" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186178580">Jason Rute (Jan 21 2020 at 12:42)</a>:</h4>
<p>I’m not saying this will 100% fulfill the HOList API since that was intended for HOL Light, but it will get 90% of the way there.  Then we can have a discussion about the other 10%.  (Ok, maybe that remaining 10% will take 90% of the time.  One still needs to catalog the Lean tactics and their parameters for example.)</p>

<a name="186228304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186228304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186228304">Christian Szegedy (Jan 21 2020 at 21:14)</a>:</h4>
<p>We would be super happy to help supporting Lean from HOList. End of last October I asked Daniel Selsam his opinion of integration. <br>
He suggested us to wait until Lean 4 is ready (suggested that it would take several months on their side to get there) . </p>
<p>I think that given the relative simplicity of our interface and the HOL Light interface as a template, it should not be a huge amount of work to integrate Lean with HOList and our team would be very happy to support this integration on our side.</p>

<a name="186236639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186236639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186236639">Jason Rute (Jan 21 2020 at 22:49)</a>:</h4>
<p>The official line of MIcrosoft Research does seem to be “wait until Lean 4”, and this makes sense.  It is a waste of their time to support Lean 3.  Nonetheless, there is a large and vibrant community using (and hacking) Lean 3, and it isn’t unreasonable to build something in Lean 3.  If nothing else, it helps make clear what we need in Lean 4.  From my investigation so far it is plausible that the lean server can be used to implement something like HOList for Lean 3.  (And there would be no need to fork Lean.)  IMO, after building a hacked together Lean 3 to DeepHOL interface (which lives safely in a Docker container), that would provide a template for a more flexible Lean-to-MLGym interface that would satisfy more researcher’s needs.</p>

<a name="186237107"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186237107" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186237107">Simon Hudon (Jan 21 2020 at 22:55)</a>:</h4>
<p>Speaking as someone who's both hacking on Lean 3.5 and Lean 4, I don't see using Lean 3 as a waste of time.</p>

<a name="186237316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186237316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186237316">Simon Hudon (Jan 21 2020 at 22:57)</a>:</h4>
<p>Porting code from Lean 3 to Lean 4 might not be completely straightforward but what you learned about Lean 3 should be transferable to Lean 4. Lean 4 is really an attempt at making all the goodies that the community loves in Lean 3 even better. If you discover a pain point (that others haven't discovered) you can already point it out and it could get better in Lean 4</p>

<a name="186237434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186237434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186237434">Simon Hudon (Jan 21 2020 at 22:59)</a>:</h4>
<p>(I say "it could get better" because it has to fit in the overall vision of Lean 4, we won't introduce ML-style modules for instance)</p>

<a name="186237459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186237459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186237459">Minchao Wu (Jan 21 2020 at 22:59)</a>:</h4>
<p>Interacting with the Lean server is basically how Rob and I implemented the interface between Lean 3 and Mathematica. Jesse and I had also discussed the possibility of doing this for ML at last year’s ITP. Talking to Lean server should be fine, the challenging part is parsing and managing proof states from what returned from Lean. For that we probably want some meta-programs to do it for us, and that’s why Jesse and I have also decided (for now) to wait until Lean 4 to see if there are new meta-level tools to use.</p>

<a name="186555403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186555403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186555403">Jason Rute (Jan 25 2020 at 03:40)</a>:</h4>
<p><span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> I've been playing around with the lean server.  The good news is that I can get it to behave in a back-and-forth manner where I feed it a goal and a tactic and it tells me if that tactic succeeds and what the goal state is.  The bad news is that it is really slow.  The only way I can reliably get it to work is to:</p>
<ul>
<li>feed in my partial proof to a "sync" request</li>
<li>wait for it to send back an "all_messages" response</li>
<li>parse that response<br>
This takes consistently about .1 seconds which is REALLY slow for this sort of simple round trip. I thought I can use the "info" request instead (which is much faster), but that is unreliable.  The response to an info request is often referencing a previous version of the file before the sync request.  Do you know of a faster way, or is this a fundamental limitation of the lean server that it takes .1 seconds to fully process a sync request.</li>
</ul>

<a name="186555577"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186555577" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186555577">Jason Rute (Jan 25 2020 at 03:46)</a>:</h4>
<p>Also, a way to make the info request reliable is to use a new file for each call, but again if I do that it is still 0.1 seconds per call, so there is no speed up to use the "info" request.</p>

<a name="186555858"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186555858" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186555858">Jason Rute (Jan 25 2020 at 03:56)</a>:</h4>
<p>For Google research, I think 0.1 seconds would be fine (and I understand that some tactics would inherently take a while to execute), but it would make it hard for us mere mortals to do cool stuff.</p>

<a name="186556185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186556185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186556185">Bryan Gin-ge Chen (Jan 25 2020 at 04:06)</a>:</h4>
<p>Unfortunately I don't know of a faster way. Maybe <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> might have ideas?</p>

<a name="186556257"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186556257" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186556257">Jason Rute (Jan 25 2020 at 04:09)</a>:</h4>
<p>And, either way, I'll play more with this and put some simple code on GitHub in the hopes that:</p>
<ul>
<li>Someone with a lot of computing power (e.g. Google research) can make use of it</li>
<li>Someone who knows better can tell me a faster way</li>
<li>Those building Lean 4 know what the sort of things those in ML would like to be able to do.</li>
</ul>

<a name="186557120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186557120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186557120">Mario Carneiro (Jan 25 2020 at 04:41)</a>:</h4>
<p>I think the more sustainable option is to hack lean to have an appropriate RPC or FFI interface</p>

<a name="186559313"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186559313" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186559313">Jason Rute (Jan 25 2020 at 05:56)</a>:</h4>
<p>I was worried someone would say that.  I know Daniel Selsam has some old hacked <a href="https://github.com/dselsam/lean-python-bindings" target="_blank" title="https://github.com/dselsam/lean-python-bindings">Lean python bindings</a> (which I don't think currently work).  I don't know if those might be along the same lines.  Anyway, I don't think I'm going to start mucking in the Lean C++ code soon, but someone else is welcome and encouraged to try.</p>

<a name="186588867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186588867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186588867">Jason Rute (Jan 25 2020 at 21:11)</a>:</h4>
<p>Ok, with batching (sending about 32 multiple goals/tactics to the same sync request) gives me about a 15x speedup.  I don't know that I can do much better with the Lean server, but 7 ms does seem more reasonable than 100 ms.</p>

<a name="186588922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186588922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186588922">Jason Rute (Jan 25 2020 at 21:13)</a>:</h4>
<p>By comparison, HOList takes about 3ms, so it is comparable (but that is without batching).</p>

<a name="186742467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186742467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186742467">Christian Szegedy (Jan 28 2020 at 00:47)</a>:</h4>
<blockquote>
<p>For Google research, I think 0.1 seconds would be fine (and I understand that some tactics would inherently take a while to execute), but it would make it hard for us mere mortals to do cool stuff.</p>
</blockquote>
<p>Currently our timeout for proving is 5 seconds, because we make heavy use of the MESON tactic. We have a lot of other overhead, especially neural networks become the bottleneck if we go to sub-second range. We are perfectly fine with 0.1 second for now.</p>

<a name="186760471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186760471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186760471">Stanislas Polu (Jan 28 2020 at 08:03)</a>:</h4>
<blockquote>
<p>Currently our timeout for proving is 5 seconds, because we make heavy use of the MESON tactic. We have a lot of other overhead, especially neural networks become the bottleneck if we go to sub-second range. We are perfectly fine with 0.1 second for now.</p>
</blockquote>
<p>On that note, are these the default config on the docker image?</p>

<a name="186839725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186839725" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186839725">Jason Rute (Jan 28 2020 at 23:05)</a>:</h4>
<p>Ok, for those interested, here is a <a href="https://github.com/jasonrute/communicating-with-lean/blob/master/communicate_with_lean.ipynb" target="_blank" title="https://github.com/jasonrute/communicating-with-lean/blob/master/communicate_with_lean.ipynb">prototype of communicating with Lean via the Lean Server from an external program</a>.    It looks like it is possible to implement a Lean version of HOList's <code>ApplyTactic</code> request.  I think the next step would be to see if we can get a list of all Lean theorems and if we can plug them into this interface (specifically see if we can run the do-nothing <code>skip</code> tactic on the theorem goal).  I'm not entirely happy with how this turned out.  The Lean server is really not intended for this purpose and had to be fought with a lot, but I think it works now (if a bit slowly).</p>

<a name="186840485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186840485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186840485">Jason Rute (Jan 28 2020 at 23:15)</a>:</h4>
<p>Also, if anyone is interested in using the Lean server for another purpose (other than a text editor/IDE) I hope this would give them inspiration.</p>

<a name="186840703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186840703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186840703">Jason Rute (Jan 28 2020 at 23:19)</a>:</h4>
<p><span class="user-mention" data-user-id="116045">@Jesse Michael Han</span> I think you told me you can get a List of all theorems from the environment.  How does one do this?</p>

<a name="186840788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186840788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186840788">Scott Morrison (Jan 28 2020 at 23:20)</a>:</h4>
<p>Don't have time to go into detail now, but look at the implementation of <code>library_search</code>, which does exactly this.</p>

<a name="186841186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186841186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186841186">Minchao Wu (Jan 28 2020 at 23:27)</a>:</h4>
<p>You can also find similar implementation in our Mathematica-Lean link repo</p>

<a name="186841188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186841188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186841188">Minchao Wu (Jan 28 2020 at 23:27)</a>:</h4>
<p><a href="https://github.com/minchaowu/mm-lean/blob/master/src/dump.lean" target="_blank" title="https://github.com/minchaowu/mm-lean/blob/master/src/dump.lean">https://github.com/minchaowu/mm-lean/blob/master/src/dump.lean</a></p>

<a name="186841353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186841353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186841353">Minchao Wu (Jan 28 2020 at 23:30)</a>:</h4>
<p>By the way, we’ve done similar things (i.e., an interface with experimental RL results) to HOL4, which is to appear in this year’s AITP.</p>

<a name="186843148"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186843148" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186843148">Jason Rute (Jan 28 2020 at 23:54)</a>:</h4>
<p>Oh cool.  I look forward to reading all the slides and abstracts from AITP this year.</p>

<a name="186843368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186843368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186843368">Jason Rute (Jan 28 2020 at 23:56)</a>:</h4>
<p>Also, <span class="user-mention" data-user-id="110187">@Minchao Wu</span>, did you interface with Mathematica in a similar way to how I did it above?  You used the lean server, right?</p>

<a name="186843645"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186843645" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186843645">Minchao Wu (Jan 28 2020 at 23:59)</a>:</h4>
<p>Yes, it works the same way as I can see from you repo, except that there is no python scripts involved. The Lean server subprocess is handled directly by Mathematica.</p>

<a name="186843896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186843896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186843896">Minchao Wu (Jan 29 2020 at 00:01)</a>:</h4>
<p>We also called the virtual file "dummy.lean" :-)</p>

<a name="186857523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186857523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186857523">Jason Rute (Jan 29 2020 at 05:30)</a>:</h4>
<p>Thank you <span class="user-mention" data-user-id="110187">@Minchao Wu</span> !  Your code has been very helpful, but it also points out a number of subtle flaws in my current implementation.  I was too quick to claim victory. :(</p>
<ul>
<li>I don't handle universes, so if I try to put in the goal <code>Π {α : Sort u} {a : α} {p : α → Sort v} {b : α}, a == b → p a → p b</code>, Lean will complain about <code>u</code> and <code>v</code>.  I could store the universes with the goal, and use a section to enter them, so that isn't a huge deal-breaker.</li>
<li>Lean's pretty printed goal output is not necessarily valid lean code.  Example, this is the Lean pretty printed theorem, but <code>∀ (s : list char), string.mk_iterator {data := s} = {fst := list.nil char, snd := s}</code> is not valid Lean.  The problem is that in <code>list.nil char</code>, the <code>char</code> is implicit (the type of <code>list.nil</code> is <code>Π {T : Type}, list T</code>).  I would have to know to enter it as <code>@list.nil char</code> or know that the <code>char</code> can be inferred.  Similarly, <code>and.symm = and.swap</code> isn't valid Lean.  It needs to be <code>∀ a b : Prop, @and.symm a b = @and.swap a b</code></li>
<li>Without knowing the theorems exact place, Lean can't fill in type classes.  For example, if I try to enter <code>∀ (c : Prop) [_inst_1 : decidable c] (a b : ordering), ite c a b = ordering.gt = ite c (a = ordering.gt) (b = ordering.gt)</code> I get complaints about "failed to synthesize type class instance [...]".</li>
<li>This isn't a problem with my app, but it should be noted that auto-generated equation theorems for definitions and type class instances get outputted in the dump.  For example,<code> ∀ {α : Type u₁} {β : Type u₂} (a : α) (b : β), combinator.K a b = a</code> and <code>∀ {α : Type u}, list.has_append = {append := list.append α}</code>.  They aren't really something that is "provable" except using themselves.  At least <code>refl</code> solves them.</li>
</ul>

<a name="186859952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186859952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186859952">Jesse Michael Han (Jan 29 2020 at 06:39)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="116045">Jesse Michael Han</span> I think you told me you can get a List of all theorems from the environment.  How does one do this?</p>
</blockquote>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span>  you can do something like this in Lean (the code in <code>library_search</code> is a bit more specialized, but essentially does the same thing):</p>
<div class="codehilite"><pre><span></span><span class="n">meta</span> <span class="n">def</span> <span class="n">process_thm</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">declaration</span><span class="o">)</span> <span class="o">:</span> <span class="n">option</span> <span class="n">declaration</span> <span class="o">:=</span>
<span class="k">let</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">d</span><span class="bp">.</span><span class="n">to_name</span> <span class="k">in</span>
  <span class="k">if</span> <span class="bp">¬</span> <span class="n">d</span><span class="bp">.</span><span class="n">is_trusted</span> <span class="bp">∨</span> <span class="n">n</span><span class="bp">.</span><span class="n">is_internal</span> <span class="k">then</span> <span class="n">none</span>
  <span class="k">else</span> <span class="k">match</span> <span class="n">d</span> <span class="k">with</span>
       <span class="bp">|</span> <span class="n">declaration</span><span class="bp">.</span><span class="n">defn</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">none</span>
       <span class="bp">|</span> <span class="n">t</span><span class="bp">@</span><span class="o">(</span><span class="n">declaration</span><span class="bp">.</span><span class="n">thm</span> <span class="n">n</span> <span class="n">ns</span> <span class="n">e</span> <span class="n">te</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">t</span>
       <span class="bp">|</span> <span class="n">declaration</span><span class="bp">.</span><span class="n">cnst</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">none</span>
       <span class="bp">|</span> <span class="n">declaration</span><span class="bp">.</span><span class="n">ax</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">none</span>
       <span class="kn">end</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">library_thms</span> <span class="o">:</span> <span class="n">tactic</span> <span class="err">$</span> <span class="n">list</span> <span class="n">declaration</span> <span class="o">:=</span>
  <span class="n">environment</span><span class="bp">.</span><span class="n">decl_filter_map</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">get_env</span> <span class="bp">&lt;*&gt;</span> <span class="n">return</span> <span class="n">process_thm</span>

<span class="n">meta</span> <span class="n">def</span> <span class="n">list_all_theorems</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
  <span class="n">do</span> <span class="n">library_thms</span> <span class="bp">&gt;&gt;=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">trace</span> <span class="o">(</span><span class="n">declaration</span><span class="bp">.</span><span class="n">to_name</span> <span class="bp">&lt;</span><span class="err">$</span><span class="bp">&gt;</span> <span class="n">x</span><span class="o">)</span>

<span class="n">run_cmd</span> <span class="n">list_all_theorems</span>
</pre></div>

<a name="186864181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186864181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186864181">Patrick Massot (Jan 29 2020 at 08:12)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span> Did you look at how format_lean and the lean crawler handle all those issues? <a href="https://github.com/leanprover-community/leancrawler" target="_blank" title="https://github.com/leanprover-community/leancrawler">leancrawler</a> is entirely devoted to listing declarations and statistics about them. And <a href="https://github.com/leanprover-community/format_lean" target="_blank" title="https://github.com/leanprover-community/format_lean">format_lean</a> does need tactic state information from python, implementing a very rough interface at <a href="https://github.com/leanprover-community/format_lean/blob/master/src/format_lean/server.py" target="_blank" title="https://github.com/leanprover-community/format_lean/blob/master/src/format_lean/server.py">https://github.com/leanprover-community/format_lean/blob/master/src/format_lean/server.py</a>.</p>

<a name="186876591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186876591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186876591">Minchao Wu (Jan 29 2020 at 11:23)</a>:</h4>
<p><span class="user-mention" data-user-id="115715">@Jason Rute</span>  The issues you mentioned are exactly some of the many reasons we prefer to delay the implementation until Lean 4. There could be even more issues with parsing and managing proof states, e.g., sometimes you might also see meta-variables occurring in the local context so that you can't directly send them back (as-is) to Lean as assumptions. <br>
For toy examples, the hardcore parsing as you have done would work well, but for serious theorems we probably need a more robust (and fast) system. It seems to me that the ideal way of doing it is having a Lean meta-program that manages proof states for us, and return directly Python-readable objects containing the information we need. In that case, Python only needs to be responsible for sending proper requests and doing machine learning.</p>

<a name="186876802"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186876802" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186876802">Minchao Wu (Jan 29 2020 at 11:26)</a>:</h4>
<p>Also this is why we prefer systems that implement a simple type theory (at current stage). Too much information about types not only increases the amount of knowledge the agent needs to learn, but also complicates proof states management.</p>

<a name="186886365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186886365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186886365">Jason Rute (Jan 29 2020 at 13:44)</a>:</h4>
<p><span class="user-mention" data-user-id="110187">@Minchao Wu</span>  When you say "the hardcore parsing", do you mean parsing the whole syntax tree of the expression?  (I assume if we have that, we could reconstruct the expression in Lean, but even then I'm not sure if it has everything to unambiguously do that.)</p>

<a name="186886846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186886846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186886846">Minchao Wu (Jan 29 2020 at 13:51)</a>:</h4>
<p>I mean parsing the pretty-printed responses from the server on the Python side</p>

<a name="186887038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186887038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186887038">Minchao Wu (Jan 29 2020 at 13:53)</a>:</h4>
<blockquote>
<p>...but even then I'm not sure if it has everything to unambiguously do that.)</p>
</blockquote>
<p>Yes, hopefully Lean 4 would offer us more tools.</p>


{% endraw %}

{% include archive_update.html %}