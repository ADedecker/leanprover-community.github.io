---
layout: archive
title: Lean Prover Zulip Chat Archive
permalink: archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/index.html">Machine Learning for Theorem Proving</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html">ML for Lean: How to do it?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">

{% raw %}
<a name="186014952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186014952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186014952">Jason Rute (Jan 18 2020 at 22:46)</a>:</h4>
<p>I want to start the conversation of how to enable machine learning for Lean 3 and Lean 4.  Of course there isn't just one application of machine learning or one type of machine learning.  Right now, I can see two immediate applications/connections of machine learning and Lean:</p>
<ul>
<li>Extending <a href="https://sites.google.com/view/holist/home" target="_blank" title="https://sites.google.com/view/holist/home">HOList</a> to Lean.  I’ve already started a <a href="https://gist.github.com/jasonrute/00109af2bdc0974d2e8e79faf26ba556" target="_blank" title="https://gist.github.com/jasonrute/00109af2bdc0974d2e8e79faf26ba556">document here</a> on what this would take (and if we are serious about doing this, the N2Formal team at Google AI would probably be willing to provide some assistance).  At first this would probably be more of a machine learning benchmark than a useable system, but I think we could also incorporate it into (a forked version of) Lean with some work.</li>
<li><a href="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Proposal.3A.20Apply.20premise.20selection.20to.20Hammer" title="#narrow/stream/219941-Machine-Learning.20for.20Theorem.20Proving/topic/Proposal.3A.20Apply.20premise.20selection.20to.20Hammer">Adding machine learning premise selection to the Lean hammer project</a></li>
</ul>
<p>Here are the four areas where machine learning will eventually need to interface with Lean.</p>
<ol>
<li><strong>At the tactic level.</strong>  If we are to ever use ML <em>from within</em> Lean, there would be to have tactics which apply machine learning under the hood.  The tactics could behave like <code>simp</code> and close the goal, or like <code>library_search</code> and suggest a proof which doesn’t use machine learning.  Both have their uses.  @Gabriel Ebner has <a href="http://www.andrew.cmu.edu/user/avigad/meetings/fomm2020/slides/fomm_ebner.pdf" target="_blank" title="http://www.andrew.cmu.edu/user/avigad/meetings/fomm2020/slides/fomm_ebner.pdf">already implemented something like this in Lean 3</a> with his Lean <code>hammer</code> tactic.  The tactic uses C++ for premise selection which means it could interface with TensorFlow or PyTorch instead.  However, it also sounds like to do this he had to hack Lean to make it work.  <strong>So it sounds like we know how to do this in Lean 3, and hopefully it will be easier in Lean 4 (where we don’t have to fork Lean to make this work).  However, one probably needs to document this more to see what is possible.</strong></li>
<li><strong>Theorem dependency recording and statistics.</strong> For some applications of machine learning, it is important to have training data.  The minimum needed for something like HOList is a list of theorems statements (and either their dependencies or a linear order of theorems where the dependencies come before the theorem which uses it).  For the hammer premise selection, one needs something similar, the list of premises used for the proof of each theorem (and for further training, the premises actually used in the hammer proof).  It sounds like (at least for the hammer project) @Gabriel Ebner <a href="#narrow/stream/113488-general/topic/Hammer.20talk" title="#narrow/stream/113488-general/topic/Hammer.20talk">has a script which generates this information</a>.  It might not be in the form needed by the HOList project however.  Others have talked about how Lean stores theorems in the “environment”, although I don't understand the details. <strong>So it sounds like we have at least one way to do this in Lean 3 if not more.  Again, the question remains of what form this information is available in and what needs it meets.  I wonder if this will be easier in Lean 4.</strong></li>
<li><strong>(Optional) Full proof recording at the tactic level</strong> For supervised learning of tactics (and again this is NOT needed for HOList, but could be a nice to have), one needs recorded tactic proofs (so one needs the tactics used and their parameters).  I have no idea if there is any work done here and if this is easy or hard.</li>
<li><strong>Outside communication and control of Lean’s tactic framework</strong>  For a system like DeepHOL/HOList, one needs to (from within Python preferably) control a tactic search inside of Lean.  Let me describe how this currently works in DeepHOL/HOList.  A forked HOL Light version is put in a docker container.  This container also contains a gRPC server which takes three request types.  These requests are sent to the HOL Light docker container server from another docker container which handles the proof guidance and training.)  The three requests are as follows: ApplyTactic says “apply [tactic] with [parameters] to [goal]."  Then the server tries that in HOL Light and if it succeeds, it returns a new list of goals.  VerifyProof says “check if [list of tactics with parameters] solves [theorem/goal]."  Last, RegisterTheorem registers a theorem so that it can be called later by the system.  (Technically, in HOList it has to be the most recently verified theorem.  Also, it returns an integer fingerprint of the theorem.)  For a more detailed descriptions of how these three requests work, see <a href="https://github.com/jasonrute/holist-communication-example/blob/master/walkthrough_of_holist_api.ipynb" target="_blank" title="https://github.com/jasonrute/holist-communication-example/blob/master/walkthrough_of_holist_api.ipynb">here</a>.  For DeepHOL/HOList or a similar system we would probably need to build something like this communication interface.  (For DeepHOL/HOList, we would probably need to implement these three commands, but it might be good to step back and think about how this could be done to support other systems besides DeepHOL.) Some have mentioned there is already <a href="https://github.com/dselsam/lean-python-bindings" target="_blank" title="https://github.com/dselsam/lean-python-bindings">Python bindings for Lean</a> which does something like this.  Others have mentioned that the LSP handles stuff like this.  It would be great to discuss this more concretely.  <strong>Is there a clear path to implementing something like this in Lean 3?  (It doesn’t need to be that fast, so we should try the easiest to implement idea first I think.)  Will this be easier in Lean 4?</strong></li>
</ol>

<a name="186070121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186070121" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186070121">Jason Rute (Jan 20 2020 at 02:54)</a>:</h4>
<p>I looked a bit into <a href="https://github.com/dselsam/lean-python-bindings" target="_blank" title="https://github.com/dselsam/lean-python-bindings">Daniel's old Python bindings for Lean</a>.  They aren't documented, but the test code gives a hint at what they can do.  It looks promising.  However, I can't get them installed correctly.  (It is probably my own not understanding C++ and other things involved in the install.)  Someone suggested also that the bindings my not work with current Lean.  Has anyone got them to work recently?</p>

<a name="186070522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186070522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186070522">Jason Rute (Jan 20 2020 at 03:09)</a>:</h4>
<p>Also, I think I said something wrong about LSP.  I suggested that Lean 3 uses LSP.  That will be Lean 4 I guess.  Lean 3 I guess can communicate with <code>lean --server</code> <a href="#narrow/stream/113488-general/topic/guides/near/184985918" title="#narrow/stream/113488-general/topic/guides/near/184985918">by sending JSON messages via STDIN and reading JSON responses from STDOUT</a>.  It seems that one can deduce the Lean 3 message format from the <a href="https://github.com/leanprover/lean-client-js/tree/master/lean-client-js-core/" target="_blank" title="https://github.com/leanprover/lean-client-js/tree/master/lean-client-js-core/">lean-client-js-core</a> package.  Honestly, this is getting outside my wheelhouse, so I would have to do a lot of digging and learning to figure out how this all works.  However, if I do, I'll try to write some descriptions of what is possible here and if it fits the needs of something like DeepHOL.</p>

<a name="186070634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186070634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186070634">Bryan Gin-ge Chen (Jan 20 2020 at 03:13)</a>:</h4>
<p>Feel free to ask here if you've got questions about Lean 3's server mode!</p>

<a name="186071195"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186071195" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186071195">Jesse Michael Han (Jan 20 2020 at 03:30)</a>:</h4>
<p>you can observe the Lean 3 server protocol in Emacs by enabling <code>M-x lean-turn-on-debug-mode</code></p>

<a name="186071312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186071312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186071312">Bryan Gin-ge Chen (Jan 20 2020 at 03:34)</a>:</h4>
<p>You can also see it action in the <a href="https://leanprover-community.github.io/lean-web-editor/" target="_blank" title="https://leanprover-community.github.io/lean-web-editor/">community web editor</a> if you click the question mark and scroll down to the "Debug settings" and then open your browser's console.</p>

<a name="186143472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186143472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186143472">Jason Rute (Jan 21 2020 at 00:37)</a>:</h4>
<p>Taking <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>'s advice, I looked at Lean's server mode through the <a href="https://leanprover-community.github.io/lean-web-editor/" target="_blank" title="https://leanprover-community.github.io/lean-web-editor/">community web editor</a>.  First, I could only get it to work on Firefox (it didn't work on Safari or Chrome on my Mac).  Second, when <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span> says my "browser's console", that means go to Tools &gt; Web Developer &gt; Web Console.</p>

<a name="186143475"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186143475" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186143475">Jason Rute (Jan 21 2020 at 00:37)</a>:</h4>
<p>From my limited experimentation, there appears to be three requests one can make of the server, "info", "sync", and "complete".  I'm still trying to figure out what these three do.  I should probably next try to interact directly with the Lean3 server via python.  Until I do that, it appears that "sync" does most of the heavy lifting.  It appears to send the whole file contents.</p>
<div class="codehilite"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;sync&quot;</span><span class="p">,</span>
  <span class="nt">&quot;file_name&quot;</span><span class="p">:</span> <span class="s2">&quot;/test.lean&quot;</span><span class="p">,</span>
  <span class="nt">&quot;content&quot;</span><span class="p">:</span> <span class="s2">&quot;example (m n : ℕ) : m + n = n + m :=\nby refl&quot;</span><span class="p">,</span>
  <span class="nt">&quot;seq_num&quot;</span><span class="p">:</span> <span class="mi">40</span>
<span class="p">}</span>
</pre></div>


<p>And then one gets back responses about the state of the file, including messages about tactics which don't work.</p>
<div class="codehilite"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;msgs&quot;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&quot;caption&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
      <span class="nt">&quot;file_name&quot;</span><span class="p">:</span> <span class="s2">&quot;/test.lean&quot;</span><span class="p">,</span>
      <span class="nt">&quot;pos_col&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&quot;pos_line&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
      <span class="nt">&quot;severity&quot;</span><span class="p">:</span> <span class="s2">&quot;error&quot;</span><span class="p">,</span>
      <span class="nt">&quot;text&quot;</span><span class="p">:</span> <span class="s2">&quot;invalid apply tactic, failed to unify\n  m + n = n + m\nwith\n  ?m_2 = ?m_2\nstate:\nm n : ℕ\n⊢ m + n = n + m&quot;</span>
    <span class="p">}</span>
  <span class="p">],</span>
  <span class="nt">&quot;response&quot;</span><span class="p">:</span> <span class="s2">&quot;all_messages&quot;</span>
<span class="p">}</span>
</pre></div>


<p>The "info" command seems for getting more information about variable types, squiggly lines, and other information displayed in the side bar.  I think the "complete" command is for autocompletion.  (Again, using a Python (or other) client to manually communicate with <code>lean --server</code> would make all this more clear.)</p>

<a name="186143481"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186143481" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186143481">Jason Rute (Jan 21 2020 at 00:38)</a>:</h4>
<p>If the "sync" command is the natural way to use try out tactics on a goal via Lean3 server, that would be a pretty blunt tool, but could be workable.  One could enter the goal with a hole (e.g. <code>example (m n : ℕ) : m + n = n + m := begin end</code>).  Then one can try filling in the hole with various tactics and see what the responses are, including the new goal state (e.g. enter <code>example (m n : ℕ) : m + n = n + m := begin induction n end</code>).  However, it seems that the agent would have to interact with the actual Lean code and parse the pretty printed human readable responses (e.g. the agent would have to parse: <code>"tactic failed, there are unsolved goals\nstate:\n2 goals\ncase nat.zero\nm : ℕ\n⊢ m + 0 = 0 + m\n\ncase nat.succ\nm n_n : ℕ,\nn_ih : m + n_n = n_n + m\n⊢ m + nat.succ n_n = nat.succ n_n + m"</code>).  This isn't impossible.  There are only a few message templates the agent would have to deal with and possibly one could turn off some pretty printers to make the formulas more machine readable.  Nonetheless, I think something like the Python bindings look more promising.</p>

<a name="186143525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186143525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186143525">Jason Rute (Jan 21 2020 at 00:38)</a>:</h4>
<p>Am I understanding this correctly, <span class="user-mention" data-user-id="123965">@Bryan Gin-ge Chen</span>?</p>

<a name="186144329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186144329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186144329">Jason Rute (Jan 21 2020 at 01:02)</a>:</h4>
<p>With pretty printing, the goal mentioned above is:</p>
<div class="codehilite"><pre><span></span>tactic failed, there are unsolved goals
state:
2 goals
case nat.zero
m : ℕ
⊢ m + 0 = 0 + m
case nat.succ
m n_n : ℕ,
n_ih : m + n_n = n_n + m
⊢ m + nat.succ n_n = nat.succ n_n + m
</pre></div>


<p>After setting <code>set_option pp.all true</code>, it becomes</p>
<div class="codehilite"><pre><span></span>tactic failed, there are unsolved goals
state:
2 goals
case nat.zero
m : nat
⊢ @eq.{1} nat (@has_add.add.{0} nat nat.has_add m nat.zero) (@has_add.add.{0} nat nat.has_add nat.zero m)

case nat.succ
m n_n : nat,
n_ih : @eq.{1} nat (@has_add.add.{0} nat nat.has_add m n_n) (@has_add.add.{0} nat nat.has_add n_n m)
⊢ @eq.{1} nat (@has_add.add.{0} nat nat.has_add m (nat.succ n_n)) (@has_add.add.{0} nat nat.has_add (nat.succ n_n) m)
</pre></div>


<p>which is fairly machine parsable (on a level similar to the s-expressions used by HOList/DeepHOL).  Given that tools like HOList don't need the fastest server, it would be interesting to see if something like the HOList server interface could be built from the Lean server.</p>

<a name="186144616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186144616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186144616">Bryan Gin-ge Chen (Jan 21 2020 at 01:10)</a>:</h4>
<p>Most of what you wrote about the commands looks correct to me. There are actually a few more commands like "search" and "hole", that are used for text editor integration. If you can read typescript, you can also get an idea of the interface for the server commands by browsing <a href="https://github.com/leanprover/lean-client-js/blob/master/lean-client-js-core/src/server.ts" target="_blank" title="https://github.com/leanprover/lean-client-js/blob/master/lean-client-js-core/src/server.ts">this</a> and <a href="https://github.com/leanprover/lean-client-js/blob/master/lean-client-js-core/src/commands.ts" target="_blank" title="https://github.com/leanprover/lean-client-js/blob/master/lean-client-js-core/src/commands.ts">this</a> from <code>lean-client-js-core</code>.</p>
<blockquote>
<p>However, it seems that the agent would have to interact with the actual Lean code and parse the pretty printed human readable responses</p>
</blockquote>
<p>I'm not a Lean metaprogramming expert, but I think it should be possible to write meta code which will return whatever info you want in machine-readable form as well. For instance, the info in the error messages you quoted is available from <code>tactic.local_context</code>. See <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md">mathlib's "tactic writing" tutorial</a> for some more info.</p>
<p>The hole commands might also be interesting to you, since they let you trigger Lean meta code at positions in the code ("holes") that are surrounded by <code>{!</code> and <code>!}</code>. Among other things, you can write meta code which returns a string in the "replacements" field of the response message; you might be able to use this to query Lean for something you're interested in and return it in JSON or some other format. <a href="https://github.com/leanprover-community/mathlib/blob/ff2a41e4579d2238b8864e2bd072831a2006a808/docs/holes.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/ff2a41e4579d2238b8864e2bd072831a2006a808/docs/holes.md">Here's</a> some docs on the hole commands provided by mathlib.</p>

<a name="186144989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186144989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186144989">Jason Rute (Jan 21 2020 at 01:19)</a>:</h4>
<p>Ok interesting.  Thanks!</p>

<a name="186146224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine%20Learning%20for%20Theorem%20Proving/topic/ML%20for%20Lean%3A%20How%20to%20do%20it%3F/near/186146224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/219941MachineLearningforTheoremProving/97947MLforLeanHowtodoit.html#186146224">Reid Barton (Jan 21 2020 at 01:51)</a>:</h4>
<p>From what I recall, if you've used Lean from inside VS Code/emacs, you've pretty much directly experienced all the functionality the server mode has to offer</p>


{% endraw %}

{% include archive_update.html %}